# [[Оглавление]]

# Generics

Обобщения (Generics) в программировании — это механизм, позволяющий создавать классы, интерфейсы и методы, которые работают с типами данных, задаваемыми в качестве параметров. Это обеспечивает типобезопасность, повторное использование кода и уменьшение дублирования. В Java обобщения были введены в версии 1.5 и позволяют указывать, с какими типами данных будет работать класс или метод, избегая приведения типов и потенциальных ошибок во время выполнения.

# Type Erasure

Type Erasure — это процесс, при котором компилятор Java удаляет всю информацию об обобщённых типах во время компиляции, заменяя их либо на их верхнюю границу (bounded type), либо на `Object`, если границы не указаны. В результате в байт-коде (коде, выполняемом JVM) нет информации о конкретных типах, использованных в обобщениях. Это означает, что в runtime обобщённые типы недоступны, и JVM работает с "сырыми" типами или их границами.

# Принцип подстановки Барбары Лисков и его связь с обобщениями

Принцип подстановки Лисков гласит: если `S` — подтип `T`, то объекты типа `T` могут быть заменены объектами типа `S` без изменения свойств программы. Для обобщений это означает, что подтипы должны сохранять корректность типизации.

**Примеры отношений тип/подтип**:
- `Number` → `Integer`
- `List<E>` → `ArrayList<E>`
- `Collection<E>` → `List<E>`
- `Iterable<E>` → `Collection<E>`

# Ковариантность, контравариантность и инвариантность

**Ковариантность**: Сохраняет иерархию наследования. Если `Cat` — подтип `Animal`, то `Set<Cat>` — подтип `Set<Animal>`.
**Контравариантность**: Обращает иерархию. `Set<Animal>` — подтип `Set<Cat>`.
**Инвариантность**: Отсутствие наследования между производными типами. `Set<Cat>` и `Set<Animal>` не связаны.

# Raw type

Raw type - это типы у которых удалён Generic.
ArrayList — это Raw тип параметризованного ArrayList. Используя Raw типы, мы возвращаемся в эру до дженериков и сознательно отказываемся от всех фич, присущих параметризованным типам. Если мы попытаемся вызвать параметризованный метода у Raw типа, то компилятор выдаст нам предупреждение «Unchecked call». Если мы попытаемся выполнить присваивание ссылки на параметризованный тип Raw типу, то компилятор выдаст предупреждение «Unchecked assignment». Игнорирование этих предупреждений, как мы увидим позже, может привести к ошибкам во время выполнения нашего приложения.

# Чем отличается `T` от Wildcard

**T (Параметр типа)** — это **имя** для конкретного, но пока неизвестного типа. Вы используете T, когда объявляете обобщенный класс или метод, и вам нужно ссылаться на этот же тип в нескольких местах, например, для связи типа аргумента с возвращаемым значением. T позволяет вам как добавлять, так и извлекать элементы этого типа.

**? (Wildcard)** — это **неизвестный тип**. Вы используете его, чтобы сделать методы более гибкими, позволяя им работать с различными типами. ? идеально подходит для параметров методов, которые работают с коллекциями, но не зависят от конкретного типа элементов. С List вы можете безопасно только читать элементы (как Object), но не можете добавлять новые (кроме null), потому что компилятор не знает точный тип.

# Wildcard

Wildcard (`?`) — это синтаксис обобщений, обозначающий неизвестный тип или группу типов. Они увеличивают гибкость кода, сохраняя типобезопасность, и упрощают API.

Типы Wildcard:
1. **Unbounded Wildcard (`?`)**: `?` обозначает любой тип, но добавление элементов (кроме `null`) запрещено.
2. **Upper Bounded Wildcard (`? extends T`)**: Ограничивает типы подтипами `T`. Подходит для чтения данных.
3. **Lower Bounded Wildcard (`? super T`)**:Ограничивает типы супертипами `T`. Подходит для записи данных.



# PECS

PECS: **Producer Extends, Consumer Super**.
1. **Producer (`? extends T`)**: Для чтения данных.
2. **Consumer (`? super T`)**: Для записи данных.

# Wildcard Capture

Wildcard Capture — это механизм, позволяющий "захватить" неизвестный тип `?` и присвоить ему временный тип `T` для выполнения операций.

```java
public static void reverse(List<?> list) { rev(list); }

private static <T> void rev(List<T> list) {
    List<T> tmp = new ArrayList<T>(list);
    for (int i = 0; i < list.size(); i++) {
        list.set(i, tmp.get(list.size()-i-1));
    }
}
```

# Multiple Bounds

Ограничивают переменную типа несколькими типами через `&`. Первое ограничение используется для type erasure.

```java
<T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
```


# Reifiable типы

Reifiable типы — это типы, полностью доступные в runtime. Они не теряют информацию из-за type erasure.

**Примеры**:

- Примитивы: `int`, `double`.
- Raw types: `List`, `Map`.
- Классы: `String`, `Integer`.
- Массивы: `String[]`, `int[]`.

**Не-reifiable**:

- `List<String>`, `List<?>`, `T`.

# Heap Pollution

Heap Pollution — это ситуация, когда в коллекцию или массив добавляются объекты неверного типа, нарушая типобезопасность.

# Type Inference

Type Inference — это процесс, при котором компилятор определяет тип данных на основе контекста.
# Unchecked Warnings

Unchecked Warnings — это предупреждения компилятора о небезопасном использовании типов, например, при работе с raw types. Их можно игнорировать, но лучше исправить.

# [[Оглавление]]