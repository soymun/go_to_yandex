# [[Оглавление]]

# Reflection

Рефлексия — механизм получения данных о программе во время выполнения. Java Reflection API (`java.lang`, `java.lang.reflect`) позволяет: 
- Определять класс объекта. 
- Получать информацию о полях, методах, конструкторах, суперклассах. 
- Создавать экземпляры, вызывать методы, изменять поля.
# Unsafe

`Unsafe` — самый потенциально опасный (и, следовательно, мощный) инструмент, поскольку он позволяет делать определённые вещи, которые в иных условиях невозможны и которые нарушают устоявшиеся правила платформы.

Например, `Unsafe` позволяет разработчикам:
- Напрямую получать доступ к ЦП и другим аппаратным возможностям.
- Создавать объект, не запуская его конструктор.
- Создавать действительно анонимный класс без обычной проверки.
- Вручную управлять памятью за пределами кучи (_off-heap memory_).
- Делать многие другие, казалось бы, невозможные вещи.

Класс `Unsafe` из Java 8, `sun.misc.Unsafe`, сразу же предупреждает нас о своей природе — не только своим названием, но и пакетом, в котором он находится. Пакет `sun.misc` — это внутренний, специфичный для конкретной реализации пакет, и Java-код никогда не должен обращаться к нему напрямую. В Java 9 и более поздних версиях эта «закулисная» природа становится еще более очевидной, поскольку функциональность `Unsafe` была перенесена в модуль под названием `jdk.unsupported`.
# MethodHandler

Дескрипторы методов (_Method handles_) — это низкоуровневый механизм для поиска и вызова методов. Их часто сравнивают с рефлексией, поскольку и API рефлексии, и дескрипторы методов предоставляют средства для вызова методов, конструкторов и доступа к полям.

Что же именно представляет собой дескриптор метода? Это **напрямую вызываемая ссылка** на базовый метод, конструктор или поле. API дескрипторов методов позволяет выполнять манипуляции с этим простым указателем на метод, давая возможность вставлять или изменять порядок аргументов, преобразовывать возвращаемые значения и т. д.
# VarHandler

В общих чертах, **дескриптор переменной (`VarHandle`)** — это просто типизированная ссылка на переменную. Этой переменной может быть элемент массива, поле экземпляра или статическое поле класса. Класс `VarHandle` предоставляет доступ на чтение и запись к переменным при определённых условиях.
`VarHandle` являются **неизменяемыми (_immutable_)** и не имеют видимого состояния. Более того, от них нельзя наследоваться.

Каждый `VarHandle` имеет:

- Обобщённый тип `T`, который является типом каждой переменной, представленной этим `VarHandle`.
- Список **координатных типов `CT`** — это типы выражений-координат, которые позволяют найти переменную, на которую ссылается `VarHandle`.

Список координатных типов может быть пустым.

Цель `VarHandle` — определить стандарт для вызова операций, **эквивалентных** операциям из пакетов `java.util.concurrent.atomic` и `sun.misc.Unsafe`, над полями и элементами массивов.
В основном это **атомарные или упорядоченные операции** — например, атомарное увеличение значения поля.

# JDK Dynamic Proxy

**JDK Dynamic Proxy** — это механизм в стандартной библиотеке Java, который позволяет создавать прокси-объекты на лету (во время выполнения программы). Эти прокси-объекты могут "притворяться" реализациями одного или нескольких интерфейсов. Основная идея заключается в том, чтобы перехватывать вызовы методов к объекту и добавлять какую-либо дополнительную логику до или после выполнения основного метода. Это очень мощный инструмент для реализации так называемого **аспектно-ориентированного программирования (AOP)**, где сквозная функциональность, такая как логирование, управление транзакциями, кэширование или проверка безопасности, отделяется от основной бизнес-логики.

Для создания динамического прокси используются два ключевых элемента:
1. **`java.lang.reflect.Proxy`**: Это класс, который предоставляет статический метод `newProxyInstance()` для создания самого прокси-объекта.
2. **`java.lang.reflect.InvocationHandler`**: Это интерфейс, который необходимо реализовать. Его единственный метод `invoke()` будет вызываться каждый раз, когда кто-то пытается выполнить любой метод прокси-объекта. Внутри этого метода и заключается вся "магия": именно здесь вы решаете, что делать с перехваченным вызовом — передать его оригинальному объекту, изменить аргументы, залогировать вызов и так далее.
# [[Оглавление]]