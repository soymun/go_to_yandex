# [[Оглавление]]

# Reflection

**Reflection API** в Java — это мощный механизм, который позволяет изменять поведение классов, интерфейсов, полей и методов во время выполнения программы. По сути, это способ для программы посмотреть на саму себя и взаимодействовать со своим внутренним устройством. С помощью Reflection можно создавать экземпляры объектов, вызывать их методы и получать доступ к их полям, даже к приватным, не зная их имён на этапе компиляции. Основными классами в Reflection API являются `Class`, `Constructor`, `Method` и `Field`. Хотя это открывает широкие возможности для создания гибких фреймворков и библиотек (например, Spring или Hibernate активно его используют для внедрения зависимостей и маппинга объектов), его следует использовать с осторожностью. Вызовы через рефлексию работают значительно медленнее, чем прямой вызов методов, и могут нарушать принципы инкапсуляции, делая код менее безопасным и сложным для понимания.
# Unsafe

Класс `sun.misc.Unsafe` — это низкоуровневый, недокументированный и, как следует из названия, **небезопасный** инструмент, который предоставляет прямой доступ к операциям с памятью. Он не является частью стандартного публичного API Java, и его использование не рекомендуется в обычном прикладном программировании. `Unsafe` позволяет выполнять такие операции, как выделение и освобождение памяти в стиле языка C (минуя сборщик мусора), атомарные операции (compare-and-swap), прямое манипулирование полями объектов по их смещению в памяти и создание экземпляров классов без вызова конструктора. Этот класс используется внутри самого JDK для реализации многих стандартных библиотек, например, в `java.nio` для работы с буферами прямого доступа и в `java.util.concurrent` для реализации высокопроизводительных неблокирующих структур данных. Использование `Unsafe` может привести к сбоям JVM и трудноуловимым ошибкам, связанным с памятью, поэтому его применение оправдано только в тех редких случаях, когда требуется максимальная производительность.
# MethodHandler

**MethodHandle** — это современная и безопасная альтернатива Reflection API, появившаяся в Java 7. `MethodHandle` представляет собой типизированную, непосредственно исполняемую ссылку на метод, конструктор или поле. В отличие от рефлексивного объекта `Method`, `MethodHandle` не проверяет права доступа при каждом вызове, а делает это только один раз при создании, что делает его значительно быстрее. Он строго типизирован, то есть его тип (сигнатура) должен соответствовать типу вызываемого метода, что проверяется на этапе компиляции, а не во время выполнения. `MethodHandle` можно трансформировать: изменять его аргументы, возвращаемый тип или связывать с определённым экземпляром. Этот механизм является основой для реализации динамических языков на платформе JVM (через инструкцию `invokedynamic`) и используется в таких вещах, как лямбда-выражения в Java 8. Он предоставляет гибкость, близкую к рефлексии, но с производительностью, приближающейся к прямым вызовам.
# VarHandler

**VarHandle** — это объектное представление переменной, которое появилось в Java 9. Он является более общей и производительной заменой для атомарных классов из пакета `java.util.concurrent.atomic` и некоторых операций класса `sun.misc.Unsafe`. `VarHandle` предоставляет безопасный и стандартизированный способ для атомарных или упорядоченных операций над полями объектов и элементами массивов. Он поддерживает различные режимы доступа к памяти (memory access modes), которые определяют гарантии видимости и упорядочивания операций в многопоточной среде (например, `get`, `set`, `getVolatile`, `setOpaque`, `compareAndSet`). Это позволяет разработчикам писать высокопроизводительный, неблокирующий многопоточный код без прямого использования `Unsafe`. `VarHandle` обеспечивает безопасность типов и проверяется статически, что делает его надёжным инструментом для низкоуровневого конкурентного программирования.

# JDK Dynamic Proxy

**JDK Dynamic Proxy** — это механизм в стандартной библиотеке Java, который позволяет создавать прокси-объекты на лету (во время выполнения программы). Эти прокси-объекты могут "притворяться" реализациями одного или нескольких интерфейсов. Основная идея заключается в том, чтобы перехватывать вызовы методов к объекту и добавлять какую-либо дополнительную логику до или после выполнения основного метода. Это очень мощный инструмент для реализации так называемого **аспектно-ориентированного программирования (AOP)**, где сквозная функциональность, такая как логирование, управление транзакциями, кэширование или проверка безопасности, отделяется от основной бизнес-логики.

Для создания динамического прокси используются два ключевых элемента:
1. **`java.lang.reflect.Proxy`**: Это класс, который предоставляет статический метод `newProxyInstance()` для создания самого прокси-объекта.
2. **`java.lang.reflect.InvocationHandler`**: Это интерфейс, который необходимо реализовать. Его единственный метод `invoke()` будет вызываться каждый раз, когда кто-то пытается выполнить любой метод прокси-объекта. Внутри этого метода и заключается вся "магия": именно здесь вы решаете, что делать с перехваченным вызовом — передать его оригинальному объекту, изменить аргументы, залогировать вызов и так далее.
# [[Оглавление]]