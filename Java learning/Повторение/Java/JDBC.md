# JDBC

JDBC, Java DataBase Connectivity (соединение с базами данных на Java) — промышленный стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде пакета java.sql, входящего в состав Java SE. JDBC основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

Преимуществами JDBC считают:
1. Лёгкость разработки: разработчик может не знать специфики базы данных, с которой работает;
2. Код практически не меняется, если компания переходит на другую базу данных (количество изменений зависит исключительно от различий между диалектами SQL);
3. Не нужно дополнительно устанавливать клиентскую программу;
К любой базе данных можно подсоединиться через легко описываемый URL.

JDBC состоит из двух частей:
1. JDBC API, который содержит набор классов и интерфейсов, определяющих доступ к базам данных. Эти классы и методы объявлены в двух пакетах - java.sql и javax.sql;
2. JDBC-драйвер, компонент, специфичный для каждой базы данных.

JDBC превращает вызовы уровня API в «родные» команды того или иного сервера баз данных
# JDBC URL

JDBC URL состоит из:
1. : (протокола) - всегда jdbc:.
2. : (подпротокола) - это имя драйвера или имя механизма соединения с базой данных. Подпротокол может поддерживаться одним или несколькими драйверами. Лежащий на поверхности пример подпротокола - это "odbc", отведенный для URL, обозначающих имя источника данных ODBC. В случае необходимости использовать сервис имен (т.е. имя базы данных в JDBC URL не будет действительным именем базы данных), то подпротоколом может выступать сервис имен.
3. (подимени) - это идентификатор базы данных. Значение подимени может менятся в зависимости от подпротокола, и может также иметь под-подимя с синтаксисом, определяемым разработчиком драйвера. Назначение подимени - это предоставление всей информации, необходимой для поиска базы данных. Например, если база данных находится в Интернет, то в состав подимени JDBC URL должен быть включен сетевой адрес, подчиняющийся следующим соглашениям: //:/<subsubname.

Пример JDBC URL для подключения к MySQL базе данных «Test» расположенной по адресу localhost и ожидающей соединений по порту 3306: jdbc:mysql://localhost:3306/Test
# Основные классы и интерфейсы JDBC

java.sql.DriverManager - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем получить соединение с базой данных.

javax.sql.DataSource - решает те же задачи, что и DriverManager, но более удобным и универсальным образом. Существуют также javax.sql.ConnectionPoolDataSource и javax.sq1.XADataSource задача которых - обеспечение поддержки пула соединений.

java.sql.Connection - обеспечивает формирование запросов к источнику данных и управление транзакциями. Также предусмотрены интерфейсы javax.sql.PooledConnection и javax.sql.XAConnection.

java.sql.Statement , java.sql.PreparedStatement и java.sql.CallableStatement - эти интерфейсы позволяют отправить запрос к источнику данных.

java.sql.ResultSet - объявляет методы, которые позволяют перемещаться по набору данных и считывать значения отдельных полей в текущей записи.

java.sql.ResultSetMetaData - позволяет получить информацию о структуре набора данных.

java.sql.DatabaseMetaData - позволяет получить информацию о структуре источника данных.
# Основные этапы работы с базой данных при использовании JDBC.

1. Регистрация драйверов; 
2. Установление соединения с базой данных; 
3. Создание запроса(ов) к базе данных; 
4. Выполнение запроса(ов) к базе данных; 
5. Обработка результата(ов); 
6. Закрытие соединения с базой данных.

# Уровни изоляции транзакций поддерживаются в JDBC

Уровень изолированности транзакций — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.

Во время использования транзакций, для обеспечения целостности данных, СУБД использует блокировки, чтобы заблокировать доступ других обращений к данным, участвующим в транзакции. Такие блокировки необходимы, чтобы предотвратить:
1. «грязное» чтение (dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);
2. неповторяющееся чтение (non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
3. фантомное чтение (phantom reads) — ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

Уровни изоляции транзакций определены в виде констант интерфейса java.sql.Connection:
1. TRANSACTION_NONE - драйвер не поддерживает транзакции;
2. TRANSACTION_READ_UNCOMMITTED - позволяет транзакциям видеть несохраненные изменения данных: разрешает грязное, непроверяющееся и фантомное чтения;
3. TRANSACTION_READ_COMMITTED - любое изменение, сделанное в транзакции, не видно вне неё, пока она не сохранена: предотвращает грязное чтение, но разрешает непроверяющееся и фантомное;
4. TRANSACTION_REPEATABLE_READ - запрещает грязное и непроверяющееся, фантомное чтение разрешено;
5. TRANSACTION_SERIALIZABLE - грязное, непроверяющееся и фантомное чтения запрещены.

NB! Сервер базы данных может не поддерживать все уровни изоляции. Интерфейс java.sql.DatabaseMetaData предоставляет информацию об уровнях изолированности транзакций, которые поддерживаются данной СУБД.

Уровень изоляции транзакции используемый СУБД можно задать с помощью метода setTransactionIsolation() объекта java.sql.Connection. Получить информацию о применяемом уровне изоляции поможет метод getTransactionIsolation().

# Statement и PreparedStatement

Для выполнения запросов к базе данных в Java используются три интерфейса: java.sql.Statement - для операторов SQL без параметров; 
java.sql.PreparedStatement - для операторов SQL с параметрами и часто выполняемых операторов; 
java.sql.CallableStatement - для исполнения хранимых в базе процедур.

Объекты-носители интерфейсов создаются при помощи методов объекта java.sql.Connection: 
java.sql.createStatement() возвращает объект Statement; 
java.sql.prepareStatement() возвращает объект PreparedStatement; 
java.sql.prepareCall() возвращает объект CallableStatement;

Statement: используется для простых случаев запроса без параметров.
PreparedStatement: предварительно компилирует запрос, который может содержать входные параметры и выполняться несколько раз с разным набором этих параметров.

Перед выполнением СУБД разбирает каждый запрос, оптимизирует его и создает «план» (query plan) его выполнения. Если один и тот же запрос выполняется несколько раз, то СУБД в состоянии кэшировать план его выполнения и не производить этапов разборки и оптимизации повторно. Благодаря этому запрос выполняется быстрее.
Суммируя: PreparedStatement выгодно отличается от Statement тем, что при повторном использовании с одним или несколькими наборами параметров позволяет получить преимущества заранее прекомпилированного и кэшированного запроса, помогая при этом избежать SQL Injection.

PreparedStatement позволяет предотвратить атаки типа SQL injection, т.к. он автоматически экранирует специальные символы. PreparedStatement позволяет использовать динамические запросы с внедрением параметров. PreparedStatement быстрее Statement. Это особенно заметно при частом использовании PreparedStatement или при использовании для вызова группы запросов. PreparedStatement позволяет писать объектно ориентированный код с использованием сеттеров\геттеров. В то время при использовании Statement необходимо использовать конкатенацию строк для создания запроса. Для больших запросов конкатенация выглядит, как минимум, большой, а так же несет в себе большой риск ошибки в запросе.

# Ограничения PreparedStatement

В PreparedStatement нельзя использовать напрямую запросы с IN (входными) параметрами. Есть некоторые обходные пути: Выполнить Single Queries - низкая производительность и вообще не рекомендуется так делать. Использовать Stored Procedure (хранимые процедуры) - являются специфичными для конкретной базы данных и следовательно плохи для приложений с возможностью подключения к различным БД. Создание PreparedStatement Query динамически - это хорошее решение, но с потерей кэширования PreparedStatement. Использование NULL в PreparedStatement Query - хорошее решение, если вы знаете максимальное число переменных IN. Можно расширить до использования неограниченного кол-во параметров с помощью разбиения на части.

# JDBC ResultSet

JDBC ResultSet - интерфейс, объект которого создается в результате запроса к базе данных. Его можно представить в виде таблицы данных, которая была сформирована в ответ на запрос.Объект ResultSet поддерживает курсор, который указывает на текущую строку данных. При инициализации курсор устанавливается до первой строки. Для движение по строкам используется метод next(). При наличии строк после текущей позиции, метод next() возвращает true, что можно использовать для итерации по таблице полученных результатов. По умолчанию объект ResultSet не модифицируемый и поддерживает курсор, который способен только к движение вперед. Для обхода такого ограничения можно использовать следующую конструкцию, которая даст возможность двунаправленного движения по таблице, а так же возможности обновления:

Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);

Объект ResultSet автоматически закрывается при закрытии объекта, который его сгенерировал. Так же закрытие произойдет при повторном выполнении запроса или возврату результата из другого набора результатов. Для использования геттера ResultSet можно использовать имя колонки или индекс, который начинается с 1.

# JDBC Batch Processing

Бывает необходимо выполнить сразу группу похожих запросов, например при загрузке данных из CSV файлов реляционной базы данных. Это можно сделать просто используя Statement или PreparedStatement для пошагового выполнения этих запросов. В JDBC API существует другая возможность, которая предоставляет возможность выполнить группу запросов за один раз. Выполнение такого рода задачи происходит с помощью JDBC API Batch Processing. JDBC API поддерживает пакетную обработку с помощью методов addBatch() и executeBatch() у Statement и PreparedStatement. К преимуществам такого подхода относится более быстрая работа, т.к. вызовов к базе данных может быть существенно меньше.

# JDBC Transaction Management

По умолчанию, при создании подключения к базе данных будет выбран auto-commit mode. Это означает, что при каждом выполнении запроса он будет подтвержден автоматически по завершению. Каждый SQL запрос является транзакционным и выполняя какие-либо DML или DDL запросы по их завершению изменения будут приняты (сохранены) базой данных. Если у нас есть необходимость отказываться от сохранения выполнения какого-либо запроса (или групп запросов) в случае, если что-то пошло не так, то мы можем воспользоваться поддержкой транзакций в JDBC API. С помощью метода setAutoCommit(boolean flag) можно отключить авто коммит в конкретном соединении. Следует отметить, что при отключении auto-commit не одно изменение не будет сохранено в базе данных до вызова метода commit() и за этим необходимо следить. Сервер базы данных будет блокировать необходимую часть базы данных до подтверждения транзакции, а так как это ресурсоёмкая задача, то подтверждать транзакцию необходимо сразу после выполнения задачи.

# JDBC Savepoint

JDBC Savepoint позволяет создавать "чекпоинты" в транзакции с помощью которых мы можем откатить не всю транзакцию целиком, а только часть до точки сохранения. Любая точка сохранения автоматически освобождается и становится недоступной после подтверждения транзакции или её роллбека. Откат к точке сохранения делает все последующие сейвы недоступными и к ним уже нельзя будет вернуться.

# JDBC DataSource

JDBC DataSource является интерфейсом пакета javax.sql и является более продвинутым в сравнении с DriverManager для подключения к базе данных. Мы можем использовать DataSource для создания подключения к базе данных и реализацию класса драйвера, которая будет выполнять всю работу по поддержанию соединения. В дополнение к соединению через Database, DataSource предоставляет следующие дополнительные возможности: Кэширование PreparedStatement для ускорения обработки запросов Настройки Connection timeout Возможности логирования Порог максимального размера ResultSet Поддержка Connection Pooling в контейнере сервлетов, использующий поддержку JNDI.
# JDBC RowSet

JDBC RowSet содержит табличные данные в более гибком формате по сравнению с ResultSet. Все объекты RowSet являются производными из ResultSet, так что они имеют все возможности ResultSet с некоторыми дополнительными функциями. RowSet интерфейс определяется в javax.sql пакета. Можно выделить следующие дополнительные функции, предоставляемые RowSet: Функции похожие на Java Beans со свойствами и get\set методами для работы с ними. RowSet использует модель событий JavaBeans. В результате можно посылать уведомления любого зарегистрированного компонента для таких событий, например, движение курсора, обновления / вставка / удаление из строки и изменять содержимое RowSet. Объекты RowSet поддерживают скроллинг по данным (scrollable), а так же являются обновляемыми по умолчанию. Так что если СУБД не поддерживает скроллинг или обновляемый ResultSet, мы можем использовать RowSet, чтобы получить эти функции. RowSet можно разделить на два типа: Connected RowSet Objects - эти объекты подключаются к БД и очень похожи на объекты ResultSet. JDBC API предоставляет только одно подключение объекта RowSet - javax.sql.rowset.JdbcRowSet и это является стандартной реализации класса com.sun.rowset.JdbcRowSetImpl. Disconnected RowSet Objects - эти объекты RowSet не требуют подключения к базе данных. Они более легковесные и могут быть сериализованы. Такие объекты хорошо подходят для передачи данных по сети. Существуют четыре реализации такого типа объектов (disconnected RowSet objects). Кратко рассмотрим четыре реализации Disconnected RowSet Objects: CachedRowSet - объекты могут получить соединение и выполнить запрос, считать данные ResultSet для заполнения данных RowSet. Мы можем управлять и обновлять данные на время отключения от БД и записать измененные данные при очередном подключении. WebRowSet получены из CachedRowSet - такие объекты могут читать и записывать XML документы. JoinRowSet получены из WebRowSet - могут образовывать SQL JOIN без подключения к источнику данных. FilteredRowSet получены из WebRowSet - поддержка применения критериев фильтрации, поэтому видны только выбранные (полученные) данные.
# CLOB и BLOB в JDBC

Character Large OBjects (CLOBs) - тип данных (внутренний символьный объект), используемый для хранения больших объектов. При выборе значения любого LOB-типа посредством оператора SELECT возвращается указатель, а не само значение; кроме того, типы LOB могут быть и внешними. Этот тип данных является подходящим для хранения текстовой информации, которая может выходить за пределы обычного типа данных VARCHAR (верхний предел 32 Кбайт).Внутренний большой двоичный объект (BLOB) - двоичный объект большого размера, который может содержать переменное количество данных. Этот тип данных может хранить данные объемом более VARBINARY (32K предел). Тип данных, предназначенный, в первую очередь, для хранения изображений, аудио и видео, а также компилированного программного кода.

# Типов блокировки в JDBC

На более широком уровне есть два типа механизма блокировки для предотвращения повреждения данных из-за одновременной работы с данными несколькими пользователями. По логике реализации различают два вида блокировок. Оптимистическая блокировка - не ограничивает модификацию обрабатываемых данных сторонними сессиями, однако перед началом предполагаемой модификации запрашивает значение некоторого выделенного атрибута каждой из строк данных (обычно используется наименование VERSION и целочисленный тип с инициальным значением 0). Перед записью модификаций в базу данных перепроверяется значение выделенного атрибута, и если оно изменилось, то транзакция откатывается или применяются различные схемы разрешения коллизий. Если значение выделенного атрибута не изменилось — производится фиксация модификаций с одновременным изменением значения выделенного атрибута (например, инкрементом) для сигнализации другим сессиям о том, что данные изменились.Пессимистическая блокировка - накладывается перед предполагаемой модификацией данных на все строки, которые такая модификация предположительно затрагивает. Всё время действия такой блокировки исключена модификация данных из сторонних сессий, данные из блокированных строк доступны согласно уровню изолированности транзакции. По завершению предполагаемой модификации гарантируется непротиворечивая запись результатов.
# Best Practices в JDBC.

Всегда закрывайте ресурсы базы данных сразу после работы с ними. Connection, Statement, ResultSet и другие JDBC объекты имеют метод close(), который позволяет закрыть их. Всегда явно закрывайте результирующий набор ResultSet, Statement и Connection в коде, потому что если вы используете пул соединений, то соединение может быть возвращено в пул, оставляя открытые result sets и statement objects и будет происходить утечка. Закрывайте ресурсы в конце finally блока, чтобы убедиться, что они закрыты даже в случае возникновения исключения. Используйте пакетную обработку (batch processing) для повторяющихся запросов. Всегда используйте PreparedStatement вместо Statement, чтобы избежать SQL Injection и получить преимущества заранее прекомпилированного и кэшированного запроса PreparedStatement. Если вы извлекаете большие массивы данных в result set, то заранее установите оптимальное значение fetchSize, что поможет получить лучшую производительность. Сервер базы данных может не поддерживать все уровни изоляции, так что проверьте их заранее. Более строгие уровни изоляции могут привести к снижению производительности, поэтому убедитесь, что вы используете оптимальный набор уровней изоляции для ваших соединений с базой данных. Если вы создаете подключения к базе данных из веб-приложения, попробуйте использовать ресурсы JDBC DataSource с помощью применения контекста JNDI для возможности повторного использования соединений. Попробуйте использовать отключенный (disconnected) RowSet, когда вам нужно работать с ResultSet в течение длительного времени.