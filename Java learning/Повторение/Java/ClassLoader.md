# [[Оглавление]]

# ClassLoader

JVM динамически загружает классы по требованию – это одна из самых мощных возможностей платформы Java. Подсистема загрузки классов (Class Loader Subsystem) ищет требуемый класс (например, по имени и пути), читает его бинарное содержимое из .class-файла и формирует в памяти внутреннюю структуру класса. Согласно спецификации JVM, загрузка классов проходит три этапа: поиск бинарного представления класса, создание класса/интерфейса на его основе и размещение этой информации в области Metaspace, где хранятся метаданные классов.

HotSpot реализует несколько уровней загрузчиков по принципу иерархии делегирования:

- **Bootstrap ClassLoader** – встроенный загрузчик, написанный на native-коде, загружает базовые классы Java из стандартной библиотеки (например, из модуля java.base). Инициализируется при старте JVM.
- **Platform/Extension ClassLoader** – загрузчик платформенных классов (в прошлых версиях – extension loader) для дополнительных библиотек расширений.
- **Application ClassLoader** – загрузчик приложений, загружает классы с указанного classpath приложения (или модульного path). Обычно реализован на Java как подкласс java.lang.ClassLoader.

Каждый загрузчик делегирует поиск классов своему родительскому загрузчику (кроме Bootstrap) – это предотвращает повторную загрузку уже загруженных классов и обеспечивает безопасность. Таким образом, если пользовательский класс обращается к классу стандартной библиотеки, Application ClassLoader сначала делегирует загрузку Bootstrap-слою.

Важно отметить, что JVM допускает создание пользовательских загрузчиков (путём наследования ClassLoader), что широко используется в современных фреймворках (OSGi, сервлет-контейнеры, JEE-серверы). Это позволяет динамически подменять или изолировать классы. Однако в данной статье мы фокусируемся на стандартном процессе загрузки с помощью bootstrap-загрузчика для простоты.
# Работа загрузки классов

Согласно спецификации Java SE для того, чтобы получить работающий в JVM код, необходимо выполнить три этапа:

- **загрузка байт-кода из ресурсов и создание экземпляра класса `Class`**
    сюда входит поиск запрошенного класса среди загруженных ранее, получение байт-кода для загрузки и проверка его корректности, создание экземпляра класса `Class` (для работы с ним в runtime), загрузка родительских классов. Если родительские классы и интерфейсы не были загружены, то и рассматриваемый класс считается не загруженным.
- **связывание (или линковка)**
    по спецификации этот этап разбивается еще на три стадии:
    - **Verification**, происходит проверка корректности полученного байт-кода.
    - **Preparation**, выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию (при этом явная инициализация, если она есть, происходит уже на этапе инициализации).
    - **Resolution**, разрешение символьных ссылок типов, полей и методов.
- **инициализация полученного объекта**
    здесь, в отличие от предыдущих пунктов, вроде бы все понятно, что должно происходить. Было бы, конечно, интересно разобраться как именно это происходит.
**Все эти этапы выполняются последовательно со следующими требованиями:**
- Класс должен быть полностью загружен прежде, чем слинкован.
- Класс должен быть полностью проверен и подготовлен прежде, чем проинициализирован.
- Ошибки разрешения ссылок происходят во время выполнения программы, даже если были обнаружены на этапе линковки.
# Как можно менять код с помощью Classloader

Так как загрузка происходит динамически, мы можем подменять классы, предоставляя JVM собственный байткод. Например, можно создать новый ClassLoader, который при запросе класса сначала анализирует или модифицирует его байткод, а потом только передаёт его в виртуальную машину. На практике это используется для реализации горячей замены кода, профилирования, логирования или внедрения аспектов. По сути, ClassLoader даёт возможность внедрять дополнительное поведение без изменения исходных файлов программы. Например, если нужно, чтобы каждый вызов метода логировался, можно создать загрузчик, который будет перехватывать загрузку классов и добавлять в их байткод вызовы логирования. Таким образом, ClassLoader становится инструментом не только для организации загрузки, но и для гибкого управления работой программы на уровне её структуры.

# [[Оглавление]]