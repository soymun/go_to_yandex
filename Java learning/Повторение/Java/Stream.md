## Основные функциональные интерфейсы

Основные функциональные интерфейсы, используемые в Stream API, находятся в пакете `java.util.function`. Они предоставляют "целевые типы" для лямбда-выражений и ссылок на методы.

1. **Predicate**: Принимает один аргумент и возвращает логическое значение (`boolean`). Используется для фильтрации данных (например, `filter`).
2. **Function**: Принимает один аргумент типа `T` и возвращает результат типа `R`. Используется для преобразования одного объекта в другой (например, `map`).
3. **Consumer**: Принимает один аргумент и ничего не возвращает (`void`). Используется для выполнения побочных эффектов (например, `forEach`).
4. **Supplier**: Не принимает аргументов, но возвращает значение. Используется для создания или предоставления данных.
## Как работает Stream

Работа Stream API строится на двух ключевых концепциях: **конвейер операций (pipeline)** и **ленивые вычисления (lazy evaluation)**.

1. **Источник (Source)**: Поток создается из источника данных.
2. **Промежуточные операции (Intermediate operations)**: К потоку применяется цепочка промежуточных операций (например, `filter`, `map`, `sorted`). Каждая такая операция возвращает новый поток. Эти операции не выполняются немедленно; они только строят "план" вычислений.
3. **Терминальная операция (Terminal operation)**: Выполнение всего конвейера запускается только тогда, когда вызывается терминальная операция (например, `collect`, `forEach`, `count`). Данные проходят через конвейер по одному элементу за раз, и к каждому элементу применяются все промежуточные операции перед обработкой следующего.
## Collectors

**Collectors** — это специальный класс-утилита, предоставляющий реализации интерфейса `Collector`. Этот интерфейс используется в терминальной операции `collect()` для преобразования элементов потока в итоговый результат, чаще всего в коллекцию (например, `List`, `Set` или `Map`). `Collectors` также позволяют выполнять сложные операции, такие как группировка элементов (`groupingBy`), их объединение (`joining`) или вычисление арифметических метрик (`averagingInt`, `summarizingInt`).
## Промежуточные функции

**Промежуточные (intermediate) операции** — это операции, которые возвращают новый поток. Они всегда ленивы; их выполнение откладывается до вызова терминальной операции. Они используются для построения конвейера обработки данных.

Основные промежуточные операции:
- `filter(Predicate)`: Отфильтровывает элементы, не удовлетворяющие условию.
- `map(Function)`: Преобразует каждый элемент потока.
- `flatMap(Function)`: Преобразует каждый элемент в поток других элементов и "схлопывает" все полученные потоки в один.
- `sorted()`: Сортирует элементы.
- `distinct()`: Оставляет только уникальные элементы.
- `peek(Consumer)`: Позволяет выполнить действие над каждым элементом без его изменения (в основном для отладки).
- `limit(long)`: Ограничивает количество элементов в потоке.
- `skip(long)`: Пропускает первые `n` элементов.
## Терминальные функции

**Терминальные (terminal) операции** — это операции, которые запускают обработку потока и возвращают конечный результат или производят побочный эффект. После вызова терминальной операции поток считается потребленным и не может быть использован повторно.

Основные терминальные операции:

- `collect()`: Собирает элементы потока в коллекцию или другую структуру данных.
- `forEach(Consumer)`: Применяет действие к каждому элементу.
- `count()`: Возвращает количество элементов в потоке.
- `reduce()`: "Сворачивает" элементы потока в одно значение.
- `min()`, `max()`, `sum()`, `average()`: Находят минимальный, максимальный элементы, сумму или среднее значение.
- `anyMatch()`, `allMatch()`, `noneMatch()`: Проверяют, удовлетворяет ли какой-либо, все или ни один из элементов потока заданному условию.
- `findFirst()`, `findAny()`: Возвращают первый или любой элемент потока.
## Stateless и Stateful

Операции в Stream API делятся на два типа в зависимости от того, нужно ли им хранить информацию о ранее обработанных элементах.

- **Stateless (без состояния)**: Это операции, для обработки которых не требуется никакой информации о других элементах потока. Каждый элемент обрабатывается независимо. Примеры: `filter`, `map`. Они идеально подходят для параллельной обработки.
- **Stateful (с состоянием)**: Это операции, которым для обработки текущего элемента может потребоваться информация обо всех или некоторых других элементах потока. Примеры: `sorted` (нужно видеть все элементы, чтобы начать сортировку), `distinct` (нужно хранить уже встреченные уникальные элементы), `limit`, `skip`. Такие операции могут снижать производительность при параллельной обработке.
## parallel в Stream и где он выполняется

Вызов метода **`parallelStream()`** или **`.parallel()`** на существующем потоке позволяет выполнять операции конвейера в несколько потоков, что может значительно ускорить обработку больших объемов данных.

По умолчанию параллельные потоки выполняются в общем пуле потоков **ForkJoinPool.commonPool()**. Это общий пул для всей JVM, который также используется другими фреймворками (например, `CompletableFuture`). Количество потоков в этом пуле обычно равно количеству ядер процессора. Использование общего пула означает, что интенсивные операции в одном параллельном потоке могут повлиять на производительность других частей приложения, использующих тот же пул.
## Оптимизация StreamApi

### Ленивые вычисления (Lazy Evaluation)

Это фундаментальный принцип оптимизации в Stream API. Промежуточные операции (`filter`, `map` и т.д.) не выполняются в момент их объявления. Вместо этого они выстраивают "рецепт" обработки данных. Реальные вычисления запускаются только при вызове **терминальной операции**. Это позволяет избежать ненужной работы; если результат может быть получен без обработки всей коллекции, Java не будет этого делать.
### Оптимизация "короткого замыкания" (Short-circuiting)

Некоторые операции, как промежуточные (`limit`), так и терминальные (`anyMatch`, `findFirst`), являются операциями "короткого замыкания". Когда Java встречает такую операцию, она понимает, что ей не всегда нужно обрабатывать все элементы потока для получения результата.
### Слияние операций (Operation Fusion)

Java оптимизирует конвейер, "сливая" несколько последовательных операций в один проход по данным. Вместо того чтобы создавать промежуточные коллекции после каждого шага (например, отфильтровать все, потом преобразовать все), JVM объединяет эти действия.

# Как работает ленивое выполнение (laziness) в Stream API?

Ленивое выполнение — ключевая особенность Stream API, которая означает, что промежуточные операции (`filter`, `map`, и т.д.) не выполняются, пока не вызвана терминальная операция (`collect`, `forEach`, и т.д.).

**Механизм**:
- Промежуточные операции создают новый объект стрима, добавляя операцию в цепочку (граф операций), но не обрабатывают данные.
- Каждая операция представлена как `Stage` в классе `PipelineHelper`, который хранит информацию о её типе и лямбда-выражении (если есть).
- Терминальная операция вызывает метод `evaluate()` в `AbstractPipeline`, который инициирует обработку данных.

# Как данные проходят через конвейер операций?

Данные в Stream API обрабатываются через **цепочку `Sink`-ов**, где каждый `Sink` представляет операцию (например, `filter`, `map`). Эта цепочка формируется во время выполнения терминальной операции.