# [[Оглавление]]

# Поток

Поток — это поток выполнения программы. JVM поддерживает одновременное выполнение нескольких потоков. В Hotspot JVM Java-поток соответствует native-потоку ОС. После создания Java-потока (с thread-local хранилищем, буферами, объектами синхронизации, стеками и счётчиками) создаётся native-поток. ОС распределяет потоки на процессоры. После инициализации native-поток вызывает метод run() Java-потока. При завершении run() обрабатываются неперехваченные исключения, и native-поток проверяет, нужно ли завершить JVM (например, если завершился последний non-daemon поток). После завершения потока все ресурсы освобождаются.
Проблемы создания обычных потоков:
1. Создание потока (`Thread`) в Java требует значительных ресурсов
2. Переключение контекста между потоками — ресурсоёмкая операция
# Состояния потока
![[Pasted image 20250819163907.png]]

# Data race

**Data race** возникает, когда два или более потока одновременно обращаются к общим данным, при этом хотя бы один выполняет запись, и действия не синхронизированы. В таких случаях **memory order** не гарантируется, что может привести к непредсказуемым результатам.

# Типы согласованности

Строгая последовательность (Sequential Consistency - SC) - Это самая интуитивная и строгая модель. Она создает иллюзию, что все операции всех потоков выполняются в **единой глобальной последовательности**, и каждый поток видит эту последовательность одинаково.

As-if-serial - Это семантика, которая применяется к **однопоточным программам**. Она гарантирует, что результат выполнения кода в одном потоке будет таким же, как если бы все его инструкции выполнялись строго последовательно, одна за другой. При этом компилятор и процессор могут переупорядочивать инструкции как угодно, главное — чтобы итоговый результат не изменился.

Последовательная согласованность для программ без гонок данных (Sequential Consistency for Data-Race-Free Programs - SC-DRF) -Если нет **гонок данных** (то есть, правильно синхронизировали доступ к общим переменным с помощью `volatile`, `synchronized` и т.д.), то JMM **гарантирует** вам поведение, эквивалентное Sequential Consistency.

# Типы ordering

**Program Order** — порядок инструкций, как они написаны в исходном коде программы.

**Instructions Ordering** — реальный порядок выполнения инструкций на уровне процессора или компилятора, который может отличаться от Program Order из-за оптимизаций.

**Memory Ordering** — наблюдаемый порядок операций с памятью (чтение/запись) с учётом многопоточности, кэширования и переупорядочивания, который может не совпадать с Program Order.

# Memory Reordering

**LoadLoad**: перестановка чтений (r1, r2 → r2, r1).
**LoadStore**: чтение перед последующей записью (r, w → w, r).
**StoreStore**: перестановка записей (w1, w2 → w2, w1).
**StoreLoad**: запись перед последующим чтением (w, r → r, w).
# Memory Barriers

**LoadLoad Barrier**:
- Гарантирует, что операции чтения до барьера завершатся до операций чтения после барьера.
- Пример: Чтение двух volatile переменных подряд требует, чтобы первое чтение завершилось до второго.
**StoreStore Barrier**:
- Гарантирует, что операции записи до барьера завершатся до операций записи после барьера.
- Пример: Запись в две volatile переменные подряд.
LoadStore Barrier**:
- Гарантирует, что операции чтения до барьера завершатся до операций записи после барьера.
- Используется, чтобы предотвратить переупорядочивание чтения и записи.
**StoreLoad Barrier**:
- Самый "тяжёлый" барьер, предотвращающий переупорядочивание записи и последующего чтения.
- Пример: Запись в volatile переменную, за которой следует чтение другой volatile переменной.
# Store Buffer в процессоре

![[Pasted image 20250819222946.png]]

В некоторых микроархитектурах (например, x86) каждое ядро имеет **FIFO Store Buffer (SB)** — буфер записи, промежуточный слой между CPU и кэшем. Ядро помещает записи в SB, где они ждут сброса в локальный кэш после того, как другие ядра инвалидируют свои копии и отправят подтверждение. Это ускоряет работу пишущего ядра, минимизируя задержки.

При чтении ядро сначала проверяет **SB**, а затем локальный кэш, чтобы обеспечить **as-if-serial** гарантию в пределах одного ядра, избегая чтения устаревших данных.

**Проблема**: Другие ядра не видят новую запись, пока она находится в SB, так как **Cache Coherence** не распространяется на SB. В результате, пишущее ядро работает с актуальным значением, а остальные — с устаревшим, пока запись не сброшена в кэш.

# Cache Coherence

**Cache Coherence** — это механизм, обеспечивающий согласованность данных в кэшах разных ядер процессора. Он гарантирует, что изменения, сделанные одним ядром в своей локальной копии данных, рано или поздно станут видимыми для всех остальных ядер.

# MESI

**MESI** — это протокол поддержания когерентности кэша в многопроцессорных системах. Он гарантирует, что все ядра процессора видят единое и согласованное состояние общей памяти, даже если у каждого ядра есть свой локальный кэш.
Протокол разделяет каждую строку кэша на **4 состояния**:
1. **Modified (M)** — строка изменена, содержит актуальные данные, которые ещё не записаны в основную память. Только одно ядро может находиться в этом состоянии для конкретной строки.
2. **Exclusive (E)** — строка присутствует только в кэше одного ядра, её данные совпадают с основной памятью, но не были изменены.
3. **Shared (S)** — строка может находиться в кэшах нескольких ядер, данные совпадают с основной памятью.
4. **Invalid (I)** — строка кэша недействительна (данные устарели или отсутствуют).

- Если значение найдено в **Shared**, **Exclusive** или **Modified**, оно возвращается.
- Если линия в **Modified**, изменения сбрасываются в память, а линия переводится в **Shared**.
- Если значения нет в кэшах, оно читается из памяти.
# CAS

**CAS (Compare-And-Swap)** — это атомарная инструкция, используемая для безопасной работы с разделяемыми данными в многопоточных средах без блокировок. Она является основой многих **lock-free** и **non-blocking** алгоритмов.

Работа CAS:
1. **Сравнение**: Проверяется, равно ли текущее значение переменной в памяти **ожидаемому значению**.
2. **Обмен**: Если значения совпадают, переменная обновляется на **новое значение**.
3. **Результат**: Операция возвращает `true`, если обмен произошёл успешно, или `false`, если значение в памяти изменилось (например, другой поток успел его модифицировать).
# JMM

Java Memory Model (JMM) описывает поведение потоков в Java, определяя правила выполнения многопоточных программ и взаимодействия потоков через общую память. JMM задаёт набор межпоточных действий (чтение/запись переменных, захват/освобождение монитора, операции с volatile, запуск потока) и отношение happens-before. Если операция X happens-before Y, то код после Y в одном потоке видит все изменения, сделанные другим потоком до X.


# Happens-before

Happens-before определяется как отношение между двумя действиями:

- Пусть есть поток T1 и поток T2 (необязательно отличающийся от потока T1) и действия x и y, выполняемые в потоках T1 и T2 соответственно
- Если x happens-before y, то во время выполнения y треду T2 будут видны все изменения, выполняемые в x тредом T1

Happens-before — это еще один способ, с помощью которого мы добьемся sequential consistency.

Правила Happens-Before в JMM:

- Program Order Rule: Каждая операция в потоке happens-before следующей операции в этом же потоке.
- Monitor Lock Rule: Разблокировка монитора happens-before последующей блокировкой этого же монитора в другом потоке.
- Volatile Variable Rule: Запись в volatile переменную happens-before последующего чтения этой же переменной.
- Thread Start Rule: Вызов Thread.start() happens-before любой операции в запущенном потоке.
- Thread Termination Rule: Любая операция в потоке happens-before его завершением (например, Thread.join()).
- Transitivity: Если A happens-before B, а B happens-before C, то A happens-before C.


# Основы многопоточности

**Кооперативная многозадачность** Потоки добровольно передают управление друг другу, не прерываясь принудительно. Используется, когда задачи сами решают, когда уступить процессор.

**Потоки-демоны** Потоки, работающие в фоне и не блокирующие завершение программы. Они автоматически завершаются, когда все пользовательские потоки завершены.

**Приоритет потока** Целочисленное значение, влияющее на порядок выполнения потоков планировщиком. Более высокий приоритет не гарантирует выполнение первым, но увеличивает шансы.

**Thread** Класс в Java для создания и управления потоками. Можно наследоваться от него или передавать объект Runnable.

**Runnable** Интерфейс с методом run(), который определяет задачу для потока. Более гибкий, чем наследование от Thread, так как позволяет расширять другие классы.

**Callable** Интерфейс, аналогичный Runnable, но возвращает результат и может выбрасывать исключения. Используется с ExecutorService для асинхронных задач.

**Thread.join()** Метод, который приостанавливает текущий поток до завершения потока, для которого вызван. Полезен для синхронизации выполнения потоков.

**Thread.sleep()** Приостанавливает выполнение текущего потока на указанное время. Не освобождает мониторы, удерживаемые потоком.

**Thread.yield()** Подсказка планировщику, что поток готов уступить процессор. Не гарантирует переключение, зависит от реализации JVM.

**wait() и notify()/notifyAll()** Методы Object для синхронизации: wait() приостанавливает поток, а notify()/notifyAll() пробуждают один или все ожидающие потоки. Используются в блоках synchronized.

**interrupted() и isInterrupted()** Методы для проверки и управления флагом прерывания потока. interrupted() сбрасывает флаг, а isInterrupted() — нет.
# volatile

**volatile** в Java обеспечивает **видимость** и **упорядочивание** операций с переменными в многопоточной среде, но не гарантирует * _взаимоисключение_*, в отличие от `synchronized`.

**Видимость**: JVM использует **memory barriers**:
- **Store Barrier** (при записи): сбрасывает данные в основную память.
- **Load Barrier** (при чтении): обновляет кэш из основной памяти.

**Упорядочивание**: запись в `volatile` создаёт **happens-before** с последующим чтением, предотвращая переупорядочивание операций.
# synchronized

**`synchronized`** в Java основан на **мониторе** — механизме, обеспечивающем эксклюзивный доступ одному потоку к объекту в определённый момент. Монитор действует как замок: поток захватывает его для выполнения синхронизированного кода, а другие потоки ждут освобождения.

# Atomic

1. **AtomicInteger**: Атомарные операции с `int` (инкремент, декремент, сравнение и замена).
2. **AtomicLong**: Аналог `AtomicInteger` для `long`.
3. **AtomicBoolean**: Атомарные операции с `boolean`.
4. **AtomicReference**: Атомарные операции над ссылками на объекты типа `V`.
5. **AtomicIntegerArray**: Массив `int` с атомарными операциями над элементами.
6. **AtomicLongArray**: Аналог `AtomicIntegerArray` для `long`.
7. **AtomicReferenceArray**: Массив ссылок на объекты типа `E` с атомарными операциями.
8. **AtomicDouble** (Java 21, экспериментально): Атомарные операции с `double` (часть Project Valhalla).
9. **AtomicMarkableReference**: Хранит ссылку и булев маркер.
10. **AtomicStampedReference**: Хранит ссылку и целочисленный штамп (версия).

Все Atomic, реализованы с помощью valotile и CAS.

# Lock

`Lock` это интерфейс из пакета `java.util.concurrent.locks`, введённый в Java 5 предоставляет явный механизм блокировки, где поток должен явно захватить блокировку (`lock()`) перед доступом к критической секции и освободить её (`unlock()`) после завершения. Это контрастирует с `synchronized`, где блокировка и освобождение происходят автоматически при входе и выходе из блока или метода.
 **Условия (`Condition`)**: Позволяет создавать объекты `Condition` для координации потоков (аналог `wait()`/`notify()`).

`ReentrantLock` — Он предоставляет потокобезопасный механизм синхронизации, позволяющий управлять доступом к общим ресурсам в многопоточной среде. `ReentrantLock` является более гибкой альтернативой встроенному механизму `synchronized`, обеспечивая такие возможности, как прерываемость, таймауты, неблокирующие попытки захвата и поддержка условий (`Condition`). Название "reentrant" отражает его способность поддерживать **повторный вход** (reentrancy), то есть поток, уже владеющий блокировкой, может захватить её снова без блокировки самого себя.

`ReadWriteLock` — это интерфейс в Java из пакета `java.util.concurrent.locks`, введённый в Java 5, который предоставляет механизм синхронизации, разделяющий доступ к ресурсу на два типа блокировок: **чтение** (`readLock`) и **запись** (`writeLock`). Он предназначен для сценариев, где операции чтения значительно преобладают над операциями записи, позволяя множеству потоков одновременно читать данные, но только одному потоку выполнять запись. Это обеспечивает более высокую конкурентность по сравнению с обычной блокировкой, такой как `ReentrantLock`, которая эксклюзивно блокирует доступ для всех операций. Основная реализация `ReadWriteLock` — это класс `ReentrantReadWriteLock`.

`StampedLock` — предоставляет более гибкий и производительный механизм синхронизации по сравнению с `ReentrantLock` и `ReentrantReadWriteLock`. Он предназначен для сценариев, где требуется высокая конкурентность, особенно при большом количестве операций чтения и редких операциях записи. В отличие от других блокировок, `StampedLock` поддерживает **оптимистическое чтение** (optimistic read), что позволяет минимизировать блокировки в сценариях с низкой вероятностью конфликтов. Однако он не реализует интерфейс `Lock`, что делает его использование менее стандартным, но более эффективным в определённых случаях.

# Future

`Future<V>` — это интерфейс, представляющий результат асинхронной задачи, где `V` — тип возвращаемого значения.

`CompletableFuture` — это мощный класс в Java, введённый в Java 8 в пакете `java.util.concurrent`. Он расширяет функциональность интерфейса `Future`, предоставляя более гибкий и удобный способ работы с асинхронными вычислениями. `CompletableFuture` поддерживает функциональный стиль программирования, цепочки операций, обработку исключений и композицию задач, что делает его предпочтительным выбором для современных многопоточных приложений по сравнению с `Future`. Он также позволяет работать в неблокирующем режиме, что особенно полезно для высокопроизводительных систем. По умолчанию выполняется в ForkJoinPool.

# ForkJoin

ForkJoinPool — специальный вид ExecutorService (пула потоков), который появился в Java с версии 7. Рекомендации для выполнения рекурсивных задач. Задача для сервиса выглядит как экземпляр класса ForkJoinTask. В основном используются подклассы RecursiveTask и RecursiveAction, для задач с результатом и без него. Аналогично интерфейсам Callable и Runnable обычный ExecutorService.Тело рекурсивной операции задается в реализации метода Compute() задачи ForkJoinTask. Здесь же определяются новые подзадачи и выполняются параллельным методом fork(). Чтобы дождаться выполнения задачи, на каждой форкнутой подзадаче возникает блокирующий метод join(), результат выполнения при необходимости агрегируется. С точки зрения использования метода ForkJoinTask.join() похож на аналогичный метод класса Thread. Но в случае, если поток разветвленного соединения может на самом деле не заснуть, а переключиться на выполнение другой задачи. Такая стратегия называется кражей работы и позволяет эффективно использовать ограниченное количество потоков. Это происходит на переиспользовании потоков корутин Kotlin (зеленые потоки).

# ThreadLocal

`ThreadLocal` — это специальный класс в Java, который позволяет создавать переменные, доступные только для одного конкретного потока (thread). Каждый поток, обращающийся к `ThreadLocal` переменной, будет видеть свою собственную, независимо инициализированную копию этой переменной.
Магия `ThreadLocal` не в самом объекте `ThreadLocal`, а в том, как он взаимодействует с классом `Thread`.
1. **`Thread.threadLocals` и `Thread.inheritableThreadLocals`:** Каждый объект `Thread` в Java имеет два поля типа `ThreadLocal.ThreadLocalMap` (это внутренний статический класс `ThreadLocal`):
    - `threadLocals`: для обычных `ThreadLocal` переменных.
    - `inheritableThreadLocals`: для `InheritableThreadLocal` переменных (о них чуть позже).
2. **`ThreadLocalMap`:**
    - Это специализированная хэш-карта.
    - **Ключами** в этой карте являются сами экземпляры `ThreadLocal` (точнее, слабые ссылки на них - `WeakReference<ThreadLocal<?>>`).
    - **Значениями** являются фактические данные, которые мы хотим сохранить для данного потока (например, строка "Hello from A").

# Основные проблемы многопоточности

| Название                                                  | Описание                                                                                                                                                                          | Пример сценария                                                                                                                               |
| --------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Deadlock (Взаимная блокировка)                            | Возникает, когда два или более потока бесконечно ждут друг друга, чтобы освободить ресурсы, которые они удерживают. Это приводит к полной остановке всех задействованных потоков. | Поток 1 удерживает `lock1` и ждёт `lock2`. Поток 2 удерживает `lock2` и ждёт `lock1`.                                                         |
| Livelock                                                  | Ситуация, когда потоки активно выполняют действия, чтобы избежать конфликта, но зацикливаются, не достигая прогресса.                                                             | Два потока пытаются захватить два замка, но каждый освобождает свой замок, если не может захватить второй, что приводит к бесконечному циклу. |
| Race Condition (Состояние гонки)                          | Возникает, когда результат выполнения программы зависит от порядка выполнения потоков, что приводит к непредсказуемому поведению.                                                 | Два потока увеличивают общий счётчик без синхронизации, что приводит к потере обновлений.                                                     |
| Starvation (Голодание)                                    | Возникает, когда один или несколько потоков не могут получить доступ к ресурсам из-за того, что другие потоки постоянно занимают их.                                              | Поток с низким приоритетом не может захватить замок, так как потоки с высоким приоритетом постоянно его удерживают.                           |
| Thread Contention (Конкуренция потоков)                   | Возникает, когда множество потоков соревнуются за доступ к общему ресурсу, что приводит к снижению производительности.                                                            | Множество потоков пытаются захватить один `synchronized` блок, вызывая задержки.                                                              |
| Memory Consistency Errors (Ошибки согласованности памяти) | Эти ошибки возникают, когда разные потоки видят разные значения одной и той же переменной из-за отсутствия правильной синхронизации.                                              | Один поток обновляет переменную, но другой поток видит устаревшее значение.                                                                   |
| Thread Leaks (Утечки потоков)                             | Возникают, когда потоки создаются, но не завершаются должным образом, что приводит к накоплению активных потоков и потреблению ресурсов.                                          | Пул потоков не закрывается с помощью `shutdown()`, или потоки создаются без контроля.                                                         |
| Excessive Synchronization (Избыточная синхронизация)      | Слишком частое или широкое использование синхронизации может привести к снижению производительности, так как потоки будут часто ждать друг друга.                                 | Синхронизация всего метода, когда достаточно защитить только критическую секцию.                                                              |
| InterruptedException и неправильная обработка прерываний  | Неправильная обработка `InterruptedException` может привести к тому, что потоки не реагируют на сигналы прерывания, что усложняет их остановку или отмену.                        | Игнорирование `InterruptedException` или неправильное восстановление состояния прерывания.                                                    |
| Performance Overhead (Издержки производительности)        | Неправильное использование многопоточности может привести к снижению производительности.                                                                                          | Создание нового потока для каждой задачи вместо использования пула потоков.                                                                   |

# Синхронизаторы

| Название           | Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Semaphore**      | Объект синхронизации, ограничивающий количество потоков, которые могут «войти» в заданный участок кода.<br><br>![[Semaphore.gif]]<br>                                                                                                                                                                                                                                                                                                                        |
| **CountDownLatch** | Объект синхронизации, разрешающий вход в заданный участок кода при выполнении определенных условий.  После открытия, невозможно использовать.<br><br>![[CountDownLatch.gif]]<br>                                                                                                                                                                                                                                                                             |
| **CyclicBarrier**  | **CyclicBarrier** (Циклический барьер) — это точка синхронизации (сбора), в которой группа потоков должна дождаться друг друга, прежде чем продолжить выполнение вместе. После того как все потоки собрались и были "отпущены", барьер автоматически сбрасывается и может быть использован снова для следующей точки сбора.<br><br>![[CyclicBarrier.gif]]<br>                                                                                                |
| **Exchanger**      | **Exchanger** в Java — `Exchanger` предоставляет точку синхронизации, где два потока могут обменяться объектами. Каждый поток вызывает метод `exchange()` и передаёт свой объект, затем блокируется, пока второй поток не вызовет `exchange()` и не предоставит свой объект. После этого потоки обмениваются данными и продолжают выполнение.<br><br>![[Exchanger.gif]]<br>                                                                                  |
| **Phaser**         | **Phaser** позволяет синхронизировать потоки, работающие в фазах, где каждая фаза завершается, когда все зарегистрированные участники достигают точки синхронизации (барьера). После завершения фазы потоки могут продолжить выполнение следующей фазы, а `Phaser` может выполнять опциональное действие. В отличие от `CyclicBarrier`, `Phaser` поддерживает динамическое изменение числа участников и может быть завершён явно.<br><br>![[Phaser.gif]]<br> |

# Пулы потоков

**Executor**
Интерфейс `Executor` — базовый интерфейс для запуска задач в новых потоках. Он содержит один метод `execute(Runnable command)`, который принимает задачу для выполнения. Реализации этого интерфейса управляют созданием и использованием потоков. Чаще всего используется как основа для более сложных интерфейсов, таких как `ExecutorService`.

**ExecutorService**
Интерфейс `ExecutorService` расширяет `Executor` и добавляет возможности для управления жизненным циклом потоков и задач. Он поддерживает завершение работы, отмену задач и получение результатов через `Future`. Позволяет отправлять задачи на выполнение с помощью `submit()` и управлять их выполнением. Это основной интерфейс для работы с пулами потоков в Java.

 **ThreadPoolExecutor**
Класс `ThreadPoolExecutor` — реализация `ExecutorService`, которая управляет пулом потоков. Позволяет настраивать количество минимальных и максимальных потоков, время простоя и очередь задач. Гибкость конфигурации делает его подходящим для большинства сценариев многопоточности. Используется для оптимизации использования ресурсов при выполнении асинхронных задач.

 **FixedThreadPool**
Статический метод `Executors.newFixedThreadPool(int nThreads)` создаёт пул с фиксированным количеством потоков. Все задачи выполняются в очереди, если все потоки заняты. Подходит для задач с предсказуемой нагрузкой. Избегает избыточного создания потоков, что экономит ресурсы.

**Executors.newCachedThreadPool()**
Метод `Executors.newCachedThreadPool()` создаёт пул потоков, который динамически создаёт новые потоки при необходимости. Потоки переиспользуются, если они свободны, иначе создаются новые. Подходит для задач с коротким временем выполнения и нерегулярной нагрузкой. Может потреблять много ресурсов при большом количестве задач.

 **SingleThreadExecutor**
Метод `Executors.newSingleThreadExecutor()` создаёт пул с одним потоком, который выполняет задачи последовательно. Гарантирует, что задачи не будут выполняться параллельно. Полезен для задач, требующих строгого порядка выполнения. Обеспечивает простоту и безопасность в многопоточных сценариях.

 **ScheduledExecutorService**
Интерфейс `ScheduledExecutorService` расширяет `ExecutorService` и добавляет возможность планирования задач. Позволяет запускать задачи с задержкой или периодически. Используется для отложенного или регулярного выполнения задач. Пример: `Executors.newScheduledThreadPool(int corePoolSize)`.

**shutdown() и shutdownNow() у ExecutorService**
Метод `shutdown()` инициирует плавное завершение пула: новые задачи не принимаются, а текущие выполняются до конца. Метод `shutdownNow()` пытается немедленно остановить все выполняемые задачи и возвращает список невыполненных задач. Оба метода не блокируют вызов, но `awaitTermination()` позволяет дождаться завершения. Важно вызывать их для освобождения ресурсов.

**submit() и execute() у пула потоков**

Метод `execute(Runnable)` запускает задачу без возврата результата и не позволяет отслеживать её статус. Метод `submit(Callable<T>)` возвращает объект `Future<T>`, через который можно получить результат или отменить задачу. `submit()` более гибок, так как поддерживает задачи с возвращаемым значением. Оба метода бросают `RejectedExecutionException`, если пул уже завершён.
# Виртуальные потоки

**Виртуальные потоки (Virtual Threads) в Java** — это лёгкие потоки исполнения, представленные в Java 19 (в рамках Project Loom) и окончательно стабилизированные в Java 21. Они позволяют создавать миллионы потоков с минимальными затратами ресурсов, так как управляются JVM, а не операционной системой.

Основное отличие от традиционных потоков (platform threads) — виртуальные потоки не блокируют ОС-потоки при ожидании I/O-операций (например, сетевых запросов или работы с БД). Это позволяет эффективно использовать ресурсы и упрощает написание высоконагруженных приложений, особенно в сценариях с большим количеством параллельных задач.

Виртуальные потоки идеально подходят для задач, где много ожиданий (I/O-bound), но не для CPU-bound задач, так как не дают реального параллелизма на уровне процессора. Пример `Thread virtualThread = Thread.ofVirtual()`.
# Потокобезопасные коллекции
Потокобезопасные коллекции - это коллекции которые гарантируют правильность работы в многопоточной программе.
# Weakly-Consistent Итераторы
Weakly-Consistent (слабо-согласованные) итераторы — это особый тип итераторов в потокобезопасных коллекциях (например, ConcurrentHashMap, ConcurrentLinkedQueue), которые не гарантируют точной согласованности данных на протяжении итерации, но при этом не выбрасывают ConcurrentModificationException. Они представляют компромисс между производительностью и актуальностью данных.

- Итерировать коллекцию без блокировок (lock-free).
- Частично учитывать изменения, внесенные другими потоками во время итерации.
- Не бросать ConcurrentModificationException.
# CuncuredHashMap

Класс ConcurrentHashMap — это хешированный ассоциативный массив Мар, аналогичный хеш-массиву HashMap, но использующий другую замковую стратегию. Вместо синхронизации каждого метода на общем замке и ограничения доступа одним потоком за раз он использует замковое расщепление на полосы lock striping, расширяющее возможности совместного доступа к ассоциативному массиву. Оно обеспечивает конкурентность между читающими потоками, между читателями и писателями и между писателями. Результатом является высокая пропускная способность в рамках конкурентного доступа с небольшим штрафом на производительность для однопоточного доступа.
# BlockingQueue

Интерфейс BlockingQueue определяет блокирующую очередь, наследующую свойства интерфейса Queue, в которой элементы хранятся в порядке «первый пришел, первый вышел» (FIFO - first in, first out). Реализация данного интерфейса обеспечивает блокировку потока в двух случаях :
1. при попытке получения элемента из пустой очереди; 
2. при попытке размещения элемента в полной очереди.
BlockingQueue изящно решает проблему передачи собранных одним потоком элементов для обработки в другой поток без явных хлопот о проблемах синхронизации.

# CopyOnWriteArrayList

CopyOnWriteArrayList - это потокобезопасный вариант of ArrayList. Подобно ArrayList, CopyOnWriteArray, он управляет массивом для хранения его элементов. Разница в том, что все мутативные операции, такие как add, set, remove, clear,... создают новую копию массива, которым он управляет.
Стоимость использования CopyOnWriteArrayList очень высока, вам придется платить больше за ресурс и производительность. Однако CopyOnWriteArrayList пригодится, когда вы не можете или не хотите синхронизировать при обходе (traversal) элементов списка.

# [[Оглавление]]