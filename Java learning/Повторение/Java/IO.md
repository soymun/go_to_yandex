# [[Оглавление]]

# IO
Данные читаются из источника или записываются в приемник последовательно, **поток байтов за потоком**. Например, `InputStream` позволяет читать данные побайтово или блоками байтов, продвигаясь вперед по потоку. При этом сами данные нигде не сохраняются автоматически – программист читает байты и решает, что с ними делать (можно сразу обработать или сохранить во временный буфер вручную). Невозможно произвольно перемещаться взад-вперед по потоку, не храня данные: если нужно перечитать уже пройденные байты, их следует сохранить (буферизовать) самостоятельно. Проще говоря, классический IO представляет собой **однонаправленный поток данных** от источника к программе (при чтении) или от программы к приемнику (при записи).
# Как работает IO

Байтовые потоки работают на низком уровне, взаимодействуя с операционной системой через **JNI (Java Native Interface)**, который вызывает системные вызовы, такие как `read()` и `write()` в Unix-подобных системах.
![[Pasted image 20250817211121.png]]
# Основные классы для IO
- **Байтовые потоки (Byte Streams)**:
    - **InputStream**: Абстрактный класс для всех потоков ввода байтов.
        - `FileInputStream`: Чтение данных из файла.
        - `ByteArrayInputStream`: Чтение из массива байтов в памяти.
        - `BufferedInputStream`: Добавляет буферизацию для ускорения чтения.
    - **OutputStream**: Абстрактный класс для всех потоков вывода байтов.
        - `FileOutputStream`: Запись данных в файл.
        - `ByteArrayOutputStream`: Запись в массив байтов в памяти.
        - `BufferedOutputStream`: Добавляет буферизацию для ускорения записи.
- **Символьные потоки (Character Streams)**:
    - **Reader**: Абстрактный класс для всех потоков чтения символов.
        - `FileReader`: Чтение текста из файла.
        - `InputStreamReader`: "Мост" от байтовых потоков к символьным (читает байты и декодирует их в символы).
        - `BufferedReader`: Добавляет буферизацию для ускорения чтения символов и позволяет читать текст построчно (`readLine()`).
    - **Writer**: Абстрактный класс для всех потоков записи символов.
        - `FileWriter`: Запись текста в файл.
        - `OutputStreamWriter`: "Мост" от символьных потоков к байтовым (кодирует символы в байты перед записью).
        - `BufferedWriter`: Добавляет буферизацию для ускорения записи символов.
# NIO
 Данные читаются не напрямую программистом, а сначала помещаются в буфер – объект типа `Buffer` (чаще всего используют `ByteBuffer` для байтов). Приложение читает или пишет _непосредственно в буфер_. Такой подход дает большую гибкость: можно перемещаться по содержимому буфера вперед и назад, читать данные не сразу целиком, а по мере готовности и т.д.. Однако возникает задача управления буфером – нужно следить, чтобы буфер содержал все необходимые для обработки данные (если нет – дозагрузить), чтобы не перезаписать непрочитанные данные при новом чтении в буфер, переворачивать буфер из режима записи в режим чтения и пр. Буферно-ориентированный подход делает ввод-вывод **двунаправленным**: буфер служит посредником, через который данные могут как читаться из источника, так и записываться в приемник. В терминах NIO, взаимодействие идет через **канал**: программа сначала запрашивает у канала чтение данных в буфер, после чего может обработать данные из буфера; аналогично для записи – приложение кладет данные в буфер и передает буфер каналу для вывода.
# Как работает NIO

![[nio.gif]]

- **Буферы (Buffers):** Буферы — это контейнеры для данных в NIO. Они представляют собой фиксированный объем памяти, который хранит данные во время операций ввода-вывода. Буферы играют ключевую роль в NIO, так как позволяют эффективно читать и записывать данные через каналы.
- **Каналы (Channels):** Каналы — это шлюзы для передачи данных. Они похожи на потоки в традиционном вводе-выводе, но отличаются тем, что могут одновременно и читать, и записывать данные, а также работают в неблокирующем режиме.
- **Селекторы (Selectors):** Селекторы используются для управления несколькими каналами в рамках одного потока. Это важный аспект NIO, позволяющий эффективно обрабатывать множество соединений без необходимости создавать отдельный поток для каждого из них.
# Основные классы для NIO
- **Каналы (Channels):**
    - `FileChannel`: Для работы с файлами.
    - `SocketChannel`: TCP-клиент.
    - `ServerSocketChannel`: TCP-сервер.
    - `DatagramChannel`: UDP-соединение.
- **Буферы (Buffers):** Основные классы: `ByteBuffer`, `CharBuffer`, `IntBuffer`.
- **Селекторы (Selectors):**
    - `Selector`: Основной класс, мультиплексор каналов.
    - `SelectionKey`: Представляет регистрацию канала у селектора и содержит информацию о готовых операциях (`OP_READ`, `OP_WRITE`, `OP_CONNECT`, `OP_ACCEPT`).
# NIO2

Ключевые нововведения NIO.2 по сравнению с IO/NIO:
1. **Path API:** `java.nio.file.Path` — это интерфейс, представляющий путь в файловой системе. Он заменяет громоздкий класс `java.io.File` и предоставляет более мощный и интуитивно понятный API для манипуляции путями.
2. **Files API:** `java.nio.file.Files` — это утилитный класс с множеством статических методов для выполнения файловых операций.
3. **Asynchronous I/O:** NIO.2 вводит асинхронные каналы, которые позволяют выполнять операции ввода-вывода полностью в асинхронном режиме.
4. **File System API (`FileSystems`):** Предоставляет возможность работать с различными файловыми системами.
# Оптимизации работы с IO/NIO

- **Используйте буферизацию**: всегда оборачивайте потоки в `BufferedInputStream`/`BufferedOutputStream` или `BufferedReader`/`BufferedWriter`.
- **Используйте асинхронные операции**: `AsynchronousFileChannel` или `AsynchronousSocketChannel` для параллельной обработки.
- **Минимизируйте обращения к диску**: используйте `Files` для массовых операций (например, `Files.copy`).

# [[Оглавление]]