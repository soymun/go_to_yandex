# Java и его работа

Java - это объектно-ориентированный язык программирования, который является компилируемо-интерпретируемым. Главным преимуществом данного языка является платформа JVM.
Выполнение кода происходит так:
1. Компиляция - компилятор преобразует код в байт-код, выполняя разрешённые оптимизации.
2. Интерпретация - после этого код интерпретируется JVM, а также компилируется в машинный код во время выполнения с помощью JIT.
# Примитивы

1. «Пустой» тип: `void` 
2. Логический тип: `boolean` (1 бит)
3. Целые числа: `byte` (8 бит) `short` (16 бит) `int` (32 бита) `long` (64 бита) 
4. Числа с плавающей запятой: `float` (32 бита) `double` (64 бита)
5. Символы: `char` (16 бит)
# Литералы

Литерал — фиксированное значение в коде (например, `42`, `"Hello"`, `0b1101`). Представляет константы примитивных типов, строк или `null`.
# Уровни доступа

1. public - члены класса видны во всей программе.
2. default - члены класса видны только в данном package.
3. protected - члены класса видны в данном package и в наследниках.
4. private - члены класса видны только внутри данного класса.
# final

Модификатор `final` может применяться к переменным, параметрам методов, полям, методам класса или самим классам: 
1) Класс не может иметь наследников. 
2) Метод не может быть переопределён в классах-наследниках. 
3) Поле не может изменить своё значение после инициализации. 
4) Параметры методов не могут изменять своё значение внутри метода. 
5) Локальные переменные не могут быть изменены после присвоения им значения.
# static

Ключевое слово static говорит о привязки не к объекту, а к классу. Оно может применяться к:
1. Полям 
2. Методам 
3. Вложенным классам 
4. Членам секции `import`

# transient

Ключевое слово transient говорит о том, что данное поле не будет использовано в сериализации объекта.

# Boolean операторы

1. `&`: Логическое AND (И) 
2. `&&`: Сокращённое AND 
3. `|`: Логическое OR (ИЛИ) 
4. `||`: Сокращённое OR 
5. `^`: Логическое XOR (исключающее OR (ИЛИ)) 
6. `!`: Логическое унарное NOT (НЕ) 
7. `&=` : AND с присваиванием 
8. `|=` : OR с присваиванием 
9. `^=` : XOR с присваиванием 
10. `==` : Равно - `!=` : Не равно 
11. `?:` : Тернарный (троичный) условный оператор (если->то->иначе)

# Битовые операторы

1. `~`: Побитовый унарный NOT 
2. `&`: Побитовый AND 
3. `&=` : Побитовый AND с присваиванием 
4. `|`: Побитовый OR 
5. `|=` : Побитовый OR с присваиванием 
6. `^`: Побитовый исключающий XOR 
7. `^=` : Побитовый исключающий XOR с присваиванием 
8. `>>`: Сдвиг вправо (деление на 2 в степени сдвига) 
9. `>>=` : Сдвиг вправо с присваиванием 
10. `>>>`: Сдвиг вправо без учёта знака 
11. `>>>=` : Сдвиг вправо без учёта знака с присваиванием 
12. `<<`: Сдвиг влево (умножение на 2 в степени сдвига) 
13. `<<=` : Сдвиг влево с присваиванием

# Метод main

Метод public static void main(String[] args), это входная точка в программу, если её нет, программа не будет выполняться.

# Наследование, переопределение и перегрузка

Наследование - это создание класса на основе существующего.
Переопределение - это изменение функционала родительского класса в наследнике(динамический полиморфизм).
Перегрузка - это создание метода с такой же сигнатурой, которая уже есть, но с изменёнными параметрами(статический полиморфизм).

# Абстрактные классы

Класс, помеченный модификатором `abstract`, называется абстрактным классом. Такие классы могут выступать только предками для других классов, экземпляры самого абстрактного класса создавать нельзя. Метод, помеченный `abstract`, — абстрактный метод, не имеющий реализации. Если в классе есть хотя бы один абстрактный метод, класс должен быть объявлен абстрактным. Использование абстрактных классов и методов позволяет описать шаблон объекта, который должен быть реализован в других классах, описывая общее поведение для всех потомков.

# Интерфейсы

Ключевое слово `interface` используется для создания полностью абстрактных классов. Интерфейс определяет, каким образом можно использовать класс, реализующий его, задавая имена методов, списки аргументов и типы возвращаемых значений без реализации их поведения. 
1. Все методы неявно объявляются как `public`. 
2. Интерфейсы могут содержать методы с реализацией по умолчанию (`default`) и статические методы (`static`). 
3. Поля интерфейса автоматически являются `public`, `static` и `final`.

При наследовании нескольких интерфейсов с одинаковыми методами, необходимо самостоятельно определить метод интерфейса и вызвать его(если default).

# Отличие интерфейсов от абстрактных классов

1. Интерфейсы не могут иметь не статические свойства.
2. Абстрактный класс создаёт более жёсткую связь между объектами, а интерфейсы - это полностью разрозненные классы.
3. Можно наследовать несколько интерфейсов.

# Типы классов

Final - это классы, которые не могут иметь наследников.
Top-Level - это самые обычные классы, которые создаю каждый день.
Вложенные:
1. Static Nested - это класс, который прикреплён к классу, а не к объекту, все правила static
2. Inner - это обычный класс, описанный внутри другого класса.
3. Local - класс внутри блока
4. Anonymous - это класс объекта, который был наследован от кого-то, но не был создан обычный класс, а была реализация "на месте". 

# Класс Object

Класс Object - это класс всех классов, все классы неявно наследуют его. У него есть 9 методов: equals(), hashCode(), toString(), clone(), getClass(), wait(), notify(), notifyAll(), finilaze().

# Метод finalize и его аналог

Метод finalize класса Object  является устаревшим и его лучше не использовать. Если его переопределить, мы получим доступ к реализации чего-то, перед удалением данного объекта GC. У него есть аналог в виде Cleaner, класс который появился в Java 9.

# Методы equals и hashcode

equals() - метод сравнения двух объектов.
hashCode() - метод получения hashCode для данного объекта.

Данные методы связаны контрактом - при переопределении equals, необходимо переопределить hashCode и если equals вернёт true, то hashCode возможно вернёт одинаковые hashCode, если false, то возможно разные.

Правила переопределения метода equals():
1) Проверка с помощью `==`: Если аргумент — та же ссылка, вернуть `true`. Если `null`, вернуть `false`. 
2) Проверка типа с `instanceof` или `getClass()`. Если тип неверный, вернуть `false`. 
3) Приведение аргумента к правильному типу. 
4) Сравнение значимых полей. Если все совпадают, вернуть `true`, иначе — `false`. 
5) Проверка свойств: рефлексивность, симметричность, транзитивность, непротиворечивость.

Правила переопределения метода Object.hashCode():
1. Равные объекты (`equals()`) должны иметь одинаковый хэш-код. 
2. Хэш-код должен быть равномерно распределён для лучшей производительности.
3. Хэш-код не должен меняться во время жизни объекта. 
4. Используйте поля, участвующие в `equals()`, для вычисления. 

Реализация hashCode в HotSpot:

1. -XX:hashCode=0

	Случайное число по алгоритму Lehmer RNG. Генератор один на всех, поэтому работает медленно

2. -XX:hashCode=2

	 Чемпион по скорости, всегда возвращает 1: java.lang.Object@1 Используется как отправная точка для тестов остальных стратегий

3. -XX:hashCode=3

	Обычная возрастающая последовательность: java.lang.Object@a4 java.lang.Object@a5 java.lang.Object@a6

4. -XX:hashCode=4

	 Текущий адрес в памяти. Популярный, но неправильный ответ на собеседованиях. Отчасти в этом виновата спецификация: там адрес приводится как пример реализации. Работает быстро, но не даёт равномерного распределения и должного уровня уникальности

5. -XX:hashCode=1

	Адрес объекта в памяти и немного манипуляций с битами(Стратегия по умолчанию)

# Метод clone

Блоки инициализации

Вызов инициализации

instrict и native методы

Приведение

Функциональный интерфейс

Основные функциональные интерфейсы

Лямбда

Date-Time Api

Optional

[[Collection]]