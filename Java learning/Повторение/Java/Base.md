# [[Оглавление]]

# Java и его работа

**Java** — это объектно-ориентированный язык программирования, известный своей универсальностью и надёжностью. Его главное преимущество — это возможность работать на различных устройствах и операционных системах благодаря **виртуальной машине Java (JVM)**.

Процесс выполнения Java-кода состоит из двух основных этапов:

1. **Компиляция**. Сначала исходный код (файлы `.java`) компилируется в промежуточный формат — **байт-код** (файлы `.class`). Этот шаг позволяет проверить код на ошибки и выполнить некоторые начальные оптимизации.
2. **Интерпретация и JIT-компиляция**. Затем JVM загружает и выполняет этот байт-код. Для повышения производительности JVM использует **JIT-компилятор (Just-In-Time)**. Он анализирует часто используемые части байт-кода и прямо во время выполнения компилирует их в **машинный код** . Это значительно ускоряет работу программы.
# Примитивы

1. «Пустой» тип: `void` 
2. Логический тип: `boolean` (1 бит)
3. Целые числа: `byte` (8 бит) `short` (16 бит) `int` (32 бита) `long` (64 бита) 
4. Числа с плавающей запятой: `float` (32 бита) `double` (64 бита)
5. Символы: `char` (16 бит)
# Integer Pool
Это место в хипе где  кэшируются значения в диапазоне **от -128 до 127** (по умолчанию, но верхнюю границу можно увеличить через параметр JVM `-XX:AutoBoxCacheMax`).
# Литералы

Литерал — фиксированное значение в коде (например, `42`, `"Hello"`, `0b1101`). Представляет константы примитивных типов, строк или `null`.
# Уровни доступа

1. public - члены класса видны во всей программе.
2. default - члены класса видны только в данном package.
3. protected - члены класса видны в данном package и в наследниках.
4. private - члены класса видны только внутри данного класса.
# final

Модификатор `final` может применяться к переменным, параметрам методов, полям, методам класса или самим классам: 
1) Класс не может иметь наследников. 
2) Метод не может быть переопределён в классах-наследниках. 
3) Поле не может изменить своё значение после инициализации. 
4) Параметры методов не могут изменять своё значение внутри метода. 
5) Локальные переменные не могут быть изменены после присвоения им значения.
# static

Ключевое слово static говорит о привязки не к объекту, а к классу. Оно может применяться к:
1. Полям 
2. Методам 
3. Вложенным классам 
4. Членам секции `import`

# transient

Ключевое слово transient говорит о том, что данное поле не будет использовано в сериализации объекта.

# Boolean операторы

1. `&`: Логическое AND (И) 
2. `&&`: Сокращённое AND 
3. `|`: Логическое OR (ИЛИ) 
4. `||`: Сокращённое OR 
5. `^`: Логическое XOR (исключающее OR (ИЛИ)) 
6. `!`: Логическое унарное NOT (НЕ) 
7. `&=` : AND с присваиванием 
8. `|=` : OR с присваиванием 
9. `^=` : XOR с присваиванием 
10. `==` : Равно - `!=` : Не равно 
11. `?:` : Тернарный (троичный) условный оператор (если->то->иначе)

# Битовые операторы

1. `~`: Побитовый унарный NOT 
2. `&`: Побитовый AND 
3. `&=` : Побитовый AND с присваиванием 
4. `|`: Побитовый OR 
5. `|=` : Побитовый OR с присваиванием 
6. `^`: Побитовый исключающий XOR 
7. `^=` : Побитовый исключающий XOR с присваиванием 
8. `>>`: Сдвиг вправо (деление на 2 в степени сдвига) 
9. `>>=` : Сдвиг вправо с присваиванием 
10. `>>>`: Сдвиг вправо без учёта знака 
11. `>>>=` : Сдвиг вправо без учёта знака с присваиванием 
12. `<<`: Сдвиг влево (умножение на 2 в степени сдвига) 
13. `<<=` : Сдвиг влево с присваиванием

# Метод main

Метод `public static void main(String[] args)` — это обязательная **входная точка** для любой программы на Java. Именно с него начинается выполнение всего кода.
**Если этот метод отсутствует**, компилятор не сможет найти, с чего начать, и программа просто не запустится.

# Наследование, переопределение и перегрузка

**Наследование** — это мощный механизм, который позволяет создавать новый класс (наследник или дочерний класс) на основе уже существующего (родительский или базовый класс).
**Переопределение метода** — это возможность в классе-наследнике изменить или полностью заменить функционал метода, который был унаследован от родительского класса. Этот механизм является основой **динамического полиморфизма**.
**Перегрузка метода** — это создание нескольких методов с одним и тем же именем, но с **разными параметрами** в пределах одного и того же класса. Это пример **статического полиморфизма**.

# Абстрактные классы

Класс, помеченный модификатором `abstract`, называется абстрактным классом. Такие классы могут выступать только предками для других классов, экземпляры самого абстрактного класса создавать нельзя. Метод, помеченный `abstract`, — абстрактный метод, не имеющий реализации. Если в классе есть хотя бы один абстрактный метод, класс должен быть объявлен абстрактным. Использование абстрактных классов и методов позволяет описать шаблон объекта, который должен быть реализован в других классах, описывая общее поведение для всех потомков.

# Интерфейсы

Ключевое слово `interface` используется для создания полностью абстрактных классов. Интерфейс определяет, каким образом можно использовать класс, реализующий его, задавая имена методов, списки аргументов и типы возвращаемых значений без реализации их поведения. 
1. Все методы неявно объявляются как `public`. 
2. Интерфейсы могут содержать методы с реализацией по умолчанию (`default`) и статические методы (`static`). 
3. Поля интерфейса автоматически являются `public`, `static` и `final`.

При наследовании нескольких интерфейсов с одинаковыми методами, необходимо самостоятельно определить метод интерфейса и вызвать его(если default).

# Отличие интерфейсов от абстрактных классов

1. Интерфейсы не могут иметь не статические свойства.
2. Абстрактный класс создаёт более жёсткую связь между объектами, а интерфейсы - это полностью разрозненные классы.
3. Можно наследовать несколько интерфейсов.

# Типы классов

**`final`** — это классы, которые **нельзя унаследовать**. Они запрещают создание наследников, что гарантирует неизменность их поведения. Это часто используется для создания надёжных и безопасных классов, например, класса `String` в Java.
**Top-Level** (или классы верхнего уровня) — это самые обычные классы, которые мы создаём в отдельных файлах `.java`. Они не вложены ни в какие другие классы и являются основой большинства программ.
**Nested Class**
1. **Static Nested Class**. Это класс, который находится внутри другого, но объявлен с модификатором `static`. Он привязан к внешнему классу, а не к его объекту. Это значит, что он может получить доступ только к статическим членам внешнего класса.
2. **Inner Class**. Это обычный класс, вложенный в другой. Он тесно связан с объектом внешнего класса и может обращаться ко всем его членам (включая приватные). Inner Class не может содержать статические методы или поля.
3. **Local Class**. Это класс, который определяется внутри блока кода, например, внутри метода. Он виден и доступен только внутри этого блока. Local Class часто используют, когда класс нужен только в одном конкретном месте.
4. **Anonymous Class**. Это уникальный тип, у которого нет имени. Его создают и реализуют "на месте", обычно для того, чтобы унаследовать класс или реализовать интерфейс. Он используется, когда нужен всего один объект с переопределённым поведением.

# Класс Object

**Класс `Object`** — это основа всей иерархии классов в Java. Он является **родителем всех классов**, и каждый класс неявно наследует его, даже если это не указано явно. Благодаря этому, все объекты в Java имеют общий набор базовых методов. У него есть 9 методов: equals(), hashCode(), toString(), clone(), getClass(), wait(), notify(), notifyAll(), finilaze().

# Метод finalize и его аналог

Метод finalize класса Object  является устаревшим и его лучше не использовать. Если его переопределить, мы получим доступ к реализации чего-то, перед удалением данного объекта GC. У него есть аналог в виде Cleaner, класс который появился в Java 9.

# Методы equals и hashcode

equals() - метод сравнения двух объектов.
hashCode() - метод получения hashCode для данного объекта.

Данные методы связаны контрактом - при переопределении equals, необходимо переопределить hashCode и если equals вернёт true, то hashCode возможно вернёт одинаковые hashCode, если false, то возможно разные.

Правила переопределения метода equals():
1) Проверка с помощью `==`: Если аргумент — та же ссылка, вернуть `true`. Если `null`, вернуть `false`. 
2) Проверка типа с `instanceof` или `getClass()`. Если тип неверный, вернуть `false`. 
3) Приведение аргумента к правильному типу. 
4) Сравнение значимых полей. Если все совпадают, вернуть `true`, иначе — `false`. 
5) Проверка свойств: рефлексивность, симметричность, транзитивность, непротиворечивость.

Правила переопределения метода Object.hashCode():
1. Равные объекты (`equals()`) должны иметь одинаковый хэш-код. 
2. Хэш-код должен быть равномерно распределён для лучшей производительности.
3. Хэш-код не должен меняться во время жизни объекта. 
4. Используйте поля, участвующие в `equals()`, для вычисления. 

Реализация hashCode в HotSpot:

1. -XX:hashCode=0

	Случайное число по алгоритму Lehmer RNG. Генератор один на всех, поэтому работает медленно

2. -XX:hashCode=2

	 Чемпион по скорости, всегда возвращает 1: java.lang.Object@1 Используется как отправная точка для тестов остальных стратегий

3. -XX:hashCode=3

	Обычная возрастающая последовательность: java.lang.Object@a4 java.lang.Object@a5 java.lang.Object@a6

4. -XX:hashCode=4

	 Текущий адрес в памяти. Популярный, но неправильный ответ на собеседованиях. Отчасти в этом виновата спецификация: там адрес приводится как пример реализации. Работает быстро, но не даёт равномерного распределения и должного уровня уникальности

5. -XX:hashCode=1

	Адрес объекта в памяти и немного манипуляций с битами(Стратегия по умолчанию)

# Метод clone

Метод **`clone()`** — это способ создать точную копию объекта в Java. Он определён в классе `Object` и по умолчанию выбрасывает исключение `CloneNotSupportedException`. Чтобы ваш класс мог быть клонирован, он должен реализовать специальный пустой интерфейс **`Cloneable`**.
Существует 2 вида клонирования - поверхностное и глубокое. Поверхностное клонирование - это клонирование значений, но ссылки остаются те же. Глубокое клонирование - клонирование как данного объекта, так и связанных с ним.
# Блоки инициализации

В Java существует 2 вида блоков инициализации - статические и нестатические. Статические блоки - блоки с ключевым слово static, имеют доступ только к static элементам и выполняются при загрузке классов. Нестатические блоки - это блоки которые выполняются при создании объекта перед конструктором.
# Вызов инициализации
1) Статические блоки инициализации родительского класса (один раз при загрузке класса). 
2) Статические блоки инициализации текущего класса. 
3) Нестатические (экземплярные) блоки инициализации родительского класса. 
4) Конструктор родительского класса. 
5) Нестатические (экземплярные) блоки инициализации текущего класса. 
6) Конструктор текущего класса.
# instrict и native методы

1. **Native**: Реализованы на платформенном языке (например, C++). Пример: `Object.hashCode`. - 
2. **Intrinsic**: Выглядят как обычные Java-методы, но JVM заменяет их нативной реализацией для оптимизации
# Приведение

**Приведение типов** позволяет работать с объектом-наследником через ссылку на его родительский класс. Это фундаментальная концепция полиморфизма.
**Приведение к родительскому классу (Upcasting)**: Это когда объект-наследник присваивается переменной типа родительского класса. Например, `Vehicle vehicle = new Car();`. Это происходит автоматически и безопасно.
**Приведение к классу-наследнику (Downcasting)**: Это обратный процесс, когда ссылка на родительский класс приводится к типу наследника. Например, `Car car = (Car) vehicle;`. Это требует явного указания типа в скобках. Если объект `vehicle` на самом деле не является объектом `Car`, будет выброшено исключение **`ClassCastException`**.

В Java также есть и `autoboxing` - это процесс приведения примитивных типов данных к ссылочным, то есть объектам.

# Функциональный интерфейс

Функциональный интерфейс - это интерфейс у которого не реализован только 1 метод. Так же такой интерфейс может быть помечен специальной аннотацией `@FunctionalInterface`, тогда компилятор проверит правила функционального интерфейса.


# Лямбда

Лямбда - это реализация функционального интерфейса. Реализуется с помощью `->`.

# Типы ссылок

1. **Сильные**, они же обычные, нужны для указания на объекты, которые должны обязательно оставаться в памяти всё то время, что эти ссылки на него существуют. Если не складывается, получите `OutOfMemoryError`.
2. **Мягкие** ссылки полезны для кэшей, чувствительных к доступному объёму оперативной памяти. Объекты по ним могут зачиститься, но только в случае необходимости. Например, если нужно насоздавать ещё объектов с сильными ссылками, а уже негде, лучше освободить кэш и замедлить работу, чем уронить процесс напрочь.
3. **Слабые** ссылки полезны для сопоставления объектов чему-нибудь без удерживания их от зачистки когда они больше не нужны (а-ля `Map<Ключ, WeakRef<Значение>>`). На возможность зачистки они не влияют вообще никак, слабые ссылки будут очищены при очередном запуске сборщика.
4. **Фантомные** ссылки возникают, когда объект уже признан мусором, финализирован и находится в процессе зачистки, о чём можно узнать с помощью класса `Cleaner` и выполнить в это время какие-то собственные действия.
# Date-Time Api

Datetime API в Java, представленный в пакете `java.time`, был добавлен в **Java 8** и предназначен для решения проблем, связанных с работой со временем и датами, которые существовали в предыдущих версиях.
### Основные классы и их назначение

Пакет `java.time` содержит множество классов, но основными, с которыми вы будете работать чаще всего, являются:

- **`LocalDate`**: Этот класс представляет дату **без времени и часового пояса**. Он идеально подходит для таких задач, как хранение дня рождения, даты отпуска или любого другого события, где время не имеет значения. Например, `LocalDate.now()` вернёт текущую дату.

- **`LocalTime`**: Представляет время **без даты и часового пояса**. Используйте его, когда вам нужно хранить только время, например, время открытия магазина или начала рабочего дня. Вы можете получить текущее время с помощью `LocalTime.now()`.

- **`LocalDateTime`**: Объединяет в себе **дату и время, но всё ещё без часового пояса**. Это самый часто используемый класс для работы с датой и временем в рамках одного часового пояса, например, для создания отметки времени в логах или планирования встречи.

- **`ZonedDateTime`**: Если вам нужно учитывать **часовые пояса**, используйте этот класс. Он содержит дату, время и информацию о часовом поясе. Это критически важно для международных приложений, чтобы правильно отображать время для пользователей в разных уголках мира.

- **`Instant`**: Представляет собой **точный момент времени на временной шкале**, обычно в секундах или наносекундах с начала эпохи (1 января 1970 года). Он не содержит никакой информации о часовом поясе и используется для высокоточных измерений.

# Optional

Класс `Optional` в Java предназначен для представления опциональных значений вместо использования `null`-ссылок. Это контейнер, который может содержать объект типа `T` или быть пустым, помогая избежать `NullPointerException` и улучшая читаемость кода.

**Описание**:
- `Optional` — это обёртка, которая явно указывает на возможность отсутствия значения.
- Способствует функциональному программированию и явной обработке случаев, когда значение может быть `null`.

Согласно Javadoc, `Optional` предназначен для:

- Использования в качестве возвращаемого типа метода, когда результат может отсутствовать.
- Явного представления "отсутствия значения" вместо `null` для предотвращения ошибок.

# [[Оглавление]]