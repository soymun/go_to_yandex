# [[Оглавление]]

# Что такое коллекция
«Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.
# Как работает красно черное дерево

Красно-чёрное дерево — это бинарное дерево поиска с дополнительным атрибутом цвета (красный или чёрный) для каждого узла, которое обеспечивает балансировку через соблюдение определённых правил. Эти правила гарантируют, что дерево остаётся сбалансированным, а высота дерева ограничена O(log n), что делает операции эффективными.
### Свойства красно-чёрного дерева
1. **Цвет узла**: Каждый узел либо **красный**, либо **чёрный**.
2. **Корень чёрный**: Корень дерева всегда чёрный.
3. **Листы (NIL)**: Все листья (внешние null-узлы) считаются чёрными.
4. **Красные узлы**: Если узел красный, оба его потомка должны быть чёрными (запрещены два последовательных красных узла).
5. **Чёрная высота**: Для каждого узла все пути от него до листьев (NIL) содержат одинаковое количество чёрных узлов.

Эти свойства гарантируют, что самый длинный путь от корня до листа не более чем в два раза длиннее самого короткого пути, что обеспечивает балансировку.
# fasil-safe fail-fast
Fail-Fast (быстрое прерывание) — это поведение итераторов в Java, при котором коллекция немедленно выбрасывает ConcurrentModificationException, если обнаруживает изменение структуры коллекции (добавление, удаление элементов) во время итерации, кроме случаев, когда изменение делается через методы самого итератора. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени.

Fail-Safe (отказоустойчивое) поведение — это подход, при котором итераторы работают с копией (snapshot) исходной коллекции, поэтому не выбрасывают ConcurrentModificationException, даже если исходная коллекция изменяется во время итерации.
# CuncurredModifyException

ConcurrentModificationException - это ошибка, которая выбрасывается при обработке коллекции, когда у коллекции взят итератор, но изменяются элементы через коллекцию. Реализовано с помощью счётчика внутри коллекции.
# Иерархия коллекций
![[Pasted image 20250816200225.png]]
# Что такое принцип PECS

PECS: **Producer Extends, Consumer Super**.
1. **Producer (`? extends T`)**: Для чтения данных.
2. **Consumer (`? super T`)**: Для записи данных.
# List

List - это основной интерфейс для реализаций динамических массивов. Основные реализации:
1. ArrayList - обычный динамических массив, реализация через массив + расширение при заполнении.
2. LinkedList - двухсвязный массив, реализация через Node.
3. CopyOnWriteArrayList - поток безопасный массив, итерирующийся через копии. 
# Set

Set - это основной интерфейс для реализаций множеств. Основным отличием является то, что данные в множестве уникальны и получать доступ к ним мы можем только через Iterator. Основные реализации:

1. HashSet - реализован за счёт HashMap, где ключи это значения, а значение это заглушка.
2. TreeSet - реализован как бинарное дерево, основным отличием является то, что элемент должен иметь Comporator.
# Queue

Queue - основной интерфейс для реализаций LIFO и FIFO. Основные реализации: LinkedList, ArrayDequeue - реализован на массиве, PriorityQueue - использует минимальную бинарную кучу, реализация массив.
# Map

Map - это ассоциативный массив, отдельное подмножество коллекций, не относящиеся к основным. Основные преимущества - это получение данных за O(1). Основные реализации:

1. HashMap состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется. По дефолту  capacity 16, loadfactor - 0.75.
2. LinkedHashMap - это HashMap с дополнительными полями для реализации выдачи элементов, с помощью LinkedList.
3. TreeMap - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в конструкторе. Красно-черные деревья это самобалансирующееся дерево которое гарантирует логарифмический рост высоты дерева от числа узлов
# Потокобезопасные коллекции
Потокобезопасные коллекции - это коллекции которые гарантируют правильность работы в многопоточной программе.
# Weakly-Consistent Итераторы
Weakly-Consistent (слабо-согласованные) итераторы — это особый тип итераторов в потокобезопасных коллекциях (например, ConcurrentHashMap, ConcurrentLinkedQueue), которые не гарантируют точной согласованности данных на протяжении итерации, но при этом не выбрасывают ConcurrentModificationException. Они представляют компромисс между производительностью и актуальностью данных.

- Итерировать коллекцию без блокировок (lock-free).
- Частично учитывать изменения, внесенные другими потоками во время итерации.
- Не бросать ConcurrentModificationException.
# CuncuredHashMap

Класс ConcurrentHashMap — это хешированный ассоциативный массив Мар, аналогичный хеш-массиву HashMap, но использующий другую замковую стратегию. Вместо синхронизации каждого метода на общем замке и ограничения доступа одним потоком за раз он использует замковое расщепление на полосы lock striping, расширяющее возможности совместного доступа к ассоциативному массиву. Оно обеспечивает конкурентность между читающими потоками, между читателями и писателями и между писателями. Результатом является высокая пропускная способность в рамках конкурентного доступа с небольшим штрафом на производительность для однопоточного доступа.
# BlockingQueue

Интерфейс BlockingQueue определяет блокирующую очередь, наследующую свойства интерфейса Queue, в которой элементы хранятся в порядке «первый пришел, первый вышел» (FIFO - first in, first out). Реализация данного интерфейса обеспечивает блокировку потока в двух случаях :
1. при попытке получения элемента из пустой очереди; 
2. при попытке размещения элемента в полной очереди.
BlockingQueue изящно решает проблему передачи собранных одним потоком элементов для обработки в другой поток без явных хлопот о проблемах синхронизации.

# CopyOnWriteArrayList

CopyOnWriteArrayList - это потокобезопасный вариант of ArrayList. Подобно ArrayList, CopyOnWriteArray, он управляет массивом для хранения его элементов. Разница в том, что все мутативные операции, такие как add, set, remove, clear,... создают новую копию массива, которым он управляет.
Стоимость использования CopyOnWriteArrayList очень высока, вам придется платить больше за ресурс и производительность. Однако CopyOnWriteArrayList пригодится, когда вы не можете или не хотите синхронизировать при обходе (traversal) элементов списка.

# [[Оглавление]]