# [[Оглавление]]

# Что такое Off-Heap

Это память, которую процесс JVM запрашивает у операционной системы напрямую, минуя механизмы управления памятью самой JVM. С точки зрения ОС, это просто еще один блок памяти, выделенный процессу `java`. Для JVM — это "черный ящик", содержимое которого ей неизвестно.

Сборщик мусора (Garbage Collector, GC) JVM полностью игнорирует данные, расположенные в этой области. GC отслеживает только объекты, находящиеся в Java-куче (Heap). Это имеет два важных последствия:
1. **Отсутствие пауз GC:** Большие объемы данных в Off-Heap не вызывают длительных пауз сборщика мусора, так как ему не нужно сканировать эти данные.
2. **Ответственность на программисте:** Освобождение этой памяти — полностью задача программиста (либо напрямую, либо через обертки).
# Как реализуется off-heap

**`ByteBuffer.allocateDirect`**. Этот API создает в Java-куче легковесный объект-обертку `DirectByteBuffer`, который по сути является указателем на участок памяти, выделенный в нативной среде через вызов, аналогичный `malloc`. Ключевое преимущество этого подхода — **автоматическое управление памятью**. Когда сборщик мусора определяет, что объект-обертка больше не используется, специальный механизм `Cleaner` автоматически вызывает системную функцию `free` для освобождения нативной памяти. Это делает `ByteBuffer.allocateDirect` идеальным и безопасным решением для высокопроизводительных операций ввода-вывода, таких как работа с сетью или файлами, поскольку позволяет операционной системе напрямую взаимодействовать с буфером, избегая лишнего копирования данных между ядром и Java-кучей.

`sun.misc.Unsafe`. Этот "хакерский" способ предоставляет прямой, сырой доступ к управлению памятью через методы, напоминающие C: `allocateMemory` (аналог `malloc`) и `freeMemory` (аналог `free`). Программист получает возможность читать и записывать данные по конкретным адресам памяти (например, через `putByte` или `getLong`). Однако такая мощь сопряжена с огромными рисками, поскольку управление памятью становится **полностью ручным**. Программист обязан сам вызывать `freeMemory`, и любая ошибка, такая как забытый вызов, запись за пределы выделенного блока или обращение к уже освобожденной памяти, может легко привести к **утечкам памяти, повреждению данных или полному краху JVM**.

С появлением Java 9+ был предложен современный и безопасный подход, сочетающий производительность `Unsafe` с надежностью — **`VarHandle` и Foreign Function & Memory (FFM) API**. Эта система разделяет процессы выделения памяти и доступа к ней. Память выделяется через FFM API с помощью объекта `MemorySegment`, который инкапсулирует в себе информацию о выделенном блоке, его размере и жизненном цикле. Это позволяет избежать выхода за границы. Для чтения и записи данных используется `VarHandle` — безопасный механизм, который выполняет проверку типов и границ доступа во время операций. Таким образом, освобождение памяти управляется через жизненный цикл `MemorySegment`, что гораздо надежнее ручного режима и делает этот подход рекомендуемым для работы с нативной памятью в современном Java.

# Плюсы и минусы off-heap

**Преимущества (Почему это используют):**
1. **Снижение пауз GC:** Самая главная причина. Если у вас есть большие объемы долгоживущих данных (например, кэш на 50 ГБ), размещение их в куче привело бы к катастрофически долгим паузам Full GC. В Off-Heap GC их не трогает.
2. **Возможность использовать больше памяти:** Можно выделить больше памяти, чем лимит кучи (`-Xmx`). Общий объем памяти процесса будет ограничен только доступной RAM в ОС.
3. **Zero-Copy I/O:** При работе с сетью или файлами данные из Off-Heap буфера могут быть переданы напрямую в сокет или на диск ядром ОС, минуя копирование в промежуточные буферы в Java-куче. Это значительно ускоряет I/O операции.
4. **Разделяемая память (Shared Memory):** Off-Heap память (особенно через memory-mapped files) может быть доступна нескольким процессам, что позволяет организовать сверхбыстрое межпроцессное взаимодействие.

**Недостатки (Цена, которую вы платите):**
1. **Сложность и риски:** Ручное управление памятью — источник трудноуловимых ошибок (утечки, повреждение памяти).
2. **Более медленное выделение/освобождение:** `malloc`/`free` — это системные вызовы, они на порядки медленнее, чем выделение маленького объекта в куче (в TLAB). Off-Heap хорош для больших и долгоживущих кусков памяти, а не для маленьких и короткоживущих.
3. **Нет безопасности Java:** `Unsafe` полностью ломает модель безопасности Java.
4. **Сложность отладки и мониторинга:** Стандартные профилировщики кучи (heap dump analysis) не покажут вам содержимое Off-Heap. Нужны специальные инструменты.

# Системные вызовы для off-heap

- **`malloc`:** Не запрашивает память у ОС при каждом вызове. Вместо этого она берёт кусок из большого пула памяти, уже полученного от ОС ранее. Это быстрая операция. Только когда этот пул заканчивается, `malloc` обращается к ОС за новым большим куском, что является " дорогой" (медленной) операцией.
- **`free`:** Не возвращает память обратно ОС. Она просто помечает блок как свободный внутри своего пула, чтобы его можно было быстро переиспользовать для будущих вызовов `malloc`.

# Что такое zero-copy

**Zero-copy** (нулевое копирование) — это принцип оптимизации в программировании, который позволяет передавать данные между различными частями системы (например, из файла в сеть) без лишнего копирования этих данных в памяти. Основная цель этого подхода — уменьшить нагрузку на центральный процессор (CPU) и сократить использование пропускной способности памяти, что в итоге значительно повышает производительность приложений, особенно тех, что интенсивно работают с вводом-выводом (I/O).
# Как реализовать zero-copy в Java

В Java механизм zero-copy реализуется через пакет `java.nio` (New I/O), который предоставляет низкоуровневые инструменты для работы с вводом-выводом. Основным инструментом для этого является класс `java.nio.channels.FileChannel`.

Самый распространенный и прямой способ использования zero-copy в Java — это метод `transferTo()`. Этот метод позволяет передавать байты напрямую из `FileChannel` в другой канал (`WritableByteChannel`), например, в `SocketChannel`.
# [[Оглавление]]