# Основные базы данных
1. **template0** - Используется для восстановления из логических резервных копий или создания баз с другой кодировкой.
2. **template1** - Служит шаблоном для новых баз данных, создаваемых командой `CREATE DATABASE`.
3. **postgres** - Обычная база данных для общего использования.

# Системный каталог

**Системный каталог** — это набор таблиц и представлений, хранящих метаданные обо всех объектах кластера: базах данных, таблицах, индексах, типах, функциях и т.д.
Каждая база данных имеет собственный системный каталог, описывающий её объекты. Также существуют общие таблицы кластера, доступные из любой базы (формально хранятся в базе с OID=0).

## Структура:
- Таблицы системного каталога имеют префикс **pg_** (например, `pg_database`, `pg_class`, `pg_attribute`).
- Столбцы в этих таблицах начинаются с трехбуквенного кода, соответствующего имени таблицы (например, `datname` в `pg_database` для имени базы).
- Первичный ключ — столбец **oid** (тип `oid`, 32-битное целое число), уникально идентифицирующий объект.

## OID
**OID** (Object Identifier) — это уникальный идентификатор, генерируемый единым счетчиком для всех объектов кластера.
Особенности:
- Используется в разных таблицах системного каталога.
- Если диапазон значений (2??) исчерпан, счетчик обнуляется, а уникальность проверяется индексами.
# Схемы

**Схемы** — это пространства имен внутри базы данных, позволяющие группировать объекты (таблицы, индексы, функции).
1. **public**:
    - Используется по умолчанию для пользовательских объектов, если схема не указана.
2. **pg_catalog**:
    - Хранит таблицы и представления системного каталога.
    - Всегда включена в путь поиска (`search_path`).
3. **information_schema**:
    - Предоставляет стандартизированное (SQL) представление метаданных.
4. **pg_toast**:
    - Используется для хранения данных, вынесенных по технологии TOAST
5. **pg_temp**:
    - Содержит временные таблицы, создаваемые в схемах `pg_temp_N` для каждого пользователя.
## Путь поиска
- Параметр `search_path` определяет порядок поиска схем для объектов, если схема не указана явно.
- По умолчанию: `search_path = "$user", public`, где `"$user"` — схема с именем текущего пользователя.
- Схемы `pg_catalog` и `pg_temp` добавляются неявно.

# Табличные пространства
**Табличные пространства** — это физические каталоги в файловой системе, где хранятся данные базы. Позволяют разделять данные по типу носителей (например, медленные HDD для архивов, быстрые SSD для активных данных).
- **pg_default**:
    - Расположен в `PGDATA/base`.
    - Используется для объектов, если не указано иное.
- **pg_global**:
    - Расположен в `PGDATA/global`.
    - Хранит общие объекты системного каталога, доступные всему кластеру.
## Логическая и физическая структура
- Логическая структура (базы, схемы) независима от физической (табличные пространства).
- Одна база может использовать несколько табличных пространств, и одно пространство — несколько баз.



# Отношения

**Отношения** — это объекты базы данных, состоящие из строк: таблицы, индексы, последовательности, материализованные представления. Термин происходит от реляционной теории, но в PostgreSQL охватывает больше объектов, чем классические таблицы. Хранятся в таблице `pg_class`, где столбцы начинаются с префикса `rel` (например, `relname`, `relfilenode`).

# Слои и файлы

Каждое отношение делится на **слои** (forks), каждый из которых хранит определенный тип данных:
1. **Основной слой** (main fork):
    - Содержит данные таблицы или индекса.
    - Имя файла — числовой идентификатор (`relfilenode` из `pg_class`).
2. **Карта свободного пространства** (free space map, `_fsm`):
    - Отслеживает свободное место на страницах для оптимизации вставки данных.
    - Создается после операций, таких как `VACUUM`.
3. **Карта видимости** (visibility map, `_vm`):
    - Хранит информацию о страницах, требующих очистки или заморозки.
    - Используется для ускорения `VACUUM` и индексного сканирования.
4. **Слой инициализации** (init fork, `_init`):
    - Создается для нежурналируемых таблиц (`UNLOGGED`) и их индексов.
    - Используется для восстановления пустого состояния после сбоя.

![[Pasted image 20250903210511.png]]

Каждый слой представлен одним или несколькими файлами. Если файл превышает 1 ГБ, создается новый сегмент (например, `16385.1`, `16385.2`). Ограничение в 1 ГБ можно изменить при сборке PostgreSQL (`--with-segsize`). Файлы хранятся в подкаталогах табличных пространств, организованных по базам данных (например, `PGDATA/base/16384/` для базы с OID=16384).
# Страницы

Файлы делятся на **страницы** (обычно 8 КБ) — минимальные единицы ввода-вывода.
Размер страницы задается при сборке PostgreSQL (`--with-blocksize`, до 32 КБ).
Страницы кэшируются в **буферном кэше** для ускорения доступа.

# TOAST

**TOAST** (The Oversized Attributes Storage Technique) — технология для хранения длинных строк, которые не помещаются на одной странице (~ 2000 байт после вычета заголовка).
**Цель**: обеспечить размещение строки на одной странице или вынести её части в отдельную таблицу.
## Стратегии:
1. **plain** - TOAST не используется (для коротких типов, например, `integer`).
2. **extended** - Сначала сжатие, затем, если нужно, хранение в `pg_toast`.
3. **external** - Хранение в `pg_toast` без сжатия (например, для JPEG).
4. **main** -  Сжатие, затем хранение в `pg_toast`, если сжатие не помогло.

## Алгоритм:
1. Если строка превышает ~2000 байт, применяются стратегии `extended` и `external`:
    - Сжимаются атрибуты `extended`, выносятся в `pg_toast`, если всё ещё длинные.
    - Атрибуты `external` выносятся без сжатия.
2. Если строка всё ещё велика, сжимаются атрибуты `main`.
3. Если нужно, атрибуты `main` выносятся в `pg_toast`.

## TOAST-таблицы
1. Создаются автоматически для таблиц с длинными типами (`text`, `json`, `numeric`).
2. Хранятся в схеме `pg_toast` (или `pg_toast_temp_N` для временных таблиц).
3. Структура: столбцы `chunk_id` (oid), `chunk_seq` (integer), `chunk_data` (bytea).
4. Имеют индекс для быстрого доступа (например, `pg_toast_16385_index`).

## Сжатие
1. Используются алгоритмы **PGLZ** (по умолчанию) или **LZ4** (более эффективный, с версии 15).
2. Настройка: параметр `default_toast_compression` или `COMPRESSION` в `CREATE TABLE`.

# Процессы и память
## Процессы:
1. **Postmaster** - Главный процесс, запускает и контролирует другие процессы. Перезапускает процессы при сбоях.
2. **Фоновые процессы**:
    - **startup**: восстанавливает данные после сбоев.
    - **autovacuum**: очищает устаревшие версии строк.
    - **wal writer**: записывает журнал предзаписи (WAL).
    - **checkpointer**: создает контрольные точки.
    - **writer**: записывает измененные страницы на диск.
    - **wal sender/receiver**: обеспечивают репликацию.
3. **Backend**: обслуживает клиентские соединения.

## Память:
1. **Общая память** - **Буферный кэш** хранит страницы для ускорения ввода-вывода.
2. **Журнал предзаписи (WAL)**
    1. Гарантирует согласованность данных при сбоях.
    2. Записывает операции перед их применением.
3. Двойное кэширование: PostgreSQL использует кэш операционной системы и собственный буферный кэш.

# Изоляция

## Согласованность

**Согласованность** (consistency) — это корректность данных, обеспечиваемая реляционными СУБД. Она шире, чем **целостность** (integrity), которая поддерживается ограничениями, такими как `NOT NULL`, `UNIQUE`, `CHECK`, `FOREIGN KEY`. Ограничения целостности задаются на уровне базы данных, и СУБД гарантирует их соблюдение. Однако согласованность включает более сложные правила, которые не всегда можно выразить ограничениями (например, правила, охватывающие несколько таблиц). Такие правила контролируются приложением, и СУБД не знает о них.

## Роль СУБД:
Если приложение выполняет корректные операции, СУБД обеспечивает согласованность через **транзакции** — неделимые наборы операций, переводящие базу из одного корректного состояния в другое.

## Проблема конкурентного выполнения:
1. Транзакции, корректные по отдельности, могут вести к некорректным результатам при одновременном (конкурентном) выполнении из-за перемешивания операций.
2. **Аномалии одновременного выполнения** возникают, когда порядок операций разных транзакций нарушает согласованность.
3. СУБД изолирует транзакции, чтобы результат конкурентного выполнения соответствовал какому-либо последовательному выполнению, минимизируя аномалии.

## Уровни изоляции и аномалии в SQL

Стандарт SQL определяет четыре уровня изоляции, различающиеся по допустимым аномалиям:

1. **Read Uncommitted**
2. **Read Committed**
3. **Repeatable Read**
4. **Serializable**

**Аномалии:**
1. **Потерянное обновление** (lost update) - Две транзакции читают одну строку, обновляют её, и вторая перезаписывает изменения первой.
2. **Грязное чтение** (dirty read) - Чтение незафиксированных изменений, которые могут быть отменены.
3. **Неповторяющееся чтение** (non-repeatable read) - Транзакция читает строку дважды, но между чтениями другая транзакция изменяет строку.
4. **Фантомное чтение** (phantom read) - Транзакция читает набор строк по условию дважды, но между чтениями другая транзакция добавляет новые строки.

## Уровни изоляции в PostgreSQL

PostgreSQL использует **изоляцию на основе снимков** (Snapshot Isolation, SI) с многоверсионной моделью (MVCC), где строки хранятся в нескольких версиях. Это отличается от стандартного подхода, основанного на блокировках, и обеспечивает более высокую производительность.


| Уровень изоляции<br> | Реализация                      |
| -------------------- | ------------------------------- |
| Read Committed       | SI перед каждым действием       |
| Repeatable Read      | SI перед началом транзакции     |
| Serializable         | Serializable Snapshot Isolation |

# Страницы и версии строк в PostgreSQL

**Страницы** — минимальные единицы ввода-вывода в PostgreSQL (обычно 8 КБ, задается при сборке параметром `--with-blocksize`).
Каждая страница имеет фиксированную внутреннюю разметку, содержащую:
1. **Заголовок** (в младших адресах).
2. **Массив указателей на версии строк**.
3. **Свободное пространство**.
4. **Версии строк** (данные).
5. **Специальная область** (в старших адресах).

## Заголовок страницы
Расположен в начале страницы, фиксированного размера (обычно 24 байта).
Содержит:
- Контрольную сумму.
- Указатели на начало и конец других областей (`lower`, `upper`, `special`).
- Дополнительные метаданные (например, флаги страницы).
## Специальная область

Расположена в конце страницы (старшие адреса).
Используется для индексов (например, B-дерево хранит метаданные или ссылки на дочерние узлы).
Для таблиц обычно имеет нулевой размер.
Пример: в B-дереве нулевая страница хранит метаданные, а обычные страницы — индексные записи.

## Версии строк
**Версии строк** (row versions, tuples) — это данные таблицы с добавленной служебной информацией. Многоверсионность (MVCC) позволяет хранить несколько версий одной строки для поддержки конкурентного доступа. В отличие от таблиц, индексы не содержат версий строк, а ссылаются на все табличные версии через идентификаторы (`tid`).

### Указатели на версии строк
Массив указателей (line pointers) — это оглавление страницы, расположенное после заголовка.
Каждый указатель (4 байта) содержит:
- Смещение версии строки относительно начала страницы.
- Длину версии строки.
- Статус (например, `normal`, `unused`, `redirect`, `dead`).
Идентификатор версии строки (`tid`) состоит из:
- Номера страницы в файле основного слоя.
- Номера указателя в массиве (не смещения, для избежания фрагментации при перемещении строк).
### Свободное пространство
Расположено между указателями и версиями строк.
Всегда представлено одним непрерывным фрагментом (без фрагментации).
Отслеживается в карте свободного пространства (`_fsm`) для оптимизации вставки данных.
## Структура версий строк
Версия строки состоит из:
- **Заголовка** (минимально 23 байта).
- **Данных** (собственно значения столбцов).
Заголовок содержит:
- `xmin`: номер транзакции, создавшей строку (`INSERT`).
- `xmax`: номер транзакции, удалившей или обновившей строку.
- `infomask`: биты, определяющие свойства версии (например, статус `xmin` и `xmax`).
- `ctid`: ссылка на следующую версию строки (тип `tid`, например, `(0,2)`).
- Битовую карту `NULL`-значений (для столбцов, допускающих `NULL`).
Данные выровнены по границам машинных слов (например, 4 или 8 байт в зависимости от архитектуры).
# Виртуальные транзакции

**Виртуальные номера транзакций** (`virtual xid`) - Используются для читающих транзакций, чтобы экономить реальные номера (`xid`).

# Снимки данных

**Снимок данных** (snapshot) — это согласованное представление данных базы на определенный момент времени, соответствующее свойствам **ACID** (в частности, согласованности и изоляции). Снимок включает только **актуальные версии строк**, зафиксированные к моменту его создания. **Многоверсионность** (MVCC): физически в таблицах могут существовать несколько версий одной строки, но каждая транзакция видит максимум одну из них, определенную снимком. **Изоляция**: каждая транзакция работает со своим снимком, что обеспечивает независимость от других транзакций и согласованность данных на разные моменты времени.

## Создание снимков
- **Read Committed** - Новый снимок создается для каждого оператора в транзакции.
- **Repeatable Read и Serializable** - Один снимок создается в начале **первого оператора** транзакции.
## Видимость версий строк в снимке
Снимок не является физической копией данных, а задается **набором параметров**, определяющих, какие версии строк видны.
Видимость зависит от полей заголовка версии строки:
- `xmin`: номер транзакции, создавшей строку (`INSERT`).
- `xmax`: номер транзакции, удалившей или обновившей строку.
- Информационные биты (`infomask`): статус транзакций (`xmin_committed`, `xmin_aborted`, `xmax_committed`, `xmax_aborted`).
**Правило видимости** (упрощенно): `xmin` < `txid` < `xmax`, и `xmin_committed`

# Горизонт транзакции
**Горизонт транзакции** — это нижняя граница снимка (`xmin`), определяющая самую старую активную транзакцию.
**Горизонт базы данных**: Наименьший `xmin` среди всех активных транзакций в базе.
# Снимок данных для системного каталога
Системный каталог (таблицы в схеме `pg_catalog`) использует **отдельные снимки**, чтобы всегда видеть последние изменения (например, новые столбцы или ограничения). Обычный снимок транзакции может быть устаревшим, что недопустимо для каталога.
Реализация:
- Создается «свежий» снимок для каждого обращения к каталогу.
- Кэширование объектов каталога оптимизирует производительность.
# Внутристраничная очистка и hot-обновления

**Раздувание таблицы (Table Bloat):** "Мертвые" строки занимают место, пока их не уберет `VACUUM`.
**Раздувание индексов (Index Bloat):** Обновление даже одного неиндексированного столбца приводит к созданию новых записей во всех индексах. Это очень дорого.
**Высокие издержки:** Множество операций записи на диск (в таблицу, во все индексы) и в журнал предзаписи (WAL).
## HOT-обновления (Heap-Only Tuple Updates)
Это супероптимизированный `UPDATE`, который позволяет создать новую версию строки на той же странице данных, что и старая, **без необходимости обновлять индексы**.

**Как это работает:**
1. HOT-обновление возможно только тогда, когда:
    - Новая версия строки может поместиться на **той же странице данных**, что и старая.
    - Значения в **индексированных столбцах не изменяются**.
2. **Процесс HOT-обновления:**
    - PostgreSQL создает новую версию строки, как обычно.
    - Он размещает её на **той же самой странице** данных.
    - **Ключевой момент:** Он НЕ обновляет записи в индексах. Индексы по-прежнему указывают на **физическое местоположение старой, "мертвой" строки**.
    - В заголовке старой строки устанавливается специальный флаг, который перенаправляет любой запрос, пришедший по старому адресу, на новую версию строки (которая лежит рядом на той же странице).

## Внутристраничная очистка (In-page cleanup)
**Проблема:** HOT-обновления оставляют на странице "мертвые" версии строк (HOT-tuples). Кто их уберет? Ждать глобальный `VACUUM` для очистки одной страницы — неэффективно.

**Внутристраничная очистка** -Это легковесный, "ленивый" механизм, который удаляет "мертвые" HOT-tuples прямо в момент обращения к странице, не дожидаясь `VACUUM`.
1. **Триггер:** Любая последующая операция (`SELECT`, `INSERT`, `UPDATE`), которая обращается к странице данных, где лежат "мертвые" HOT-tuples.
2. **Проверка:** Прежде чем выполнить свою основную работу, запрос проверяет: "А есть ли на этой странице мертвые HOT-версии, которые уже не видит ни одна активная транзакция?"
3. **Очистка:** Если такие версии найдены, они **немедленно удаляются**, а освободившееся место становится доступным для новых строк на этой же странице.

# Очистка и автоочистка
Из-за MVCC (многоверсионности) операции DELETE и UPDATE не удаляют строки физически, а лишь помечают их как "мертвые" (dead tuples). Это приводит к двум проблемам:
1. **Раздувание (Bloat):** Таблицы и индексы разрастаются, занимая лишнее место и замедляя работу.
2. **Устаревшая статистика:** Планировщик запросов не знает об актуальном состоянии данных и может строить неэффективные планы.
`VACUUM` и `ANALYZE` решают эти проблемы. `AUTOVACUUM` делает это автоматически.

## `VACUUM`: Ручная уборка
Это команда, которую вы можете запустить вручную. Её главная задача — сделать "мертвое" пространство **повторно используемым**. Стандартный `VACUUM` не блокирует таблицу для чтения и записи.

Этапы выполнения `VACUUM`:
1. **Поиск "мертвых" строк:** `VACUUM` последовательно сканирует файл таблицы (heap), находя строки, помеченные как удаленные и уже невидимые для любой активной транзакции.
2. **Очистка индексов:** Для каждой найденной "мертвой" строки `VACUUM` удаляет соответствующие ей указатели из **всех** индексов таблицы. Это критически важно для поддержания производительности и компактности индексов.
3. **Обновление Карты Свободного Пространства (FSM):** Освободившееся место помечается в специальной карте (Free Space Map). Теперь PostgreSQL знает, что сюда можно быстро вставлять новые строки, не ища место по всей таблице.
4. **Обновление Карты Видимости (VM):** Если страница была полностью очищена и все строки на ней "видны всем", она помечается в Карте Видимости (Visibility Map). Это необходимо для сверхбыстрых **Index-Only Scans**.
5. **Защита от зацикливания ID транзакций (TXID Wraparound):** Самая важная, невидимая задача. `VACUUM` "замораживает" ID очень старых транзакций, чтобы после переполнения 32-битного счетчика они не стали ошибочно считаться новыми. Это предотвращает катастрофическую потерю данных.

## `ANALYZE`: Сбор разведданных
`VACUUM` убирает мусор, а `ANALYZE` составляет отчет о том, что осталось.
**Что делает:**
1. Проходит по таблице и собирает статистику о распределении данных в столбцах.
2. Он узнает: количество уникальных значений, самые частые значения, гистограмму распределения, среднюю ширину строк и т.д.
3. Записывает эту информацию в системные таблицы (`pg_statistic`).
## `AUTOVACUUM`: Автоматический уборщик и аналитик
Запускать `VACUUM ANALYZE` вручную утомительно и непрактично. `AUTOVACUUM` — это встроенный фоновый процесс (демон) PostgreSQL, который делает эту работу за вас. Это одна из лучших функций СУБД.
`AUTOVACUUM` не работает по расписанию. Он срабатывает на основе **пороговых значений**, которые рассчитываются для каждой таблицы индивидуально.
1. **Триггер для `AUTOVACUUM` (очистки):** Процесс запускается для таблицы, если количество "мертвых" строк в ней превышает: `autovacuum_vacuum_threshold + (autovacuum_vacuum_scale_factor * количество_строк_в_таблице)`
    - `autovacuum_vacuum_threshold` (по умолчанию `50`) — минимальное количество мертвых строк.
    - `autovacuum_vacuum_scale_factor` (по умолчанию `0.2` или 20%) — процент от размера таблицы.
2. **Триггер для `AUTOANALYZE` (анализа):** Логика та же, но с другими параметрами. Запускается, если количество измененных (`INSERT`, `UPDATE`, `DELETE`) строк превышает: `autovacuum_analyze_threshold + (autovacuum_analyze_scale_factor * количество_строк_в_таблице)`

# Заморозка
**Заморозка**- Это превентивный механизм, который защищает базу данных от катастрофической потери данных из-за исчерпания и "зацикливания" идентификаторов транзакций (TXID)`FrozenTransactionId`.
- **Каждая транзакция имеет номер:** Когда вы делаете `INSERT`, `UPDATE` или `DELETE`, эта операция выполняется внутри транзакции, которой присваивается уникальный номер — **Transaction ID (TXID)**.
- **Счетчик не бесконечен:** TXID — это 32-битное число. Это значит, что существует всего около 4 миллиардов уникальных номеров. В активно используемой базе этот счетчик может "обнулиться" (пройти полный круг) за несколько недель или месяцев.
- **MVCC и сравнение:** Механизм многоверсионности (MVCC) работает, сравнивая TXID текущей транзакции с TXID, записанными в строках (`xmin` - кем создана, `xmax` - кем удалена). Логика сравнения хитрая: она понимает, что TXID 10 "новее", чем TXID 4,000,000,000, если счетчик только что "зациклился".
`FrozenTransactionId` - Эта строка настолько стара, что она гарантированно была создана до начала любой возможной активной транзакции в этой базе данных. **Считай её видимой всегда и для всех**, не утруждай себя сравнением TXID.

## `VACUUM`
1. При своем обычном сканировании таблицы `VACUUM` проверяет не только "мертвые" строки, но и возраст "живых".
2. Для каждой "живой" строки он вычисляет её возраст (`age`): `текущий_TXID - TXID_создания_строки`.
3. Если возраст строки превышает определенный порог (`vacuum_freeze_min_age`, по умолчанию 150 млн транзакций), `VACUUM` **перезаписывает эту строку**, заменяя её `xmin` на `FrozenTransactionId`.

### Защитные механизмы: `AUTOVACUUM` как страж
1. **Агрессивный Autovacuum (`autovacuum_freeze_max_age`):**
    - PostgreSQL постоянно отслеживает возраст самой старой, еще не замороженной транзакции во всей базе данных.
    - Если этот возраст превышает порог `autovacuum_freeze_max_age` (по умолчанию 200 млн), PostgreSQL принудительно запускает **агрессивный `AUTOVACUUM`** на таблице, содержащей эту старую строку. Этот `AUTOVACUUM` будет более настойчивым и менее "вежливым", чем обычный.
2. **Аварийная остановка (`vacuum_failsafe_age`):**
    - Если по какой-то причине (например, `AUTOVACUUM` отключен или не справляется) возраст транзакции достигнет критического порога `vacuum_failsafe_age` (по умолчанию 2.1 млрд), PostgreSQL примет экстренные меры.
    - Он **запретит запуск новых транзакций и, в конечном итоге, остановит работу базы данных**, чтобы предотвратить потерю данных. В логах появится страшное сообщение `WARNING: database is approaching transaction ID wraparound limit`. Этого нужно избегать любой ценой.

# Буферный кеш
Кеширование компенсирует разницу в производительности между быстрой (дорогой, малой по объему) и медленной (дешевой, большой по объему) памятью. Активные ("горячие") данные хранятся в кеше, минимизируя обращения к медленной памяти. Буферный кеш PostgreSQL хранит страницы отношений, сглаживая разницу во времени доступа: оперативная память — наносекунды, диски — миллисекунды. PostgreSQL использует буферизованные операции ввода-вывода через кеш ОС, а не прямой ввод-вывод, что упрощает код, но исключает прямое управление записью и предвыборкой. Прямой ввод-вывод использует DMA, избегая копирования через кеш ОС, но требует асинхронного ввода-вывода и учета различий в ОС. Работа над этим ведется (параметр `debug_io_direct`).

Буферный кеш — массив буферов в общей памяти, доступный всем процессам. Каждый буфер содержит страницу данных (8 КБ) и заголовок:
- Физическое расположение (файл, слой, номер блока).
- Флаг "грязной" страницы (`isdirty`) — требует записи на диск.
- Счетчик обращений (`usage count`) — число использований.
- Счетчик закреплений (`pin count`) — число процессов, удерживающих буфер.
Процесс запрашивает страницу у менеджера буферов, получает номер буфера, закрепляет его для работы, избегая замены. Изменения происходят в кеше без немедленного ввода-вывода. Расширение `pg_buffercache` позволяет анализировать кеш.

Менеджер ищет страницу в хеш-таблице (`buf_table.c`) по ключу: идентификатор файла, слой, номер страницы. Хеш-таблица динамически расширяется, коллизии разрешаются цепочками (`dynahash.c`). При нахождении буфер закрепляется, `usagecount` увеличивается, работа идет без ввода-вывода. Закрепление предотвращает замену страницы, но допускает обновления строк. Закрепленные буферы могут блокировать операции, например, `VACUUM`. Хеш-таблица неэффективна для операций `DROP` или `TRUNCATE`.

Если страница отсутствует, выбирается новый буфер:
1. **Свободные буферы**: при старте кеш содержит пустые буферы в списке (`freelist.c`). Первый свободный используется.
2. **Занятые буферы**: при их отсутствии применяется алгоритм "часовой стрелки" (`clock sweep`):
    - Уменьшает `usagecount` буферов.
    - Выбирает незакрепленный буфер с `usagecount=0`.
    - Грязные страницы записываются на диск перед вытеснением.
    - Максимальный `usagecount=5`.

Новая страница читается через буферизованный ввод-вывод, добавляется в хеш-таблицу, `usagecount=1`. Кеш ОС может смягчить промахи. Статистика доступна через `pg_statio_all_tables`.

Массовые операции используют буферные кольца, ограничивающие вытеснение внутри кольца (`GetBufferFromRing`). Стратегии:

- **bulkread**: для таблиц >1/4 кеша, кольцо 256 КБ (32 страницы), грязные буферы заменяются без записи.
- **bulkwrite**: для `COPY`, `CREATE TABLE AS`, кольцо до 16 МБ (2048 страниц, ?1/8 кеша).
- **vacuum**: для очистки/анализа, размер кольца — `vacuum_buffer_usage_limit`.

Кольца не всегда эффективны, например, при массовых `UPDATE`/`DELETE` или доступе к TOAST-таблицам по индексу. Статистика в `pg_stat_io` показывает операции по стратегиям.
# Журнал предзаписи

Журнал предзаписи (WAL, write-ahead log) обеспечивает согласованность данных после сбоев (например, отключения питания или отказа СУБД/ОС), когда содержимое оперативной памяти теряется. Данные на диске рассогласованы, так как страницы записываются отложенно. WAL фиксирует каждое действие (например, изменение страницы в буферном кеше) в виде журнальной записи, которая сохраняется на диск до записи измененной страницы. Это позволяет восстановить пропавшие изменения после сбоя. Журналирование эффективнее записи отдельных страниц, так как записи небольшие и пишутся последовательно. Журналируются:
- Изменения страниц в буферном кеше.
- Фиксация/отмена транзакций (в буферах clog).
- Файловые операции (создание/удаление файлов).

Не журналируются:
- Операции с нежурналируемыми (`UNLOGGED`) таблицами и последовательностями.
- Операции с временными таблицами и последовательностями.

WAL используется для восстановления после сбоя, восстановления из резервной копии и репликации.


## Контрольная точка
Контрольная точка определяет момент, с которого начинается восстановление, позволяя удалять старые записи WAL. Процесс `checkpointer` выполняет контрольную точку:

- **Начало**: сбрасываются небольшие структуры (clog, вложенные транзакции).
- **Выполнение**: помечаются грязные буферы, постепенно записываются на диск по порядку номеров для последовательной записи. Чередуется запись в разные табличные пространства. Другие процессы могут сбрасывать помеченные буферы.
- **Завершение**: создается запись WAL о завершении, обновляется `PGDATA/global/pg_control` с LSN начала точки. Старые записи WAL становятся ненужными.

## Восстановление
При старте процесс `postmaster` запускает `startup`, который проверяет статус кластера в `pg_control` ("in production" указывает на сбой). Восстановление начинается с LSN последней контрольной точки (или из `backup_label` при восстановлении из копии). Записи WAL применяются к страницам в буферном кеше, если LSN страницы меньше LSN записи. Полные образы страниц (FPI) и изменения статуса транзакций идемпотентны. После восстановления нежурналируемые отношения перезаписываются, выполняется контрольная точка. PostgreSQL не требует отката транзакций — незавершенные считаются оборванными.

## Фоновая запись
Процесс `bgwriter` асинхронно сбрасывает грязные буферы, снижая нагрузку на обслуживающие процессы. Использует алгоритм "часовой стрелки", но не уменьшает `usagecount` и сбрасывает незакрепленные буферы с нулевым `usagecount`. Это увеличивает вероятность, что вытесняемые буферы не будут грязными.
## Уровни журнала

**Minimal**:
- Только восстановление после сбоя. Не журналирует `CREATE TABLE AS`, `TRUNCATE` (> `wal_skip_threshold`).
- Требует `max_wal_senders = 0`. Для систем без репликации.

**Replica**:
- Для физической репликации и PITR. Добавляет `LOCK`, `RUNNING_XACTS`.
- По умолчанию с версии 10. Для большинства систем.

**Logical**:
- Для логической репликации. Добавляет записи для декодирования каталога.
- Используйте только при необходимости.

# Блокировки
Представьте, что несколько человек пытаются одновременно отредактировать один и тот же документ. Если не будет правил, кто и когда может вносить правки, получится полная неразбериха. В мире баз данных эту проблему решают **блокировки** (locks).

Это механизм, который упорядочивает доступ к общим ресурсам, когда несколько процессов или потоков хотят с ними поработать. Неважно, работают ли они по-настоящему параллельно на разных ядрах процессора или поочередно в режиме разделения времени — как только появляется конкуренция за ресурс, нужны блокировки. Если же ресурс у каждого свой (например, локальный кеш процесса), то и делить нечего, а значит, блокировки не требуются.

Правило простое: хочешь поработить с ресурсом — сначала **захвати** (acquire) для него блокировку. Закончил — **освободи** (release), чтобы другие тоже могли им воспользоваться. В СУБД вроде PostgreSQL этот процесс в основном автоматизирован. Система сама следит за порядком. Но если вы решите управлять блокировками из своего приложения, вся ответственность ложится на ваши плечи.

## Как это работает «под капотом»?
Если копнуть глубже, блокировка — это просто кусочек **общей памяти**, где хранится её статус (свободна/занята) и, возможно, какая-то дополнительная информация: кто её захватил, когда и т.д. Но ведь и сама эта ячейка памяти — общий ресурс! Доступ к ней тоже нужно регулировать. Для этого используются **примитивы синхронизации** операционной системы:

- **Семафоры** — чтобы ограничить число одновременных пользователей ресурса.
- **Мьютексы** — чтобы гарантировать, что в один момент времени с ресурсом работает только один процесс.

А они, в свою очередь, построены на **атомарных инструкциях процессора** (типа `Test-and-set` или `Compare-and-swap`), которые выполняются как одна неделимая операция. Это и есть самый нижний уровень, гарантирующий порядок и отсутствие хаоса.

Блокировать можно что угодно, лишь бы это «что-то» можно было однозначно опознать:

- **Объекты базы данных**: таблица, страница данных, конкретная строка.
- **Структуры в памяти**: хеш-таблица или буфер.
- **Абстрактные сущности**: иногда блокировки нужны просто для координации процессов, а не для защиты конкретного объекта.

Если вы пытаетесь захватить блокировку, а она уже занята, придётся подождать. Процесс либо встаёт в **очередь ожидания**, либо раз за разом пытается снова захватить ресурс. В любом случае, это простой, который влияет на производительность.

## Ключевые моменты, которые нужно понимать
1. **Гранулярность блокировки** Это, по сути, «масштаб» блокировки.
    - **Крупная** (например, блокировка всей таблицы): легко управлять, но страдает параллельность. Вы блокируете всю таблицу, даже если хотели изменить всего одну строку, мешая другим работать с остальными данными.
    - **Мелкая** (например, блокировка одной строки): отлично для параллельной работы, но создаёт кучу самих блокировок, что отъедает память и усложняет управление.
    - **Эскалация блокировок**: умный компромисс. Если система видит, что вы наставили слишком много мелких блокировок (например, на тысячи строк в одной таблице), она может заменить их все одной крупной — на всю таблицу. Это экономит ресурсы, но ценой снижения параллелизма.
2. **Режимы блокировки** Определяют, какие операции можно выполнять одновременно.
    - **Исключительный (exclusive)**: монопольный режим. Никто другой не может получить доступ. Нужен для изменения данных.
    - **Разделяемый (shared)**: режим «для чтения». Несколько процессов могут одновременно получить такую блокировку и читать данные. В PostgreSQL режимов гораздо больше, и их совместимость определяется **матрицей конфликтов**. Чем больше совместимых режимов, тем шустрее система работает под нагрузкой.

## Какие блокировки бывают в PostgreSQL?
Условно их можно поделить на два типа по времени жизни:
- **Длительные блокировки**: Живут долго, обычно до конца транзакции. Применяются к объектам вроде таблиц и строк. У них сложная инфраструктура с очередями ожидания и поиском взаимных блокировок (deadlocks), потому что ожидание здесь — норма.
- **Короткие блокировки**: Живут доли секунды. Нужны для защиты структур в оперативной памяти (например, буферного кеша). У них всё просто: минимум режимов, никакой сложной логики, ведь главное — скорость.
## Тяжёлые блокировки (Heavyweight Locks)
Это длительные блокировки, которые вешаются на объекты БД: таблицы, индексы, последовательности и т.д. Они нужны, чтобы защитить структуру объектов от одновременных изменений (`TRUNCATE`, `VACUUM FULL`) или скоординировать другие операции.

Хранятся они в **общей памяти сервера**, и их можно посмотреть через представление `pg_locks`. Их общее количество ограничено настройками `max_locks_per_transaction` и `max_connections`. Пул блокировок общий, так что если одна транзакция не жадничает, другая может взять больше своего лимита.

Если ресурс занят в несовместимом режиме, процесс не тратит процессорное время впустую, а засыпает в **очереди ожидания**. Как только ресурс освободится, система его разбудит.

Иногда случаются **взаимоблокировки (deadlocks)** — это когда две транзакции ждут друг друга по кругу (А ждёт ресурс Б, а Б ждёт ресурс А). PostgreSQL умеет находить такие ситуации и автоматически «убивает» одну из транзакций, чтобы остальные могли продолжить работу.

## Блокировки отношений (таблиц, индексов и т.д.)
Для таблиц и индексов в PostgreSQL существует аж **восемь режимов** блокировок. Такое разнообразие позволяет максимально распараллелить работу. Вот основные идеи:
- `Access Share`: самая слабая, для простого чтения (`SELECT`). Совместима почти со всем.
- `Row Exclusive`: нужна для изменения данных (`INSERT`, `UPDATE`, `DELETE`). Конфликтует с другими режимами, которые тоже хотят что-то менять.
- `Share`: нужна для операций типа `CREATE INDEX`. Позволяет другим читать данные, но не менять их.
- `Access Exclusive`: самая сильная. Несовместима ни с чем. Используется для серьезных структурных изменений, вроде `DROP TABLE`.

Чем больше режимов и чем тоньше их настройка, тем меньше процессы мешают друг другу.

## Очередь ожидания
PostgreSQL реализует **честную очередь**: кто раньше пришёл, тот первым и получит доступ. Процесс встаёт в очередь, если запрашиваемый им режим несовместим не только с текущим захваченным режимом, но и с теми, что уже запрошены другими процессами в очереди.

Это важный момент: даже если вы запрашиваете совместимую блокировку, вам придётся подождать, если перед вами в очереди стоит кто-то с несовместимым запросом. Это предотвращает ситуацию, когда «тяжёлые» операции могут ждать вечно, пока мимо них пролетают «лёгкие».

Когда транзакция завершается (коммитом или откатом), все её блокировки снимаются, и первый процесс из очереди получает свой доступ.

---

## Блокировки строк: особый случай
Блокировать строки так же, как и таблицы («тяжёлыми» блокировками), было бы слишком накладно. Каждая такая блокировка — это сотни байт в общей памяти. На таблице с миллионами строк память бы кончилась очень быстро.

### Как поступает PostgreSQL?
Он идёт на хитрость. Вместо того чтобы хранить информацию о блокировке строк в отдельном месте, он записывает её **прямо в заголовок самой версии строки** на странице данных.

Когда транзакция обновляет или удаляет строку, она не ставит полноценную блокировку. Она просто помечает старую версию строки как «неактуальную» и записывает в её служебное поле `xmax` номер своей транзакции. Другая транзакция, увидев это, понимает: «Ага, с этой строкой сейчас работает другая транзакция, надо подождать её завершения».

### Режимы блокировки строк
- **Update**: для изменения строки или её удаления.
- **No Key Update**: для изменения полей, которые не являются частью уникального ключа. PostgreSQL умён и использует этот более «лёгкий» режим, когда это возможно, чтобы уменьшить конфликты.
- **Share**: защищает строку от любых изменений, но позволяет её читать.
- **Key Share**: используется для проверки внешних ключей. Защищает только ключевые поля, но позволяет менять остальные. Это позволяет одновременно обновлять неключевые поля и проверять ссылочную целостность.

### Очередь ожидания за строкой: как она устроена?

Хорошо, мы поняли, что процесс ждёт завершения другой транзакции. Но как это ожидание организовано? Ведь простого списка «кто за кем» для строк нет.

PostgreSQL использует хитрую комбинацию: чтобы организовать очередь за «лёгкой» блокировкой строки, он использует «тяжёлые» блокировки! Вот как это работает:

1. Транзакция видит, что строка заблокирована другой транзакцией (смотрит на `xmax`).
2. Чтобы «встать в очередь», она сначала пытается захватить специальную **тяжёлую блокировку на саму версию строки** (`tuple lock`). Это как взять талончик в электронной очереди.
3. Захватив талончик, она засыпает, ожидая завершения транзакции-блокировщика (через блокировку её `transactionid`).

Эта блокировка на версию строки (`tuple lock`) нужна, чтобы не началась «гонка», когда первая транзакция-блокировщик завершится. Без неё все ожидающие процессы проснулись бы одновременно и бросились обновлять строку. А так — только тот, кто первым взял `tuple lock`.

Но есть нюанс. Эта идеальная очередь работает до тех пор, пока не завершится _первая_ блокирующая транзакция. После того как она освободит строку и первый «очередник» её обработает, строгая очередь может нарушиться. Следующие ожидающие транзакции могут начать «гонку» за строкой между собой.

**Вывод:** очередь ожидания за строкой работает надёжно, но при высокой конкуренции за одну и ту же «горячую» строку могут начаться проблемы с производительностью. Лучше избегать сценариев, где десятки транзакций одновременно пытаются обновить одну и ту же запись.

### Как не ждать блокировку?
Иногда лучше получить ошибку, чем висеть в ожидании. Для этого есть несколько инструментов:

1. **`NOWAIT`**: в команде `SELECT ... FOR UPDATE` можно добавить `NOWAIT`. Если строка заблокирована, команда не будет ждать, а сразу же вернёт ошибку.
2. **`SKIP LOCKED`**: тоже для `SELECT ... FOR UPDATE`. Если строка заблокирована, она будет просто пропущена. Идеально для реализации очередей задач, когда несколько воркеров разбирают задачи из одной таблицы.
3. **`lock_timeout`**: можно установить максимальное время ожидания блокировки (`SET lock_timeout = '1s'`). Если за это время блокировка не будет получена, команда завершится с ошибкой.

## Быстрые блокировки в памяти

Помимо «тяжёлых» блокировок, о которых мы говорили, есть и «лёгкие», которые защищают структуры данных в общей памяти сервера. Они живут очень недолго и для пользователя почти незаметны.

- **Спин-блокировки (spinlocks)**: самый простой и быстрый вид. Если блокировка занята, процесс не засыпает, а крутится в цикле (`spin`), постоянно проверяя, не освободилась ли она. Это эффективно, если ожидание очень короткое.
- **Лёгкие блокировки (lwlocks)**: чуть более сложный механизм. У них есть два режима (разделяемый и исключительный) и даже простая очередь ожидания. Они используются для защиты буферов, хеш-таблиц и других внутренних структур на время чуть более долгих операций.

Эти блокировки — внутренняя кухня PostgreSQL. Разработчикам приложений не нужно ими управлять, но полезно знать об их существовании, чтобы понимать, откуда могут браться задержки на низком уровне.

# Этапы выполнения запросов

![[Pasted image 20250903215917.png]]
## Этап 1: Парсинг (Parsing / Синтаксический анализ)
Проверка синтаксической корректности SQL-запроса, без понимания его смысла.
**Результат этапа:** **Дерево разбора (Parse Tree).** Это иерархическая структура, которая просто представляет синтаксис вашего запроса. На этом этапе PostgreSQL еще не знает, существует ли таблица `users` или столбец `id`.
## Этап 2: Анализ и Переписывание (Analysis & Rewrite)
Проверка смысловой корректности запроса и его преобразование в стандартную внутреннюю форму.
**Результат этапа:** **Дерево запроса (Query Tree).** Это детальное, семантически проверенное представление того, **ЧТО** нужно сделать. Оно содержит всю информацию об объектах, операциях и условиях.
## Этап 3: Планирование и Оптимизация (Planning & Optimization)
Найти самый дешевый способ выполнить запрос. Это "мозг" всей системы.

**Что происходит:**
1. **Генерация планов:** Планировщик берет Дерево запроса и генерирует множество **возможных планов выполнения**. Например, для соединения двух таблиц он рассмотрит `Nested Loop`, `Hash Join` и `Merge Join`. Для фильтрации он рассмотрит `Seq Scan` и различные виды `Index Scan`.
2. **Оценка стоимости:** Для **каждого** сгенерированного плана планировщик рассчитывает его **оценочную стоимость**. Он использует статистику, собранную командой `ANALYZE` (размер таблиц, распределение данных в столбцах, наличие индексов), чтобы предсказать, сколько операций чтения с диска и процессорного времени потребует каждый шаг плана.
3. **Выбор лучшего плана:** Выбирается план с **наименьшей итоговой стоимостью**.
**Результат этапа:** **План выполнения (Execution Plan).** Это пошаговая инструкция для исполнителя, как именно, в каком порядке и какими методами получить данные. Это именно то, что вы видите в выводе `EXPLAIN`.
## Этап 4: Исполнение (Execution)
Механическое выполнение инструкций из плана.
**Результат этапа:** **Набор строк (Result Set),** который отправляется клиенту.

# Статистика
**Статистика** — это метаданные о содержимом базы данных, которые PostgreSQL использует для оценки характеристик данных

Статистика в PostgreSQL собирается с помощью команды `ANALYZE` или автоматически процессом **autovacuum**.
**Что собирается**:
- Количество строк (`pg_class.reltuples`).
- Размер таблицы (`pg_class.relpages`).
- Гистограммы распределения значений для столбцов.
- Наиболее частые значения (MCV, Most Common Values) и их частоты.
- Количество уникальных значений (`n_distinct`).
- Корреляция между физическим порядком строк и значениями столбца (для оценки эффективности индексов).

## Autovacuum и статистика
Процесс `autovacuum` автоматически запускает `ANALYZE` для таблиц, в которых произошли значительные изменения (например, после множества `INSERT`, `UPDATE`, `DELETE`).
Порог для запуска определяется параметрами:
- `autovacuum_analyze_scale_factor`: Доля изменённых строк (по умолчанию 0.1, т.е. 10%).
- `autovacuum_analyze_threshold`: Минимальное количество изменённых строк (по умолчанию 50).

Статистика сохраняется в системных каталогах:
- **`pg_statistic`**: Основной каталог, содержащий детализированные данные о распределении значений, гистограммах и MCV. Доступен только суперпользователям.
- **`pg_stats`**: Представление, упрощающее доступ к статистике для обычных пользователей. Содержит человеко-читаемые данные

## Как используется статистика?
Оптимизатор запросов PostgreSQL (query planner) использует статистику для:
1. **Оценки стоимости запроса**:
    - Выбор между последовательным сканированием (`Seq Scan`), индексным сканированием (`Index Scan`) или другими методами.
    - Оценка количества строк, которые вернёт запрос (селективность).
2. **Выбора алгоритма соединения**:
    - Например, если статистика показывает, что в таблице мало уникальных значений, оптимизатор может выбрать Hash Join вместо Nested Loop.
3. **Оптимизации условий**:
    - Для условий в `WHERE` или `JOIN` статистика помогает оценить, сколько строк будет отфильтровано.
    - Например, для `WHERE age > 30` гистограмма значений столбца `age` покажет, сколько строк удовлетворяет условию.
# Табличные методы доступа

## Последовательное сканирование (Sequential Scan / Seq Scan)
**Суть в одном предложении:** Это самый простой и прямолинейный способ прочитать таблицу — от самого первого байта до самого последнего, строка за строкой.
## Параллельное последовательное сканирование (Parallel Sequential Scan)
**Суть в одном предложении:** Разделение работы по чтению одной большой таблицы между несколькими рабочими процессами для ускорения выполнения.
## Index Scan (Классическое индексное сканирование)
**Суть в одном предложении:** Поочередная работа: найти одну запись в индексе, затем найти соответствующую ей строку в таблице, и так для каждого совпадения.
## Index-Only Scan (Сканирование только по индексу)
**Суть в одном предложении:** Получить все необходимые данные напрямую из индекса, полностью игнорируя основную таблицу.

## Bitmap Index Scan (Сканирование по битовой карте)
**Суть в одном предложении:** Двухэтапная стратегия: сначала составить в памяти "карту" всех нужных строк, а затем за один последовательный проход собрать их из таблицы.

# Способы соединений (алгоритмы в PostgreSQL)

## Nested Loop Join (Соединение вложенными циклами)
**Суть в одном предложении:** Самый простой и интуитивный способ, похожий на два вложенных цикла `for` в программировании.
## Hash Join (Соединение через хэш-таблицу)
**Суть в одном предложении:** Создание в памяти "картотеки" (хэш-таблицы) для одной таблицы, чтобы потом быстро находить в ней записи из второй таблицы.

## Merge Join (Соединение слиянием)
**Суть в одном предложении:** Эффективное слияние двух **уже отсортированных** списков (таблиц).

## Сводка и как на это влиять

|Способ|Принцип работы|Сильные стороны|Слабые стороны|Главный сценарий использования|
|:--|:--|:--|:--|:--|
|**Nested Loop**|Цикл в цикле|Быстрый старт (для `LIMIT`), идеален с индексом на внутренней таблице.|Катастрофически медленный без индекса на больших таблицах (O(N*M)).|Одна из таблиц очень маленькая.|
|**Hash Join**|Хэш-таблица в памяти|Очень быстрый для больших объемов, не требует сортировки.|Требует много памяти (`work_mem`), медленный старт, только для `=`.|Соединение больших таблиц по равенству.|
|**Merge Join**|Слияние 2-х отсортированных наборов|Экономичен по памяти, работает с очень большими данными, поддерживает `>` и `<`.|Требует предварительной сортировки, которая может быть дорогой.|Соединение гигантских таблиц или данных, уже отсортированных по индексу.|