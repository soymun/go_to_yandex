# SQL

SQL, Structured query language («язык структурированных запросов») — формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД). SQL основывается на исчислении кортежей. Стандарт SQL определяется с помощью кода ANSI.
# Временная таблица

Временная таблица - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. Используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или как замена курсоров и параметризованных представлений.

# Представление (view)

Представление, View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом. В действительности представление - всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.
#  Материализованное представление

**Материализо́ванное представле́ние** — физический объект базы данных, содержащий результат выполнения запроса.

Материализованные представления позволяют многократно ускорить выполнение запросов, обращающихся к большому количеству (сотням тысяч или миллионам) записей, позволяя за секунды (и даже доли секунд) выполнять запросы к терабайтам данных. Это достигается за счет прозрачного использования заранее вычисленных итоговых данных и результатов соединений таблиц. Предварительно вычисленные итоговые данные обычно имеют очень небольшой объем по сравнению с исходными данными.

# Индекс

Индекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности поиска данных. Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путем последовательного просмотра таблицы строка за строкой может занимать много времени. Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева. Индекс можно создать либо с помощью выражения CREATE INDEX: CREATE INDEX index_name ON table_name (column_name) либо указав ограничение целостности в виде уникального UNIQUE или первичного PRIMARY ключа в операторе создания таблицы CREATE TABLE.

# Хранимая процедура

Хранимая процедура — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения. Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.

# Триггер

Триггер (trigger) — это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции. Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события). В случае, если триггер вызывается до события, он может внести изменения в модифицируемую событием запись. Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). В этом случае с их помощью реализуется механизм «обновляемого представления». В этом случае ключевые слова BEFORE и AFTER влияют лишь на последовательность вызова триггеров, так как собственно событие (удаление, вставка или обновление) не происходит.

# Курсор

Курсор — это объект базы данных, который позволяет приложениям работать с записями «по-одной», а не сразу с множеством, как это делается в обычных SQL командах. Порядок работы с курсором такой: Определить курсор (DECLARE) Открыть курсор (OPEN) Получить запись из курсора (FETCH) Обработать запись... Закрыть курсор (CLOSE) Удалить ссылку курсора (DEALLOCATE). Когда удаляется последняя ссылка курсора, SQL освобождает структуры данных, составляющие курсор.
# Операторы SQL

- операторы определения данных (Data Definition Language, DDL): CREATE создает объект БД (базу, таблицу, представление, пользователя и т. д.), ALTER изменяет объект, DROP удаляет объект;
- операторы манипуляции данными (Data Manipulation Language, DML): SELECT выбирает данные, удовлетворяющие заданным условиям, INSERT добавляет новые данные, UPDATE изменяет существующие данные, DELETE удаляет данные;
- операторы определения доступа к данным (Data Control Language, DCL): GRANT предоставляет пользователю (группе) разрешения на определенные операции с объектом, REVOKE отзывает ранее выданные разрешения, DENY задает запрет, имеющий приоритет над разрешением;
- операторы управления транзакциями (Transaction Control Language, TCL): COMMIT применяет транзакцию, ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции, SAVEPOINT разбивает транзакцию на более мелкие.

# SELECT

SELECT - оператор DML SQL, возвращающий набор данных (выборку) из базы данных, удовлетворяющих заданному условию. Имеет следующую структуру: 
SELECT (DISTINCT | DISTINCTROW | ALL) select_expression,... 
FROM table_references 
WHERE where_definition
GROUP BY {unsigned_integer | column | formula}
HAVING where_definition
ORDER BY {unsigned_integer | column | formula} (ASC | DESC), ...

## Join
JOIN - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. Особенностями операции соединения являются следующее: в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов; каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда; при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

SELECT field_name [,... n] FROM Table1 {INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN Table2 {ON | USING (field_name [,... n])}

1. (INNER) JOIN Результатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным. 
2. LEFT (OUTER) JOIN Производит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (NULL). Порядок таблиц для оператора важен, поскольку оператор не является симметричным. 
3. RIGHT (OUTER) JOIN LEFT JOIN с операндами, расставленными в обратном порядке. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.
4. FULL (OUTER) JOIN Результатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным. 
5. CROSS JOIN (декартово произведение) При выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.

Что лучше использовать JOIN или подзапросы?

Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы. Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.


# Блокировки в SQL

### FOR UPDATE

Указание `FOR UPDATE` вызывает блокировку строк, полученных оператором `SELECT`, как для обновления. Это не позволяет другим транзакциям блокировать, изменять или удалять их до завершения текущей транзакции. То есть, другие транзакции, которые попытаются выполнить `UPDATE`, `DELETE`, `SELECT FOR UPDATE`, `SELECT FOR NO KEY UPDATE`, `SELECT FOR SHARE` или `SELECT FOR KEY SHARE` для этих строк, будут заблокированы до завершения текущей транзакции; и наоборот, `SELECT FOR UPDATE` будет ожидать завершения параллельной транзакции, выполнившей любую из этих команд для той же строки, а затем заблокирует и вернёт обновлённую строку (или не вернёт ничего, если строка была удалена). Однако в транзакции с уровнем изоляции `REPEATABLE READ` или `SERIALIZABLE` будет выдана ошибка, если строка, подлежащая блокировке, изменилась с момента начала транзакции. Более подробное обсуждение см. в Разделе 13.4.

Режим блокировки `FOR UPDATE` также устанавливается любой командой `DELETE` для строки, а также командой `UPDATE`, которая изменяет значения определённых столбцов. В настоящее время для `UPDATE` рассматриваются столбцы, имеющие уникальный индекс, который может быть использован во внешнем ключе (таким образом, частичные индексы и индексы по выражениям не учитываются), но это может измениться в будущем.

### FOR NO KEY UPDATE

Ведёт себя аналогично `FOR UPDATE`, за исключением того, что устанавливаемая блокировка слабее: эта блокировка не будет блокировать команды `SELECT FOR KEY SHARE`, которые пытаются установить блокировку на те же строки. Этот режим блокировки также устанавливается любой командой `UPDATE`, которая не устанавливает блокировку `FOR UPDATE`.

### FOR SHARE

Ведёт себя аналогично `FOR NO KEY UPDATE`, за исключением того, что она устанавливает разделяемую (shared), а не исключительную (exclusive) блокировку на каждую полученную строку. Разделяемая блокировка блокирует другие транзакции от выполнения `UPDATE`, `DELETE`, `SELECT FOR UPDATE` или `SELECT FOR NO KEY UPDATE` для этих строк, но не мешает им выполнять `SELECT FOR SHARE` или `SELECT FOR KEY SHARE`.

### FOR KEY SHARE

Ведёт себя аналогично `FOR SHARE`, за исключением того, что блокировка слабее: `SELECT FOR UPDATE` блокируется, а `SELECT FOR NO KEY UPDATE` — нет. Разделяемая блокировка ключа (key-shared) блокирует другие транзакции от выполнения `DELETE` или любого `UPDATE`, изменяющего значения ключа, но не другие `UPDATE`. Также она не препятствует выполнению `SELECT FOR NO KEY UPDATE`, `SELECT FOR SHARE` или `SELECT FOR KEY SHARE`.

### Обработка блокировок

| Опция              | Поведение при обнаружении заблокированной строки        | Типичный сценарий использования                                                    |
| ------------------ | ------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| **(По умолчанию)** | Ожидать снятия блокировки                               | Стандартные операции, где ожидание допустимо.                                      |
| `SKIP LOCKED`      | Пропустить заблокированную строку и перейти к следующей | Реализация очередей задач, параллельная обработка данных.                          |
| `NOWAIT`           | Немедленно вернуть ошибку                               | Интерактивные системы, где долгое ожидание недопустимо и лучше сообщить об ошибке. |

# Основные агрегатные функции

Агрегатных функции - функции, которые берут группы значений и сводят их к одиночному значению. SQL предоставляет несколько агрегатных функций: COUNT - производит подсчет записей, удовлетворяющих условию запроса; SUM - вычисляет арифметическую сумму всех значений колонки; AVG - вычисляет среднее арифметическое всех значений; MAX - определяет наибольшее из всех выбранных значений; MIN - определяет наименьшее из всех выбранных значений.

# EXISTS

EXISTS берет подзапрос, как аргумент, и оценивает его как TRUE, если подзапрос возвращает какие-либо записи и FALSE, если нет.

# IN, BETWEEN, LIKE

IN - определяет набор значений. SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel'); BETWEEN определяет диапазон значений. В отличие от IN, BETWEEN чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку. SELECT * FROM Persons WHERE age BETWEEN 20 AND 25; LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки. В качестве условия используются символы шаблонизации (wildkards) - специальные символы, которые могут соответствовать чему-нибудь: _ замещает любой одиночный символ. Например, 'b_t' будет соответствовать словам 'bat' или 'bit', но не будет соответствовать 'brat'. % замещает последовательность любого числа символов. Например '%p%t' будет соответствовать словам 'put', 'posit', или 'opt', но не 'spite'. SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';

# Insert

INSERT — создать новые строки в таблице
```sql
[ WITH [ RECURSIVE ] _`with_query`_ [, ...] ]
INSERT INTO _`table_name`_ [ AS _`alias`_ ] [ ( _`column_name`_ [, ...] ) ]
    [ OVERRIDING { SYSTEM | USER } VALUE ]
    { DEFAULT VALUES | VALUES ( { _`expression`_ | DEFAULT } [, ...] ) [, ...] | _`query`_ }
    [ ON CONFLICT [ _`conflict_target`_ ] _`conflict_action`_ ]
    [ RETURNING { * | _`output_expression`_ [ [ AS ] _`output_name`_ ] } [, ...] ]

where _`conflict_target`_ can be one of:

    ( { _`index_column_name`_ | ( _`index_expression`_ ) } [ COLLATE _`collation`_ ] [ _`opclass`_ ] [, ...] ) [ WHERE _`index_predicate`_ ]
    ON CONSTRAINT _`constraint_name`_
```
Инструкция `INSERT` добавляет новые строки в таблицу. Можно вставить одну или несколько строк, используя заданные выражения-значения, либо ноль или более строк, полученных в результате запроса.

Имена целевых столбцов можно перечислять в любом порядке. Если список имён столбцов вообще не указан, по умолчанию используются все столбцы таблицы в порядке их объявления. Если предложение `VALUES` или запрос предоставляют только `N` столбцов, то по умолчанию используются первые `N` столбцов. Значения, предоставленные `VALUES` или запросом, сопоставляются со столбцами из явного или неявного списка слева направо.

Каждый столбец, не указанный в явном или неявном списке, будет заполнен значением по умолчанию: либо его объявленным значением по умолчанию, либо `NULL`, если такового нет.

Если выражение для какого-либо столбца имеет неверный тип данных, будет предпринята попытка автоматического преобразования типов.

Инструкция `INSERT` в таблицы, у которых нет уникальных индексов, не будет блокироваться параллельными операциями. Таблицы с уникальными индексами могут быть заблокированы, если параллельные сеансы выполняют действия, которые блокируют или изменяют строки, совпадающие с вставляемыми значениями уникального индекса. Более подробная информация об этом описана в разделе 62.5. Для того чтобы избежать ошибки нарушения уникального или исключающего ограничения, можно использовать предложение `ON CONFLICT` для указания альтернативного действия. (См. раздел "Предложение ON CONFLICT" ниже).

Необязательное предложение `RETURNING` позволяет инструкции `INSERT` вычислить и вернуть одно или несколько значений на основе каждой фактически вставленной (или обновлённой, если использовалось предложение `ON CONFLICT DO UPDATE`) строки. Это особенно полезно для получения значений, которые были предоставлены по умолчанию, например, порядковый номер из последовательности. Однако можно использовать любое выражение со столбцами таблицы. Синтаксис списка `RETURNING` полностью совпадает с синтаксисом списка вывода в `SELECT`. Будут возвращены только те строки, которые были успешно вставлены или обновлены. Например, если строка была заблокирована, но не обновлена, потому что условие в предложении `ON CONFLICT DO UPDATE ... WHERE` не было выполнено, эта строка не будет возвращена.

Для вставки данных в таблицу вы должны иметь привилегию `INSERT` для неё. Если используется предложение `ON CONFLICT DO UPDATE`, также необходима привилегия `UPDATE` для этой таблицы.

Если указан список столбцов, вам нужна привилегия `INSERT` только для перечисленных столбцов. Аналогично, если указано `ON CONFLICT DO UPDATE`, вам нужна привилегия `UPDATE` только для столбцов, которые вы собираетесь обновить. Однако `ON CONFLICT DO UPDATE` также требует привилегии `SELECT` для любых столбцов, значения которых считываются в выражениях или условиях предложения `ON CONFLICT DO UPDATE`.

Использование предложения `RETURNING` требует привилегии `SELECT` для всех столбцов, упомянутых в `RETURNING`. Если вы используете предложение `query` для вставки строк из запроса, вам, конечно, также нужна привилегия `SELECT` на любую таблицу или столбец, используемый в этом запросе.

Виды конфликтов:
- **ON CONFLICT DO NOTHING** (НИЧЕГО НЕ ДЕЛАТЬ): Это действие просто пропускает вставку строки, если возникает конфликт.
- **ON CONFLICT DO UPDATE** (ОБНОВИТЬ): Это действие обновляет уже существующую строку, которая вызвала конфликт, используя данные из строки, предназначенной для вставки. Это также называют **UPSERT** (от **UP**date или in**SERT** — обновить или вставить).
# Update

Update - это сочетание delete+insert.

```
[ WITH [ RECURSIVE ] _`with_query`_ [, ...] ]
UPDATE [ ONLY ] _`table_name`_ [ * ] [ [ AS ] _`alias`_ ]
    SET { _`column_name`_ = { _`expression`_ | DEFAULT } |
          ( _`column_name`_ [, ...] ) = [ ROW ] ( { _`expression`_ | DEFAULT } [, ...] ) |
          ( _`column_name`_ [, ...] ) = ( _`sub-SELECT`_ )
        } [, ...]
    [ FROM _`from_item`_ [, ...] ]
    [ WHERE _`condition`_ | WHERE CURRENT OF _`cursor_name`_ ]
    [ RETURNING { * | _`output_expression`_ [ [ AS ] _`output_name`_ ] } [, ...] ]
```

Инструкция `UPDATE` изменяет значения указанных столбцов во всех строках, которые удовлетворяют заданному условию. В предложении `SET` необходимо перечислить только те столбцы, которые нужно изменить; столбцы, не указанные явно, сохраняют свои предыдущие значения.

Существует два способа изменить таблицу, используя информацию из других таблиц в базе данных: с помощью **подзапросов (sub-selects)** или путём добавления дополнительных таблиц в предложение `FROM`. Какой из этих методов больше подходит, зависит от конкретных обстоятельств.

Необязательное предложение `RETURNING` позволяет инструкции `UPDATE` вычислить и вернуть одно или несколько значений на основе каждой обновлённой строки. Можно использовать любое выражение с столбцами целевой таблицы и/или столбцами из других таблиц, упомянутых в `FROM`. При этом используются новые (уже изменённые) значения столбцов. Синтаксис списка `RETURNING` полностью совпадает с синтаксисом списка вывода в `SELECT`.

Чтобы выполнить `UPDATE`, вы должны иметь привилегию `UPDATE` для этой таблицы или хотя бы для столбцов, которые вы собираетесь изменить. Также необходима привилегия `SELECT` для любых столбцов, значения которых считываются в выражениях или условиях.

# Delete

```
[ WITH [ RECURSIVE ] _`with_query`_ [, ...] ]
DELETE FROM [ ONLY ] _`table_name`_ [ * ] [ [ AS ] _`alias`_ ]
    [ USING _`from_item`_ [, ...] ]
    [ WHERE _`condition`_ | WHERE CURRENT OF _`cursor_name`_ ]
    [ RETURNING { * | _`output_expression`_ [ [ AS ] _`output_name`_ ] } [, ...] ]
```

Инструкция `DELETE` удаляет из указанной таблицы строки, которые удовлетворяют условию в предложении `WHERE`. Если предложение `WHERE` отсутствует, удаляются все строки в таблице. В результате получается корректная, но пустая таблица.

Существует два способа удалить строки из таблицы, используя информацию из других таблиц в базе данных: с помощью **подзапросов (sub-selects)** или путём добавления дополнительных таблиц в предложение `USING`. Какой из этих методов больше подходит, зависит от конкретных обстоятельств.

Необязательное предложение `RETURNING` позволяет инструкции `DELETE` вычислить и вернуть одно или несколько значений на основе каждой фактически удалённой строки. Можно использовать любое выражение с столбцами целевой таблицы и/или столбцами из других таблиц, упомянутых в `USING`. Синтаксис списка `RETURNING` полностью совпадает с синтаксисом списка вывода в `SELECT`.

Чтобы удалить данные из таблицы, вы должны иметь привилегию `DELETE` для неё, а также привилегию `SELECT` для любой таблицы, указанной в предложении `USING`, или для таблиц, значения которых считываются в условии.

# TRUNCATE

```
TRUNCATE [ TABLE ] [ ONLY ] _`name`_ [ * ] [, ... ]
    [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]
```

Инструкция `TRUNCATE` быстро удаляет все строки из набора таблиц. По своему эффекту она аналогична инструкции `DELETE` без условия `WHERE` для каждой таблицы, но поскольку она фактически не сканирует таблицы, она работает намного быстрее. Кроме того, она немедленно освобождает дисковое пространство, в отличие от `DELETE`, которая требует последующей операции `VACUUM`. Это особенно полезно для больших таблиц.

# DELETE и TRUNCATE

DELETE - оператор DML, удаляет записи из таблицы, которые удовлетворяют критерию WHERE при этом задействуются триггеры, ограничения и т.д. TRUNCATE - DDL оператор (удаляет таблицу и создает ее заново. Причем если на эту таблицу есть ссылки FOREGIN KEY или таблица используется в репликации, то пересоздать такую таблицу не получится).
# Ограничения на целостность данных существуют в SQL

Целостность данных - важное свойство SQL. При правильном использовании оно обеспечивает корректность и валидность хранимых данных в любой момент времени. Также, с их помощью можно обнаруживать ошибки в приложениях, которые тяжело найти другими способами. Целостность данных поддерживается с помощью ограничений.
1. PRIMARY KEY - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей. 
2. CHECK используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе. 
3. UNIQUE обеспечивает отсутствие дубликатов в столбце или наборе столбцов. FOREIGN KEY защищает от действий, которые могут нарушить связи между таблицами. 
4. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY.


Отличия между ограничениями PRIMARY и UNIQUE

По умолчанию ограничение PRIMARY создает кластерный индекс на столбце, а UNIQUE - некластерный. Другим отличием является то, что PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну (а в некоторых СУБД несколько) NULL запись.

# PIVOT и UNPIVOT в Transact-SQL

PIVOT и UNPIVOT являются нестандартными реляционными операторами, которые поддерживаются Transact-SQL. Оператор PIVOT разворачивает возвращающее табличное значение выражение, преобразуя уникальные значения одного столбца выражения в несколько выходных столбцов, а также, в случае необходимости, объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных. Оператор UNPIVOT производит действия, обратные PIVOT, преобразуя столбцы возвращающего табличное значение выражения в значения столбца.

# UNION, INTERSECT, EXCEPT

Оператор UNION - применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из похожих срок. Оба запроса Должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Оператор INTERSECT - используется для нахождения пересечения двух множеств. Результатом его выполнения будет множество строк, которые присутствуют в обоих множествах. Оператор EXCEPT - используется для нахождения разности двух множеств. Результатом выполнения является множество строк из множества 1, которые отсутствуют в множестве 2. Приоритет выполнения операторов над множествами: INTERSECT -> EXCEPT -> UNION

# Оконная функция

Оконная функция в SQL - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце.

Партиции (окна из набора строк) - это набор строк, указанный для оконной функции по одному из столбцов или группе столбцов таблицы. Партиции для каждой оконной функции в запросе могут быть разделены по различным колонкам таблицы.

При использовании агрегирующих функций предложение GROUP BY сокращает количество строк в запросе с помощью их группировки.

При использовании оконных функций количество строк в запросе не уменьшается по сравнении с исходной таблицей.

## Порядок расчета оконных функций в SQL запросе

SELECT list of columns, window functions FROM table / joint tables / subquery WHERE filtering clause GROUP BY list of columns HAVING aggregation filtering clause ORDER BY list of columns /window functions

Сначала выполняется команда выборки таблиц, их объединения и возможные подзапросы под командой FROM. Далее выполняются условия фильтрации WHERE, группировки GROUP BY и возможная фильтрация c HAVING Только потом применяется команда выборки столбцов SELECT и расчет оконных функций под выборкой. После этого идет условие сортировки ORDER BY, где тоже можно указать столбец расчета оконной функции для сортировки. Здесь важно уточнить, что партиции или окна оконных функций создаются после разделения таблицы на группы с помощью команды GROUP BY, если эта команда используется в запросе.

## Синтаксис оконных функций

1. Имя оконной функции одного из классов
    
2. Необязательное выражение фильтрации
    
3. Ключевое слово определения оконной ф.
    
4. Определение партиций по колонкам
    
5. Сортировка вычисления оконной функции
    
6. Указание фрейма для партиции
    
7. FUNCTION_NAME(column_name)
    
8. [FILTER (WHERE filter_clause)]
    
9. OVER
    
10. PARTITION BY (column names),
    
11. ORDER BY (column names),
    
12. [frame clause]
    

SELECT Название функции (столбец для вычислений) OVER ( PARTITION BY столбец для группировки ORDER BY столбец для сортировки ROWS или RANGE выражение для ограничения строк в пределах группы )

## OVER()

Откроем окно при помощи OVER() и просуммируем столбец «Conversions»: SELECT Date , Medium , Conversions , SUM(Conversions) OVER() AS 'Sum' FROM Orders

Мы использовали инструкцию OVER() без предложений. В таком варианте окном будет весь набор данных и никакая сортировка не применяется. Появился новый столбец «Sum» и для каждой строки выводится одно и то же значение 14. Это сквозная сумма всех значений колонки «Conversions».

## PARTITION BY

Теперь применим инструкцию PARTITION BY, которая определяет столбец, по которому будет производиться группировка и является ключевой в разделении набора строк на окна: SELECT Date , Medium , Conversions , SUM(Conversions) OVER(PARTITION BY Date) AS 'Sum' FROM Orders

Инструкция PARTITION BY сгруппировала строки по полю «Date». Теперь для каждой группы рассчитывается своя сумма значений столбца «Conversions».

## ORDER BY

Попробуем отсортировать значения внутри окна при помощи ORDER BY: SELECT Date , Medium , Conversions , SUM(Conversions) OVER(PARTITION BY Date ORDER BY Medium) AS 'Sum' FROM Orders

К предложению PARTITION BY добавилось ORDER BY по полю «Medium». Таким образом мы указали, что хотим видеть сумму не всех значений в окне, а для каждого значения «Conversions» сумму со всеми предыдущими. То есть мы посчитали нарастающий итог.

## ROWS или RANGE

Инструкция ROWS позволяет ограничить строки в окне, указывая фиксированное количество строк, предшествующих или следующих за текущей. Инструкция RANGE, в отличие от ROWS, работает не со строками, а с диапазоном строк в инструкции ORDER BY. То есть под одной строкой для RANGE могут пониматься несколько физических строк одинаковых по рангу. Обе инструкции ROWS и RANGE всегда используются вместе с ORDER BY. В выражении для ограничения строк ROWS или RANGE также можно использовать следующие ключевые слова: UNBOUNDED PRECEDING — указывает, что окно начинается с первой строки группы; UNBOUNDED FOLLOWING - с помощью данной инструкции можно указать, что окно заканчивается на последней строке группы; CURRENT ROW - инструкция указывает, что окно начинается или заканчивается на текущей строке; BETWEEN «граница окна» AND «граница окна» — указывает нижнюю и верхнюю границу окна; «Значение» PRECEDING - определяет число строк перед текущей строкой (не допускается в предложении RANGE).; «Значение» FOLLOWING — определяет число строк после текущей строки (не допускается в предложении RANGE).

Разберем на примере: SELECT Date , Medium , Conversions , SUM(Conversions) OVER(PARTITION BY Date ORDER BY Conversions ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS 'Sum' FROM Orders

## Виды функций

Агрегатные функции - это функции, которые выполняют на наборе данных арифметические вычисления и возвращают итоговое значение. SUM - возвращает сумму значений в столбце; COUNT — вычисляет количество значений в столбце (значения NULL не учитываются); AVG — определяет среднее значение в столбце; MAX — определяет максимальное значение в столбце; MIN — определяет минимальное значение в столбце. Пример использования агрегатных функций с оконной инструкцией OVER: SELECT Date , Medium , Conversions , SUM(Conversions) OVER(PARTITION BY Date) AS 'Sum' , COUNT(Conversions) OVER(PARTITION BY Date) AS 'Count' , AVG(Conversions) OVER(PARTITION BY Date) AS 'Avg' , MAX(Conversions) OVER(PARTITION BY Date) AS 'Max' , MIN(Conversions) OVER(PARTITION BY Date) AS 'Min' FROM Orders

Ранжирующие функции - это функции, которые ранжируют значение для каждой строки в окне. Например, их можно использовать для того, чтобы присвоить порядковый номер строке или составить рейтинг. ROW_NUMBER - функция возвращает номер строки и используется для нумерации; RANK — функция возвращает ранг каждой строки. В данном случае значения уже анализируются и, в случае нахождения одинаковых, возвращает одинаковый ранг с пропуском следующего значения; DENSE_RANK — функция возвращает ранг каждой строки. Но в отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий; NTILE - это функция, которая позволяет определить к какой группе относится текущая строка. Количество групп задается в скобках. SELECT Date , Medium , Conversions , ROW_NUMBER() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Row_number' , RANK() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Rank' , DENSE_RANK() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Dense_Rank' , NTILE(3) OVER(PARTITION BY Date ORDER BY Conversions) AS 'Ntile' FROM Orders

Функции смещения Функции смещения - это функции, которые позволяют перемещаться и обращаться к разным строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или в конце окна. LAG или LEAD - функция LAG обращается к данным из предыдущей строки окна, а LEAD к данным из следующей строки. Функцию можно использовать для того, чтобы сравнивать текущее значение строки с предыдущим или следующим. Имеет три параметра: столбец, значение которого необходимо вернуть, количество строк для смещения (по умолчанию 1), значение, которое необходимо вернуть если после смещения возвращается значение NULL; FIRST_VALUE или LAST_VALUE — с помощью функции можно получить первое и последнее значение в окне. В качестве параметра принимает столбец, значение которого необходимо вернуть. SELECT Date , Medium , Conversions , LAG(Conversions) OVER(PARTITION BY Date ORDER BY Date) AS 'Lag' , LEAD(Conversions) OVER(PARTITION BY Date ORDER BY Date) AS 'Lead' , FIRST_VALUE(Conversions) OVER(PARTITION BY Date ORDER BY Date) AS 'First_Value' , LAST_VALUE(Conversions) OVER(PARTITION BY Date ORDER BY Date) AS 'Last_Value' FROM Orders

Аналитические функции — это функции которые возвращают информацию о распределении данных и используются для статистического анализа. CUME_DIST — вычисляет интегральное распределение (относительное положение) значений в окне; PERCENT_RANK — вычисляет относительный ранг строки в окне; PERCENTILE_CONT — вычисляет процентиль на основе постоянного распределения значения столбца. В качестве параметра принимает процентиль, который необходимо вычислить (в этой статье я рассказываю как посчитать медиану, благодаря этой функции); PERCENTILE_DISC — вычисляет определенный процентиль для отсортированных значений в наборе данных. В качестве параметра принимает процентиль, который необходимо вычислить.

Важно! У функций PERCENTILE_CONT и PERCENTILE_DISC, столбец, по которому будет происходить сортировка, указывается с помощью ключевого слова WITHIN GROUP.

SELECT Date , Medium , Conversions , CUME_DIST() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Cume_Dist' , PERCENT_RANK() OVER(PARTITION BY Date ORDER BY Conversions) AS 'Percent_Rank' , PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY Conversions) OVER(PARTITION BY Date) AS 'Percentile_Cont' , PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY Conversions) OVER(PARTITION BY Date) AS 'Percentile_Disc' FROM Orders

