
**Индекс** — это специальная структура данных, которая создаётся для ускорения поиска и обработки запросов в базе данных. Он хранит отсортированные значения одного или нескольких столбцов таблицы и указатели на соответствующие строки.

Индексы — не бесплатное решение, они имеют свои издержки:
**Ускорение чтения vs. замедление записи**:
- Индексы значительно ускоряют **SELECT**, но замедляют операции **INSERT**, **UPDATE** и **DELETE**, так как СУБД должна обновлять не только таблицу, но и все связанные индексы.
Индексы — это отдельные структуры, которые занимают место на диске. Чем больше индексов и чем шире индексируемые столбцы, тем больше дискового пространства требуется.
## **B-Tree (B-дерево)**
Индекс btree, он же B-дерево, пригоден для данных, которые можно отсортировать. Иными словами, для типа данных должны быть определены операторы «больше», «больше или равно», «меньше», «меньше или равно» и «равно». Заметьте, что одни и те же данные иногда можно сортировать разными способами, что возвращает нас к концепции семейства операторов.  
  
Как всегда, индексные записи B-дерева упакованы в страницы. В листовых страницах эти записи содержат индексируемые данные (ключи) и ссылки на строки таблицы (TID-ы); во внутренних страницах каждая запись ссылается на дочернюю страницу индекса и содержит минимальное значение ключа в этой странице.  
  
B-деревья обладают несколькими важными свойствами:  
- Они сбалансированы, то есть любую листовую страницу отделяет от корня одно и то же число внутренних страниц. Поэтому поиск любого значения занимает одинаковое время.  
- Они сильно ветвисты, то есть каждая страница (как правило, 8 КБ) содержит сразу много (сотни) TID-ов. За счет этого глубина B-деревьев получается небольшой; на практике до 4–5 для очень больших таблиц.  
- Данные в индексе упорядочены по неубыванию (как между страницами, так и внутри каждой страницы), а страницы одного уровня связаны между собой двунаправленным списком. Поэтому получить упорядоченный набор данных мы можем, просто проходя по списку в одну или в другую сторону, не возвращаясь каждый раз к корню.  
  
Вот схематичный пример индекса по одному полю с целочисленными ключами.  

![[Pasted image 20250906214925.png]]
В самом начале файла находится метастраница, которая ссылается на корень индекса. Ниже корня расположены внутренние узлы; самый нижний ряд — листовые страницы. Стрелочки вниз символизируют ссылки из листовых узлов на строки таблицы (TID-ы).Индекс по умолчанию, подходит для большинства сценариев. Эффективен для операций сравнения (`=`, `>`, `<`, `>=`, `<=`, `BETWEEN`, `IN`, `IS NULL`) и сортировки (`ORDER BY`). Также поддерживает `LIKE 'префикс%'` ( например, `LIKE 'abc%'`).

## **Hash**
Многие современные языки программирования включают хеш-таблицы в качестве базового типа данных. Внешне это выглядит, как обычный массив, но в качестве индекса используется не целое число, а любой тип данных (например, строка). Хеш-индекс в PostgreSQL устроен похожим образом. Как это работает?  
  
Как правило, типы данных имеют очень большие диапазоны допустимых значений: сколько различных строк можно теоретически представить в столбце типа text? В то же время, сколько разных значений реально хранится в текстовом столбце какой-нибудь таблицы? Обычно не так много.  
  
Идея хеширования состоит в том, чтобы значению любого типа данных сопоставить некоторое небольшое число (от 0 до _N_−1, всего _N_ значений). Такое сопоставление называют _хеш-функцией._ Полученное число можно использовать как индекс обычного массива, куда и складывать ссылки на строки таблицы (TID). Элементы такого массива называют _корзинами хеш-таблицы_ — в одной корзине могут лежать несколько TID-ов, если одно и то же проиндексированное значение встречается в разных строках.  
  
Хеш-функция тем лучше, чем равномернее она распределяет исходные значения по корзинам. Но даже хорошая функция будет иногда давать одинаковый результат для разных входных значений — это называется _коллизией._ Так что в одной корзине могут оказаться TID-ы, соответствующие разным ключам, и поэтому полученные из индекса TID-ы необходимо перепроверять.  
  
Просто в качестве примера: какую хеш-функцию можно придумать для строк? Пусть число корзин равно 256. Тогда в качестве номера корзины можно взять код первого символа (допустим, у нас однобайтовая кодировка). Хорошая ли это хеш-функция? Очевидно, нет: если все строки начинаются с одного и того же символа, все они попадут в одну корзину; о равномерности тут нет и речи, придется перепроверять все значения и весь смысл хеширования потеряется. Что, если просуммировать коды всех символов по модулю 256? Будет гораздо лучше, хотя тоже далеко не идеально. Если интересно, как на самом деле устроена такая хеш-функция в PostgreSQL, посмотрите определение hash_any() в hashfunc.c.  

**Устройство индекса**
Вернемся к хеш-индексу. Наша задача состоит в том, чтобы по значению некоторого типа данных (ключ индексирования) быстро найти соответствующий TID.  
  
При вставке в индекс вычислим хеш-функцию для ключа. Хеш-функции в PostgreSQL всегда возвращают тип integer, что соответствует диапазону 232 ≈ 4 миллиарда значений. Число корзин изначально равно двум и увеличивается динамически, подстраиваясь под объем данных; номер корзины можно вычислить по хеш-коду с помощью битовой арифметики. В эту корзину и положим наш TID.  
  
Но этого недостаточно, ведь в одну корзину могут попасть TID-ы, соответствующие разным ключам. Как быть? Можно было бы записывать в корзину вместе с TID-ом еще и исходное значение ключа, но это очень сильно увеличило бы размер индекса. Так что для экономии места в корзине сохраняется не сам ключ, а его хеш-код.  
  
При поиске в индексе мы вычисляем хеш-функцию для ключа и получаем номер корзины. Остается перебрать все содержимое корзины и вернуть только подходящие TID-ы с нужными хеш-кодами. Это делается эффективно, поскольку пары «хеш-код — TID» хранятся упорядоченно.  
  
Но может так получиться, что два разных ключа не просто попадут в одну корзину, но и будут иметь одинаковые 4-байтовые хеш-коды — коллизии никто не отменял. Поэтому метод доступа просит общий механизм индексирования контролировать каждый TID, перепроверяя условие по табличной строке (механизм умеет это делать заодно с проверкой видимости).  

**Страничная организация**
Если посмотреть на индекс не с точки зрения планирования и выполнения запроса, а глазами менеджера буферного кеша, то окажется, что вся информация, все индексные записи должны быть упакованы в страницы. Такие индексные страницы помещаются в буферный кеш и вытесняются оттуда точно так же, как и табличные страницы.  

![[Pasted image 20250906215107.png]]
Хеш-индекс, как видно на картинке, использует страницы (серые прямоугольники) четырех видов:  
  

- Метастраница (meta page) — нулевая страница, содержит информацию о том, что находится внутри индекса;
- Страницы корзин (bucket page) — основные страницы индекса, хранят данные в виде пар «хеш-код — TID»;
- Страницы переполнения (overflow page) — устроены так же, как страницы корзин, и используются в случае, когда одной страницы для корзины не хватает;
- Страницы битовой карты (bitmap page) — в них отмечаются освободившиеся страницы переполнения, которые можно использовать для других корзин.

  
Стрелочки вниз, идущие от элементов индексных страниц, символизируют TID-ы — ссылки на табличные строки.  
  
При очередном увеличении индекса одномоментно создается в два раза больше корзин (и, соответственно, страниц), чем в прошлый раз. Чтобы не выделять сразу такое, потенциально большое, количество страниц, в версии 10 сделали более плавное увеличение размера. Ну а страницы переполнения выделяются просто по мере необходимости и отслеживаются в страницах битовой карты, которые также выделяются по мере надобности.  
  
Заметим, что хеш-индекс не умеет уменьшаться в размере. Если удалить часть проиндексированных строк, однажды выделенные страницы уже не возвращаются операционной системе, а только переиспользуются для новых данных после очистки (VACUUM). Единственный вариант уменьшить физический размер индекса — перестроить его с нуля командой REINDEX или VACUUM FULL.Только для операций точного равенства (`=`). Подходит для столбцов с высокой селективностью, где не нужны диапазонные запросы. В PostgreSQL до версии 10 были проблемы с надёжностью, но теперь они решены. Однако B-Tree чаще предпочтительнее.

## **GIN (Generalized Inverted Index)**
GIN расшифровывается как Generalized Inverted Index — это так называемый _обратный индекс_. Он работает с типами данных, значения которых не являются атомарными, а состоят из элементов. При этом индексируются не сами значения, а отдельные элементы; каждый элемент ссылается на те значения, в которых он встречается.  
  
Хорошая аналогия для этого метода — алфавитный указатель в конце книги, где для каждого термина приведен список страниц, где этот термин упоминается. Как и указатель в книге, индексный метод должен обеспечивать быстрый поиск проиндексированных элементов. Для этого они хранятся в виде уже знакомого нам B-дерева (для него используется другая, более простая, реализация, но в данном случае это несущественно). К каждому элементу привязан упорядоченный набор ссылок на строки таблицы, содержащие значения с этим элементом. Упорядоченность не принципиальна для выборки данных (порядок сортировки TID-ов не несет в себе особого смысла), но важна с точки зрения внутреннего устройства индекса.  
  
Элементы никогда не удаляются из GIN-индекса. Считается, что значения, содержащие элементы, могут пропадать, появляться, изменяться, но набор элементов, из которых они состоят — довольно статичен. Такое решение существенно упрощает алгоритмы, обеспечивающие параллельную работу с индексом нескольких процессов.  
  
Если список TID-ов достаточно мал, он помещается в ту же страницу, что и элемент (и называется posting list). Но если список большой, нужна более эффективная структура данных, и мы ее уже знаем — это снова B-дерево. Такое дерево располагается в отдельных страницах данных (и называется posting tree).  
  
Таким образом, индекс GIN состоит из B-дерева элементов, к листовым записям которого привязаны B-деревья или плоские списки TID-ов.  

![[Pasted image 20250906215447.png]]

Как и рассмотренные ранее индексы GiST и SP-GiST, GIN предоставляет прикладному разработчику интерфейс для поддержки различных операций над сложносоставными типами данных.Для сложных типов данных:
    - Полнотекстовый поиск с `tsvector` (например, поиск по ключевым словам в тексте).
    - Массивы (операторы `@>`, `<@`, `&&`, например, поиск по тегам).
    - JSONB (операторы `?`, `?|`, `?&`, `@>`, например, поиск в JSON-полях).

## **GiST (Generalized Search Tree)**
GiST — сокращение от «generalized search tree». Это сбалансированное дерево поиска, точно так же, как и рассмотренный ранее b-tree.  
  
В чем же разница? Индекс b-tree жестко привязан к семантике сравнения: поддержка операторов «больше», «меньше», «равно» — это все, на что он способен (зато способен очень хорошо!). Но в современных базах хранятся и такие типы данных, для которых эти операторы просто не имеют смысла: геоданные, текстовые документы, картинки…  
  
Тут на помощь и приходит индексный метод GiST. Он позволяет задать принцип распределения данных произвольного типа по сбалансированному дереву, и метод использования этого представления для доступа по некоторому оператору. Например, в GiST-индекс можно «уложить» R-дерево для пространственных данных с поддержкой операторов взаимного расположения (находится слева, справа; содержит и т. п.), или RD-дерево для множеств с поддержкой операторов пересечения или вхождения.  
  
За счет расширяемости в PostgreSQL вполне можно создать совершенно новый метод доступа с нуля: для этого надо реализовать интерфейс с механизмом индексирования. Но это требует продумывания не только логики индексации, но и страничной структуры, эффективной реализации блокировок, поддержки журнала упреждающей записи — что подразумевает очень высокую квалификацию разработчика и большую трудоемкость. GiST упрощает задачу, беря на себя низкоуровневые проблемы и предоставляя свой собственный интерфейс: несколько функций, относящихся не к технической сфере, а к прикладной области. В этом смысле можно говорить о том, что GiST является каркасом для построения новых методов доступа.  
  
 **Устройство**
GiST — сбалансированное по высоте дерево, состоящее из узлов-страниц. Узлы состоят из индексных записей.  
  
Каждая запись листового узла (листовая запись) содержит, если говорить в самом общем виде, некий _предикат_ (логическое выражение) и ссылку на строку таблицы (TID). Индексированные данные (ключ) должны удовлетворять этому предикату.  
  
Каждая запись внутреннего узла (внутренняя запись) также содержит _предикат_ и ссылку на дочерний узел, причем все индексированные данные дочернего поддерева должны удовлетворять этому предикату. Иными словами, предикат внутренней записи _включает_ в себя предикаты всех дочерних записей. Это важное свойство, заменяющее индексу GiST простую упорядоченность B-дерева.  
  
Поиск в дереве GiST использует специальную _функцию согласованности_ (consistent) — одну из функций, определяемых интерфейсом, и реализуемую по-своему для каждого поддерживаемого семейства операторов.  
  
Функция согласованности вызывается для индексной записи и определяет, «согласуется» ли предикат данной записи с поисковым условием (вида «_индексированное-поле оператор выражение_»). Для внутренней записи она фактически определяет, надо ли спускаться в соответствующее поддерево, а для листовой записи — удовлетворяют ли индексированные данные условию.  
  
Поиск, как обычно в дереве, начинается с корневого узла. С помощью функции согласованности выясняется, в какие дочерние узлы имеет смысл заходить (их может оказаться несколько), а в какие — нет. Затем алгоритм повторяется для каждого из найденных дочерних узлов. Если же узел является листовым, то запись, отобранная функцией согласованности, возвращается в качестве одного из результатов.  
  
Поиск производится в глубину: алгоритм в первую очередь старается добраться до какого-нибудь листового узла. Это позволяет по возможности быстро вернуть первые результаты (что может быть важно, если пользователя интересуют не все результаты, а только несколько).  
  
Еще раз обратим внимание, что функция согласованности не должна иметь какое-либо отношение к операторам «больше», «меньше» или «равно». Ее семантика может быть совершенно иной, и поэтому не предполагается, что индекс будет выдавать значения в каком-то определенном порядке.  
  
Мы не будем рассматривать алгоритмы вставки и удаления значений в GiST — для этого используется еще несколько интерфейсных функций. Но есть один важный момент. При вставке в индекс нового значения для него выбирается такая родительская запись, чтобы ее предикат пришлось расширить как можно меньше (в идеале, не расширить вовсе). Но при удалении значения предикат родительской записи уже не сужается. Это происходит только в двух случаях: при разделении страницы на две (когда на странице не хватает места для вставки новой индексной записи) и при полном перестроении индекса (командами reindex или vacuum full). Поэтому эффективность GiST-индекса при часто меняющихся данных может со временем деградировать.  
  
Дальше мы рассмотрим несколько примеров индексов для разных типов данных и полезные свойства GiST:  
- точки (и другие геометрические объекты) и поиск ближайших соседей;
- интервалы и ограничения исключения;
- полнотекстовый поиск.

**R-дерево для точек**
Продемонстрируем сказанное выше на примере индекса для точек на плоскости (похожие индексы можно построить и для других геометрических объектов). Обычное B-дерево не подходит для такого типа данных, так как для точек не определены операторы сравнения.  
  
Идея R-дерева состоит в том, что плоскость разбивается на прямоугольники, которые в сумме покрывают все индексируемые точки. Индексная запись хранит прямоугольник, а предикат можно сформулировать так: «искомая точка лежит внутри данного прямоугольника».  
  
Корень R-дерева будет содержать несколько самых крупных прямоугольников (возможно, даже пересекающихся). Дочерние узлы будут содержать меньшие по размеру прямоугольники, вложенные в родительский, в совокупности охватывающие все нижележащие точки.  
  
Листовые узлы, по идее, должны содержать индексируемые точки, однако тип данных во всех индексных записях должен совпадать; поэтому хранятся все те же прямоугольники, но «схлопнутые» до точек.  
  
Чтобы представить себе такую структуру наглядно, ниже приведены рисунки трех уровней R-дерева; точки представляют координаты аэропортов (аналогично таблице airports демо-базы, но здесь взято больше данных с сайта openflights.org.  
![[Pasted image 20250906215311.png]]

 Для данных, где важны геометрические или логические отношения:
    - Геометрические типы (поиск пересекающихся фигур, например, полигонов).
    - Полнотекстовый поиск (в некоторых случаях).
    - Данные с "пересечением" (например, диапазоны времени).

## **BRIN (Block Range Index)**
В отличие от индексов, с которыми мы уже познакомились, идея BRIN не в том, чтобы быстро найти нужные строки, а в том, чтобы избежать просмотра заведомо ненужных. Это всегда _неточный_ индекс: он вообще не содержит TID-ов табличных строк.  
  
Упрощенно говоря, BRIN хорошо работает для тех столбцов, значения в которых коррелируют с их физическим расположением в таблице. Иными словами, если запрос без предложения ORDER BY выдает значения столбца практически в порядке возрастания или убывания (и при этом по столбцу нет индексов).  
  
Метод доступа создавался в рамках европейского проекта по сверхбольшим аналитическим базам данных Axle с прицелом на таблицы размером в единицы и десятки терабайт. Важное свойство BRIN, позволяющее создавать индексы на таких таблицах — небольшой размер и минимальные накладные расходы на поддержание.  
  
Работает это следующим образом. Таблица разбивается на _зоны_ (range) размером в несколько страниц (или блоков, что то же самое) — отсюда и название: Block Range Index, BRIN. Для каждой зоны в индексе сохраняется _сводная информация_ о данных в этой зоне. Как правило, это минимальное и максимальное значения, но бывает и иначе, как мы увидим дальше. Если при выполнении запроса, содержащего условие на столбец, искомые значения не попадают в диапазон, то всю зону можно смело пропускать; если же попадают — все строки во всех блоках зоны придется просмотреть и выбрать среди них подходящие.  
  
Не будет ошибкой рассматривать BRIN не как индекс в обычном понимании, а как ускоритель последовательного сканирования таблицы. Можно посмотреть на него и как на альтернативу секционированию, если каждую зону считать отдельной «виртуальной» секцией.  
Теперь рассмотрим устройство индекса более подробно.  

 **Устройство**
Первой (точнее, нулевой) в индексе идет страница с метаданными.  
  
С некоторым отступом от метаданных находятся страницы со сводной информацией. Каждая индексная строка содержит сводку по какой-то одной зоне.  
  
А между метастраницей и сводными данными располагаются страницы с _обратной картой зон_ (reverse range map, сокращенно revmap). По сути, это массив указателей (TID-ов) на соответствующие индексные строки.  

![[Pasted image 20250906215600.png]]

Для некоторых зон указатель в revmap может не вести ни к какой индексной строке (на рисунке отмечен серым цветом). В этом случае считается, что для этой зоны еще нет сводной информации.  
  
**Сканирование индекса**
Как используется индекс, если он не содержит ссылок на табличные строки? Конечно, возвращать строки одну за другой этот метод доступа не умеет, зато он может построить битовую карту. Страницы битовой карты бывает двух типов: точные — до строки — и неточные — до страницы. Именно неточная битовая карта и используется.  
  
Алгоритм простой. Последовательно просматривается карта зон (то есть зоны перебираются в порядке их расположения в таблице). С помощью указателей определяются индексные строки со сводной информацией по каждой зоне. Если зона точно не содержит искомого значения, она пропускается; если может содержать (или если сводная информация отсутствует) — все страницы зоны добавляются к битовой карте. Получившаяся битовая карта используется дальше как обычно.  
  
 **Обновление индекса**
Интереснее обстоит дело с обновлением индекса при изменении таблицы.  
  
**При добавлении** новой версии строки в табличную страницу мы определяем, к какой зоне она принадлежит, и по карте зон находим индексную строку со сводной информацией. Все это — простые арифметические операции. Пусть, например, размер зоны — 4 страницы, и на странице 13 появилась версия строки со значением «42». Номер зоны (начиная с нуля) равен 13 / 4 = 3, значит в revmap берем указательно со смещением 3 (четвертый по счету).  
  
Минимальное значение для этой зоны — 31, максимальное — 40. Поскольку новое значение 42 выходит за эти пределы, обновляем максимальное значение (см. рисунок). Если же новое значение укладывается в существующие рамки, индекс обновлять не нужно.  

![[Pasted image 20250906215621.png]]

Все это касается случая, когда новая версия строки появляется в зоне, для которой уже есть сводная информация. При построении индекса сводная информация вычисляется для всех существующих зон, но при дальнейшем росте таблицы могут появиться новые страницы, выходящие за этот диапазон. Тут возможны два варианта:  
1. Обычно немедленного обновления индекса не происходит. Ничего страшного в этом нет; как мы говорили, при сканировании индекса будет просмотрена вся зона целиком. Фактически же обновление выполняется при очистке (vacuum), либо его можно выполнить вручную, вызвав функцию brin_summarize_new_values.  
2. Если создать индекс с параметром autosummarize, то обновление будет происходить немедленно. Но при заполнении страниц зоны новыми значениями обновление может выполняться очень часто, поэтому этот параметр и выключен по умолчанию.  
При появлении новых зон размер revmap может увеличиться. Если эта карта перестает помещаться в отведенные ей страницы, она просто «захватывает» следующую, а все версии строк, которые там были, перемещаются на другие страницы. Таким образом, карта зон всегда располагается между метастраницей и сводными данными.  
  
**При удалении** строки… ничего не происходит. Можно заметить, что в каких-то случаях будет удалено минимальное или максимальное значение, и тогда диапазон можно было бы уменьшить. Но чтобы это определить, пришлось бы прочитать все значения в зоне, а это накладно.  
  
Корректность индекса от этого не страдает, однако при поиске может потребоваться просмотреть больше зон, чем реально необходимо. В принципе, по такой зоне можно вручную пересобрать сводную информацию (вызвать функции brin_desummarize_range и brin_summarize_new_values), но как обнаружить такую необходимость? Во всяком случае, никакой штатной процедуры для этого не предусмотрено.  
  
Ну и **обновление строки** — это просто удаление старой версии и добавление новой.Для очень больших таблиц с естественным порядком данных (например, временные метки или автоинкрементные ID). Эффективен, если данные физически упорядочены (например, новые записи добавляются в конец).

## **SP-GIST**

Итак, идея индексного метода SP-GiST состоит в разбиении области значений на _неперекрывающиеся_ подобласти, каждая из которых, в свою очередь, также может быть разбита. Такое разбиение порождает _несбалансированные_ деревья (в отличие от B-деревьев и обычного GiST).  
  
Свойство непересечения упрощает принятие решений при вставке и поиске. С другой стороны, получающиеся деревья, как правило, слабо ветвисты. Например, узел дерева квадрантов обычно имеет четыре дочерних узла (в отличие от B-деревьев, где они измеряются сотнями) и большую глубину. Такие деревья хорошо подходят для работы в оперативной памяти, но индекс хранится на диске, и поэтому для сокращения числа операций ввода-вывода узлы приходится паковать в страницы — а это непросто сделать эффективно. Кроме того, время поиска разных значений в индексе может отличаться из-за разной глубины ветвей.  
  
Так же, как и GiST, этот метод доступа берет на себя заботу о низкоуровневых задачах (одновременный доступ и блокировки, журналирование, собственно алгоритм поиска) и позволяет добавлять поддержку новых типов данных и алгоритмов разбиения, предоставляя для этого специальный упрощенный интерфейс.  
  
Внутренний узел дерева SP-GiST хранит ссылки на дочерние узлы; для каждой ссылки может быть задана _метка._ Кроме того, внутренний узел может хранить значение, называемое _префиксом._ На самом деле это значение не обязано быть именно префиксом; его можно рассматривать как произвольный предикат, выполняющийся для всех дочерних узлов.  
  
Листовые узлы SP-GiST содержат значение индексированного типа и ссылку на строку таблицы (TID). В качестве значения могут использоваться сами индексированные данные (ключ поиска), но не обязательно: может храниться и сокращенное значение.  
  
Кроме того, листовые узлы могут собираться в списки. Таким образом, внутренний узел может ссылаться не на одно единственное значение, а на целый список.  
  
Заметим, что префиксы, метки и значения в листовых узлах все могут быть совершенно разных типов данных.  
  
Как и в GiST, основной функцией, которую надо определить для поиска, является _функция согласованности._ Эта функция вызывается для узла дерева и возвращает набор дочерних узлов, значения которых «согласуются» с поисковым предикатом (как обычно, вида «_индексированное-поле оператор выражение_»). Для листового узла функция согласованности определяет, удовлетворяет ли индексированное значение в этом узле поисковому предикату.  
  
Поиск начинается с корневого узла. С помощью функции согласованности выясняется, в какие дочерние узлы имеет смысл заходить; алгоритм повторяется для каждого из найденных узлов. Поиск производится в глубину.  
  
На физическом уровне узлы индекса упакованы в страницы, чтобы с ними можно было эффективно работать с точки зрения операций ввода-вывода. При этом на одной странице оказываются либо внутренние узлы, либо листовые, но не те и другие одновременно.

![[Pasted image 20250906215755.png]]

## **Bloom**

Классический фильтр Блума — структура данных, позволяющая быстро проверить принадлежность элемента множеству. Фильтр очень компактен, но допускает ложные срабатывания: он имеет право ошибиться и счесть элемент принадлежащим множеству (false positive), но не имеет права сказать, что элемента нет в множестве, если на самом деле он там присутствует (false negative).  
  
Фильтр представляет собой битовый массив (называемый также _сигнатурой_) длиной _m_ бит, изначально заполненный нулями. Выбираются _k_ различных хеш-функций, которые отображают любой элемент множества в _k_ битов сигнатуры. Чтобы добавить элемент в множество, нужно установить в сигнатуре каждый из этих битов в единицу. Следовательно, если все соответствующие элементу биты установлены в единицу — элемент может присутствовать в множестве; если хотя бы один бит равен нулю — элемент точно отсутствует.  
  
В случае индекса СУБД мы фактически имеем _N_ отдельных фильтров, построенных для каждой индексной строки. Как правило, в индекс включаются несколько полей; значения этих полей и составляют множество элементов для каждой из строк.  
  
Благодаря выбору размера сигнатуры _m,_ можно находить компромисс между объемом индекса и вероятностью ложного срабатывания. Область применения Блум-индекса — большие, достаточно «широкие» таблицы, запросы к которым могут использовать фильтрацию по любым из полей. Этот метод доступа, как и BRIN, можно рассматривать как ускоритель последовательного сканирования: все найденные индексом совпадения необходимо перепроверять по таблице, но есть шанс вовсе не рассматривать значительную часть строк.  

**Устройство**
Мы уже говорили о сигнатурных деревьях в контексте метода доступа GiST. В отличие от этих деревьев, Блум-индекс представляет собой плоскую структуру. Он состоит из метастраницы, за которой следуют обычные страницы с индексными строками. Каждая индексная строка содержит сигнатуру и ссылку на табличную строку (TID), как схематически показано на рисунке.  

![[Pasted image 20250906215944.png]]

# Разновидность видов индексов
**Составные (многоколоночные) индексы**
Индекс, охватывающий несколько столбцов.
**Особенности**:
- **Порядок столбцов важен**: Индекс `(A, B)` эффективен для запросов `WHERE A = ?`, `WHERE A = ? AND B = ?`, но не для `WHERE B = ?`, так как индекс строится по `A` в первую очередь.
- Используется для запросов с фильтрацией, сортировкой или объединением по нескольким столбцам.
Размещайте в начале столбцы с более высокой селективностью или те, которые чаще используются в фильтрах. Порядок важен потому что, при доступе мы сначала сортируем по первой колонке, а потом только по второй. При доступе только по первой колонке, индекс сможет увидеть данные и они будут находиться близко друг к другу. При доступе только во второй колонке, данные будут находится в разных блоках и непонятно где, поэтому это не эффективно и оптимизатор не возьмёт его.

 **Кластерный индекс**
 В PostgreSQL нет "кластерного индекса" в классическом смысле (как в SQL Server), но есть команда `CLUSTER`, которая физически переупорядочивает строки таблицы в порядке указанного индекса.
 Таблица не остаётся кластеризованной навсегда — новые вставки/обновления нарушают порядок. Требуется периодический вызов `CLUSTER`.

 **Покрывающие индексы (Covering Indexes) и Index-Only Scans**

**Index-Only Scan**: Самый быстрый способ чтения, когда PostgreSQL получает все данные из индекса, не обращаясь к таблице (heap).
**Когда использовать**: Если запрос запрашивает только столбцы, входящие в индекс ( например, `SELECT col_a, col_b FROM my_table WHERE col_a = 42`).
**Польза**: Ускоряет запросы, минимизируя доступ к таблице, особенно для больших таблиц.

**Частичные индексы (Partial Indexes)**
Индекс, охватывающий только строки, удовлетворяющие заданному условию.

**Польза**:
- Меньший размер индекса, так как индексируется только часть данных.
- Быстрее обновляется, так как изменения в строках, не соответствующих условию, не затрагивают индекс.
- Идеально для полей с низкой селективностью (например, `status`, `is_deleted`), где обычный индекс был бы неэффективен.

**Индексы по выражениям (Expression/Functional Indexes)**
Индекс на результат функции или выражения, а не на сам столбец.
**Когда использовать**: Для запросов с выражениями, например, `WHERE lower(email) = 'test@example.com'`. Обычный индекс на `email` в таких случаях не сработает.
**Совет**: Убедитесь, что запрос точно повторяет выражение в индексе, иначе он не будет использован.

**Обслуживание индексов**
- **Раздувание (Bloat)**:
    - Удаление или обновление строк оставляет "мёртвые" записи в индексах, увеличивая их размер и снижая эффективность.
    - Раздувание замедляет поиск и увеличивает затраты на хранение.
- **VACUUM**:
    - Очищает мёртвые записи в таблицах и индексах.
    - **Autovacuum** автоматически запускается в PostgreSQL, но важно мониторить его настройки для больших таблиц.
    - Используйте `VACUUM FULL` для полной очистки, но это блокирует таблицу.
- **REINDEX**:
    - Перестраивает индекс, устраняя раздувание и восстанавливая эффективность.
    - Пример: `REINDEX INDEX idx_name;` или `REINDEX TABLE my_table;`.
    - Используйте с осторожностью, так как это может быть ресурсоёмкой операцией.
- **Совет**: Мониторьте раздувание с помощью `pgstattuple` или аналогичных расширений и регулярно выполняйте `VACUUM` и `REINDEX` для нагруженных баз.
