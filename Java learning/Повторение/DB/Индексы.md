#### Что такое индекс и зачем он нужен?

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81-%D0%B8-%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%BE%D0%BD-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD)

**Индекс** — это специальная структура данных, которая создаётся для ускорения поиска и обработки запросов в базе данных. Он хранит отсортированные значения одного или нескольких столбцов таблицы и указатели на соответствующие строки.

- **Аналогия**: Индекс похож на алфавитный указатель в книге. Без него поиск термина (например, в таблице с миллионом строк) требует полного просмотра всех данных (это **Full Table Scan** или **Seq Scan**). С индексом СУБД сразу находит нужные строки, как по указателю в книге.
- **Зачем нужен**: Ускоряет операции чтения (**SELECT**) с условиями (**WHERE**), объединениями (**JOIN**) и сортировкой (**ORDER BY**). Например, поиск по `WHERE user_id = 123` без индекса может быть медленным, а с индексом — почти мгновенным.

#### Главный компромисс (Trade-Off)

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BE%D0%BC%D0%BF%D1%80%D0%BE%D0%BC%D0%B8%D1%81%D1%81-trade-off)

Индексы — не бесплатное решение, они имеют свои издержки:

- **Ускорение чтения vs. замедление записи**:
    - Индексы значительно ускоряют **SELECT**, но замедляют операции **INSERT**, **UPDATE** и **DELETE**, так как СУБД должна обновлять не только таблицу, но и все связанные индексы.
    - Например, при добавлении новой строки в таблицу нужно также добавить её в каждый индекс, что требует дополнительных вычислений.
- **Затраты на хранение**: Индексы — это отдельные структуры, которые занимают место на диске. Чем больше индексов и чем шире индексируемые столбцы, тем больше дискового пространства требуется.
- **Когда не нужны**: Если таблица редко используется для чтения или часто обновляется (например, логи операций), индексы могут быть неэффективны.

#### Базовый синтаксис

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B9-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81)

Создание и удаление индексов в SQL (на примере PostgreSQL):

- **Создание индекса**:
    
    ```sql
    CREATE INDEX my_idx ON my_table (my_column);
    ```
    
    Создаёт индекс с именем `my_idx` для столбца `my_column` в таблице `my_table`.
- **Удаление индекса**:
    
    ```sql
    DROP INDEX my_idx;
    ```
    
    Удаляет индекс `my_idx`.

#### Типы индексов

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D1%82%D0%B8%D0%BF%D1%8B-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2)

- **B-Tree (B-дерево)**
    
    - **Как устроен**: Сбалансированное дерево с корневым узлом, промежуточными узлами и листовыми узлами, где хранятся пары `(ключ, указатель на строку)`. Это обеспечивает логарифмическую сложность поиска.
    - **Когда использовать**: Индекс по умолчанию, подходит для большинства сценариев. Эффективен для операций сравнения (`=`, `>`, `<`, `>=`, `<=`, `BETWEEN`, `IN`, `IS NULL`) и сортировки (`ORDER BY`). Также поддерживает `LIKE 'префикс%'` ( например, `LIKE 'abc%'`).
    - **Пример**: Индекс на столбец `user_id` для быстрого поиска пользователей по ID.
- **Hash**
    
    - **Как устроен**: Хеш-таблица, где значение преобразуется в хеш, а хеш указывает на строки. Компактнее B-Tree, но менее универсален.
    - **Когда использовать**: Только для операций точного равенства (`=`). Подходит для столбцов с высокой селективностью, где не нужны диапазонные запросы. В PostgreSQL до версии 10 были проблемы с надёжностью, но теперь они решены. Однако B-Tree чаще предпочтительнее.
    - **Пример**: Индекс на `email` для точного поиска.
- **GIN (Generalized Inverted Index)**
    
    - **Как устроен**: Инвертированный индекс, где хранится `(значение -> список строк)`, а не `(строка -> значение)`. Это идеально для данных, где одно значение связано с множеством строк.
    - **Когда использовать**: Для сложных типов данных:
        - Полнотекстовый поиск с `tsvector` (например, поиск по ключевым словам в тексте).
        - Массивы (операторы `@>`, `<@`, `&&`, например, поиск по тегам).
        - JSONB (операторы `?`, `?|`, `?&`, `@>`, например, поиск в JSON-полях).
    - **Пример**: Индекс на `tags` (массив) для поиска записей с определёнными тегами.
- **GiST (Generalized Search Tree)**
    
    - **Как устроен**: Гибкое дерево, группирующее "похожие" значения. Позволяет индексировать сложные типы данных, учитывая их семантическую "близость".
    - **Когда использовать**: Для данных, где важны геометрические или логические отношения:
        - Геометрические типы (поиск пересекающихся фигур, например, полигонов).
        - Полнотекстовый поиск (в некоторых случаях).
        - Данные с "пересечением" (например, диапазоны времени).
    - **Пример**: Индекс на поле `geometry` для поиска объектов в заданной области.
- **BRIN (Block Range Index)**
    
    - **Как устроен**: Лёгкий индекс, хранящий минимальное и максимальное значение для диапазонов физических блоков таблицы. Занимает мало места, но менее точен.
    - **Когда использовать**: Для очень больших таблиц с естественным порядком данных (например, временные метки или автоинкрементные ID). Эффективен, если данные физически упорядочены (например, новые записи добавляются в конец).
    - **Пример**: Индекс на `created_at` в таблице логов для фильтрации по датам.

#### Селективность (Selectivity)

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D1%81%D0%B5%D0%BB%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D1%81%D1%82%D1%8C-selectivity)

- **Что это**: Показатель уникальности значений в столбце. Чем выше селективность, тем эффективнее индекс.
    - **Высокая селективность**: Значения почти уникальны (например, `id`, `email`). Индексы B-Tree или Hash на таких столбцах очень эффективны, так как возвращают мало строк.
    - **Низкая селективность**: Мало уникальных значений (например, `пол` или `is_deleted`). Индексы на таких столбцах часто бесполезны, так как планировщик запросов предпочтёт **Seq Scan** (полный просмотр таблицы).
- **Почему важно**: Планировщик PostgreSQL оценивает селективность, чтобы решить, использовать индекс или нет. Например, индекс на булево поле `is_active` (true/false) редко будет полезен, если половина строк имеет значение `true`.

#### Составные (многоколоночные) индексы

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D1%81%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BA%D0%BE%D0%BB%D0%BE%D0%BD%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B)

- **Что это**: Индекс, охватывающий несколько столбцов.
    
    ```sql
    CREATE INDEX idx_users_name ON users (last_name, first_name);
    ```
    
- **Особенности**:
    - **Порядок столбцов важен**: Индекс `(A, B)` эффективен для запросов `WHERE A = ?`, `WHERE A = ? AND B = ?`, но не для `WHERE B = ?`, так как индекс строится по `A` в первую очередь.
    - Используется для запросов с фильтрацией, сортировкой или объединением по нескольким столбцам.
- **Пример**: Для запроса `SELECT * FROM users WHERE last_name = 'Smith' AND first_name = 'John'` индекс `(last_name, first_name)` будет оптимален.
- **Совет**: Размещайте в начале столбцы с более высокой селективностью или те, которые чаще используются в фильтрах.
- **Важен порядок колонок**: Порядок важен потому что, при доступе мы сначала сортируем по первой колонке, а потом только по второй. При доступе только по первой колонке, индекс сможет увидеть данные и они будут находиться близко друг к другу. При доступе только во второй колонке, данные будут находится в разных блоках и непонятно где, поэтому это не эффективно и оптимизатор не возьмёт его.

#### Кластерный индекс

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B9-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81)

- **Что это**: В PostgreSQL нет "кластерного индекса" в классическом смысле (как в SQL Server), но есть команда `CLUSTER`, которая физически переупорядочивает строки таблицы в порядке указанного индекса.
- **Как работает**:
    - `CLUSTER my_table USING my_idx;` сортирует строки таблицы по индексу `my_idx`.
    - Улучшает производительность для запросов, читающих данные в порядке индекса, за счёт минимизации дисковых операций.
- **Ограничения**: Таблица не остаётся кластеризованной навсегда — новые вставки/обновления нарушают порядок. Требуется периодический вызов `CLUSTER`.
- **Пример**: Подходит для таблиц, где данные часто читаются в порядке определённого столбца, например, `created_at`.

#### Покрывающие индексы (Covering Indexes) и Index-Only Scans

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D0%BF%D0%BE%D0%BA%D1%80%D1%8B%D0%B2%D0%B0%D1%8E%D1%89%D0%B8%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B-covering-indexes-%D0%B8-index-only-scans)

- **Index-Only Scan**: Самый быстрый способ чтения, когда PostgreSQL получает все данные из индекса, не обращаясь к таблице (heap).
- **Клауза `INCLUDE`**:
    
    ```sql
    CREATE INDEX idx_my_table ON my_table (col_a) INCLUDE (col_b, col_c);
    ```
    
    - `col_a`: ключ для поиска и сортировки.
    - `col_b`, `col_c`: дополнительные столбцы, хранящиеся в листовых узлах индекса для поддержки Index-Only Scan. Они не участвуют в структуре дерева.
- **Когда использовать**: Если запрос запрашивает только столбцы, входящие в индекс ( например, `SELECT col_a, col_b FROM my_table WHERE col_a = 42`).
- **Польза**: Ускоряет запросы, минимизируя доступ к таблице, особенно для больших таблиц.

#### Частичные индексы (Partial Indexes)

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D1%87%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B-partial-indexes)

- **Что это**: Индекс, охватывающий только строки, удовлетворяющие заданному условию.
    
    ```sql
    CREATE INDEX idx_completed_orders ON orders (order_id) WHERE status = 'completed';
    ```
    
- **Польза**:
    - Меньший размер индекса, так как индексируется только часть данных.
    - Быстрее обновляется, так как изменения в строках, не соответствующих условию, не затрагивают индекс.
    - Идеально для полей с низкой селективностью (например, `status`, `is_deleted`), где обычный индекс был бы неэффективен.
- **Пример**: Запрос `SELECT * FROM orders WHERE status = 'completed' AND order_id = 123` использует частичный индекс, ускоряя выполнение.

#### Индексы по выражениям (Expression/Functional Indexes)

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B-%D0%BF%D0%BE-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC-expressionfunctional-indexes)

- **Что это**: Индекс на результат функции или выражения, а не на сам столбец.
    
    ```sql
    CREATE INDEX idx_lower_email ON users (lower(email));
    ```
    
- **Когда использовать**: Для запросов с выражениями, например, `WHERE lower(email) = 'test@example.com'`. Обычный индекс на `email` в таких случаях не сработает.
- **Пример**: Индекс на `upper(name)` для регистронезависимого поиска или на `date_trunc('day', created_at)` для группировки по дням.
- **Совет**: Убедитесь, что запрос точно повторяет выражение в индексе, иначе он не будет использован.

#### Обслуживание индексов

[](https://github.com/vvvxd/java-questions/blob/master/Databases/PostgreSql.md#%D0%BE%D0%B1%D1%81%D0%BB%D1%83%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2)

- **Раздувание (Bloat)**:
    - Удаление или обновление строк оставляет "мёртвые" записи в индексах, увеличивая их размер и снижая эффективность.
    - Раздувание замедляет поиск и увеличивает затраты на хранение.
- **VACUUM**:
    - Очищает мёртвые записи в таблицах и индексах.
    - **Autovacuum** автоматически запускается в PostgreSQL, но важно мониторить его настройки для больших таблиц.
    - Используйте `VACUUM FULL` для полной очистки, но это блокирует таблицу.
- **REINDEX**:
    - Перестраивает индекс, устраняя раздувание и восстанавливая эффективность.
    - Пример: `REINDEX INDEX idx_name;` или `REINDEX TABLE my_table;`.
    - Используйте с осторожностью, так как это может быть ресурсоёмкой операцией.
- **Совет**: Мониторьте раздувание с помощью `pgstattuple` или аналогичных расширений и регулярно выполняйте `VACUUM` и `REINDEX` для нагруженных баз.
