
**Индекс** — это специальная структура данных, которая создаётся для ускорения поиска и обработки запросов в базе данных. Он хранит отсортированные значения одного или нескольких столбцов таблицы и указатели на соответствующие строки.

Индексы — не бесплатное решение, они имеют свои издержки:
**Ускорение чтения vs. замедление записи**:
- Индексы значительно ускоряют **SELECT**, но замедляют операции **INSERT**, **UPDATE** и **DELETE**, так как СУБД должна обновлять не только таблицу, но и все связанные индексы.
Индексы — это отдельные структуры, которые занимают место на диске. Чем больше индексов и чем шире индексируемые столбцы, тем больше дискового пространства требуется.


**B-Tree (B-дерево)**
- **Как устроен**: Сбалансированное дерево с корневым узлом, промежуточными узлами и листовыми узлами, где хранятся пары `(ключ, указатель на строку)`. Это обеспечивает логарифмическую сложность поиска.
- **Когда использовать**: Индекс по умолчанию, подходит для большинства сценариев. Эффективен для операций сравнения (`=`, `>`, `<`, `>=`, `<=`, `BETWEEN`, `IN`, `IS NULL`) и сортировки (`ORDER BY`). Также поддерживает `LIKE 'префикс%'` ( например, `LIKE 'abc%'`).

**Hash**
- **Как устроен**: Хеш-таблица, где значение преобразуется в хеш, а хеш указывает на строки. Компактнее B-Tree, но менее универсален.
- **Когда использовать**: Только для операций точного равенства (`=`). Подходит для столбцов с высокой селективностью, где не нужны диапазонные запросы. В PostgreSQL до версии 10 были проблемы с надёжностью, но теперь они решены. Однако B-Tree чаще предпочтительнее.

**GIN (Generalized Inverted Index)**
- **Как устроен**: Инвертированный индекс, где хранится `(значение -> список строк)`, а не `(строка -> значение)`. Это идеально для данных, где одно значение связано с множеством строк.
- **Когда использовать**: Для сложных типов данных:
    - Полнотекстовый поиск с `tsvector` (например, поиск по ключевым словам в тексте).
    - Массивы (операторы `@>`, `<@`, `&&`, например, поиск по тегам).
    - JSONB (операторы `?`, `?|`, `?&`, `@>`, например, поиск в JSON-полях).

**GiST (Generalized Search Tree)**
    
- **Как устроен**: Гибкое дерево, группирующее "похожие" значения. Позволяет индексировать сложные типы данных, учитывая их семантическую "близость".
- **Когда использовать**: Для данных, где важны геометрические или логические отношения:
    - Геометрические типы (поиск пересекающихся фигур, например, полигонов).
    - Полнотекстовый поиск (в некоторых случаях).
    - Данные с "пересечением" (например, диапазоны времени).

**BRIN (Block Range Index)**
- **Как устроен**: Лёгкий индекс, хранящий минимальное и максимальное значение для диапазонов физических блоков таблицы. Занимает мало места, но менее точен.
- **Когда использовать**: Для очень больших таблиц с естественным порядком данных (например, временные метки или автоинкрементные ID). Эффективен, если данные физически упорядочены (например, новые записи добавляются в конец).


**Составные (многоколоночные) индексы**
Индекс, охватывающий несколько столбцов.
**Особенности**:
- **Порядок столбцов важен**: Индекс `(A, B)` эффективен для запросов `WHERE A = ?`, `WHERE A = ? AND B = ?`, но не для `WHERE B = ?`, так как индекс строится по `A` в первую очередь.
- Используется для запросов с фильтрацией, сортировкой или объединением по нескольким столбцам.
Размещайте в начале столбцы с более высокой селективностью или те, которые чаще используются в фильтрах. Порядок важен потому что, при доступе мы сначала сортируем по первой колонке, а потом только по второй. При доступе только по первой колонке, индекс сможет увидеть данные и они будут находиться близко друг к другу. При доступе только во второй колонке, данные будут находится в разных блоках и непонятно где, поэтому это не эффективно и оптимизатор не возьмёт его.

 **Кластерный индекс**
 В PostgreSQL нет "кластерного индекса" в классическом смысле (как в SQL Server), но есть команда `CLUSTER`, которая физически переупорядочивает строки таблицы в порядке указанного индекса.
 Таблица не остаётся кластеризованной навсегда — новые вставки/обновления нарушают порядок. Требуется периодический вызов `CLUSTER`.

 **Покрывающие индексы (Covering Indexes) и Index-Only Scans**

**Index-Only Scan**: Самый быстрый способ чтения, когда PostgreSQL получает все данные из индекса, не обращаясь к таблице (heap).
**Когда использовать**: Если запрос запрашивает только столбцы, входящие в индекс ( например, `SELECT col_a, col_b FROM my_table WHERE col_a = 42`).
**Польза**: Ускоряет запросы, минимизируя доступ к таблице, особенно для больших таблиц.

**Частичные индексы (Partial Indexes)**
Индекс, охватывающий только строки, удовлетворяющие заданному условию.

**Польза**:
- Меньший размер индекса, так как индексируется только часть данных.
- Быстрее обновляется, так как изменения в строках, не соответствующих условию, не затрагивают индекс.
- Идеально для полей с низкой селективностью (например, `status`, `is_deleted`), где обычный индекс был бы неэффективен.

**Индексы по выражениям (Expression/Functional Indexes)**
Индекс на результат функции или выражения, а не на сам столбец.
**Когда использовать**: Для запросов с выражениями, например, `WHERE lower(email) = 'test@example.com'`. Обычный индекс на `email` в таких случаях не сработает.
**Совет**: Убедитесь, что запрос точно повторяет выражение в индексе, иначе он не будет использован.

**Обслуживание индексов**
- **Раздувание (Bloat)**:
    - Удаление или обновление строк оставляет "мёртвые" записи в индексах, увеличивая их размер и снижая эффективность.
    - Раздувание замедляет поиск и увеличивает затраты на хранение.
- **VACUUM**:
    - Очищает мёртвые записи в таблицах и индексах.
    - **Autovacuum** автоматически запускается в PostgreSQL, но важно мониторить его настройки для больших таблиц.
    - Используйте `VACUUM FULL` для полной очистки, но это блокирует таблицу.
- **REINDEX**:
    - Перестраивает индекс, устраняя раздувание и восстанавливая эффективность.
    - Пример: `REINDEX INDEX idx_name;` или `REINDEX TABLE my_table;`.
    - Используйте с осторожностью, так как это может быть ресурсоёмкой операцией.
- **Совет**: Мониторьте раздувание с помощью `pgstattuple` или аналогичных расширений и регулярно выполняйте `VACUUM` и `REINDEX` для нагруженных баз.
