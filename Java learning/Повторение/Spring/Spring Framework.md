# IOC
IoC (Inversion of Control, Инверсия управления) — это принцип проектирования в программировании, при котором управление созданием, конфигурацией и жизненным циклом объектов (или компонентов) передается от самого объекта внешнему контейнеру или фреймворку. В контексте Spring Framework IoC является одной из ключевых концепций.
# Виды IOC

Внедрение зависимости (Dependency injection, DI) — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

Dependency Lookup  — это шаблон проектирования, в котором компоненты активно запрашивают свои зависимости из центрального реестра или контейнера при необходимости.

# IoC-контейнер

Это программный компонент или фреймворк, реализующий принцип **инверсии управления (IoC)**. Он отвечает за управление объектами (их создание, конфигурация, связывание зависимостей и жизненный цикл) в приложении, позволяя разработчику сосредоточиться на бизнес-логике, а не на инфраструктурных задачах.
# Spring IoC

Центральной частью Spring является подход Inversion of Control, который позволяет конфигурировать и управлять объектами Java с помощью рефлексии. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это посредством контейнера. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.

Объекты, создаваемые контейнером, также называются управляемыми объектами (beans). Обычно, конфигурирование контейнера, осуществляется путём внедрения аннотаций (начиная с 5 версии J2SE), но также, есть возможность, по старинке, загрузить XML-файлы, содержащие определение bean'ов и предоставляющие информацию, необходимую для создания bean'ов.

# Типы DI

DI можно делать через: 
- Поля класса 
- Сеттеры 
- Конструкторы

# Self autowired

Для реализации self-injection необходимо добавить аннотацию @Lazy, которая внедрит бин только при первом обращении.

# Primary и Qualifaer

@Primary - Помечает один из бинов как **основной** или **предпочтительный**.
@Qualifier("имя_бина") -  Позволяет **явно указать**, какой именно бин внедрить, по его имени.
# Поведение аннотации @Autowired

1. Контейнер определяет тип объекта для внедрения
2. Контейнер ищет бины в контексте(он же контейнер), которые соответствуют нужному типу
3. Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он
4. Если используется аннотации @Autowire + Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять
5. В противном случае контейнер попытается внедрить компонент, основываясь на его имени или ID
6. Если ни один из способов не сработал, то будет выброшено исключение

Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.

Если внедряемый объект массив, коллекция, или map с дженериком, то Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map ключом будет имя бина. //параметр указывает, требуется ли DI @Authowired(required = true/false)

# Основные части Spring Framework

1. Bean Definition - это набор метаданных будущего бина, макет, по которому нужно будет создавать бин в случае необходимости. То есть для каждого бина создается свой объект BeanDefinition, в котором хранится описание того, как создавать и управлять этим конкретным бином. Проще говоря, сколько бинов в программе - столько и объектов BeanDefinition, их описывающих.
2. BeanFactoryPostProcessor -  специальный интерфейс, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять. В этом интерфейсе всего один метод -  postProcessBeanFactory.
3. ApplicationContextAware - это интерфейс обратного вызова (callback interface) из пакета `org.springframework.beans.factory`, который позволяет бину получить ссылку на `ApplicationContext`, в котором он был создан.
4. BeanFactory -  это не класс, а **интерфейс**. Это его первое и самое важное архитектурное свойство. Он определяет **минимальный контракт**, который должен выполнить любой контейнер, желающий называться IoC-контейнером в экосистеме Spring.
5. BeanPostProcessor - позволяет вклиниться в процесс настройки наших бинов до того, как они попадут в контейнер. ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и помечает их как "post-processors" для того, чтобы создать их определенным способом
6. ApplicationContext -  это центральный и наиболее важный интерфейс в Spring Framework. Его можно рассматривать как **командный центр** или **оркестратор** вашего приложения. Архитектурно, он является наследником интерфейса `BeanFactory`, что означает, что он включает в себя все базовые возможности по созданию бинов и внедрению зависимостей, но при этом расширяет их огромным количеством высокоуровневых функций, необходимых для построения современных enterprise-приложений.
7. ApplicationListener - Он умеет слушать контекст Spring, все "events", которые с ним происходят. Работает на этапе, когда все уже создано. Также он имеет дженерики <>, в которых мы можем указать что конкретно мы хотим слушать. Обозначается аннотацией @EventListener. — contextStartedEvent — контекст начал свое построение (не построился, а только начал) — contextRefreshedEvent — когда контекст заканчивает свое построение, он всегда делает refresh. — contextStoppedEvent — contextClosedEvent
8. EventListener - это мощный механизм в Spring, основанный на паттерне "Издатель-подписчик" (Publisher-Subscriber). Он позволяет компонентам вашего приложения общаться друг с другом, не имея прямых ссылок друг на друга, что значительно **уменьшает связанность (decoupling)** кода.

# ApplicationContext vs BeanFactory

| Характеристика             | `BeanFactory`                                                              | `ApplicationContext`                                                   |
| :------------------------- | :------------------------------------------------------------------------- | :--------------------------------------------------------------------- |
| **Основная роль**          | Низкоуровневый IoC-контейнер.                                              | Высокоуровневый, полнофункциональный фреймворк.                        |
| **Отношение**              | Базовый интерфейс.                                                         | **Наследует и расширяет** `BeanFactory`.                               |
| **Инициализация бинов**    | **Ленивая (Lazy)** по умолчанию.                                           | **Немедленная (Eager)** по умолчанию для `singleton`.                  |
| **Автоматизация**          | Требует ручной регистрации расширений (`...PostProcessor`'ов).             | **Автоматически** находит и регистрирует расширения.                   |
| **Функциональность**       | Только базовый DI и управление жизненным циклом.                           | Поддержка **AOP, событий, i18n, загрузки ресурсов** и многого другого. |
| **Типичное использование** | Практически не используется напрямую. Важен для понимания "внутренностей". | **Стандарт де-факто** для всех современных Spring-приложений.          |


# Типы контекстов
- `ClassPathXmlApplicationContext`: Загружает контекст из XML-файлов, находящихся в classpath.
- `FileSystemXmlApplicationContext`: Загружает контекст из XML-файлов в файловой системе.
- **`AnnotationConfigApplicationContext`**: Наиболее современный и популярный вариант. Создает контекст на основе Java-классов, помеченных аннотациями `@Configuration` и `@Component`. Именно он лежит в основе Spring Boot.
- **`AnnotationConfigWebApplicationContext`**: Веб-версия предыдущего для приложений на основе Java-конфигурации.

# Жизненный цикл работы Spring IOC.

![[Pasted image 20250827122158.png]]

**Этапы инициализации контекста Spring**

1. Парсирование конфигурации и создание BeanDefinition
2. Настройка созданных BeanDefinition
3. Создание кастомных FactoryBean (только для XML-конфигурации)
4. Создание экземпляров бинов
5. Настройка созданных бинов
6. Бины готовы к использованию
7. Закрытие контекста
   
**Этап Парсирование конфигурации и создание BeanDefinition**

Цель первого этапа — это создание всех BeanDefinition. Объекты BeanDefinition — это набор метаданных будущего бина, макет, по которому нужно будет создавать бин в случае необходимости. То есть для каждого бина создается свой объект BeanDefinition, в котором хранится описание того, как создавать и управлять этим конкретным бином. Проще говоря, сколько бинов в программе - столько и объектов BeanDefinition, их описывающих.

BeanDefinition содержат (среди прочего) следующие метаданные:

1. Имя класса с указанием пакета: обычно это фактический класс бина.
2. Элементы поведенческой конфигурации бина, которые определяют, как бин должен вести себя в контейнере (scope, обратные вызовы жизненного цикла и т.д.).
3. Ссылки на другие bean-компоненты, которые необходимы для его работы. Эти ссылки также называются зависимостями.
4. Другие параметры конфигурации для установки во вновь созданном объекте - например, ограничение размера пула или количество соединений, используемых в бине, который управляет пулом соединений.

Эти метаданные преобразуются в набор свойств, которые составляют каждое BeanDefinition.
При конфигурации через аннотации с указанием пакета для сканирования или JavaConfig используется класс AnnotationConfigApplicationContext.

Если заглянуть во внутрь AnnotationConfigApplicationContext, то можно увидеть два поля. private final AnnotatedBeanDefinitionReader reader; private final ClassPathBeanDefinitionScanner scanner;
ClassPathBeanDefinitionScanner сканирует указанный пакет на наличие классов помеченных аннотацией @Component (или любой другой аннотацией которая включает в себя @Component). Найденные классы парсируются и для них создаются BeanDefinition.Чтобы сканирование было запущено, в конфигурации должен быть указан пакет для сканирования. @ComponentScan({"package.name"})
AnnotatedBeanDefinitionReader работает в несколько этапов. Первый этап — это регистрация всех @Configuration для дальнейшего парсирования. Если в конфигурации используются Conditional, то будут зарегистрированы только те конфигурации, для которых Condition вернет true.

Второй этап — это регистрация специального BeanFactoryPostProcessor, а именно BeanDefinitionRegistryPostProcessor, который при помощи класса ConfigurationClassParser парсирует JavaConfig и создает BeanDefinition, создаёт граф зависимостей (между бинами) и создаёт:
Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);
в которой хранятся все описания бинов, обнаруженных в ходе парсинга конфигурации.

**Этап Настройка созданных BeanDefinition**

После первого этапа у нас имеется Map, в котором хранятся BeanDefinition. Архитектура спринга построена таким образом, что у нас есть возможность повлиять на то, какими будут наши бины еще до их фактического создания, иначе говоря мы имеем доступ к метаданным класса. Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять. В этом интерфейсе всего один метод.

Давайте разберем одну из родных реализаций интерфейса BeanFactoryPostProcessor. Обычно, настройки подключения к базе данных выносятся в отдельный property файл, потом при помощи PropertySourcesPlaceholderConfigurer они загружаются и делается inject этих значений в нужное поле. Так как inject делается по ключу, то до создания экземпляра бина нужно заменить этот ключ на само значение из property файла. Эта замена происходит в классе, который реализует интерфейс BeanFactoryPostProcessor. Название этого класса — PropertySourcesPlaceholderConfigurer.

![[Pasted image 20250827122232.png]]

**Этап Создание экземпляров бинов**

Сначала BeanFactory из коллекции Map с объектами BeanDefinition вначале достает определения этих BeanPostProcessor-ов, создает их и кладет в сторону, т.е. в первую очередь он создаст те бины, которые имплементируют интерфейс BeanPostProcessor и с их помощью будет потом настраивать все остальные бины. Создаются экземпляры бинов через BeanFactory на основе ранее созданных BeanDefinition

![[Pasted image 20250827122301.png]]

**Этап Настройка созданных бинов**

На данном этапе бины уже созданы, мы можем лишь их донастроить.

Интерфейс BeanPostProcessor позволяет вклиниться в процесс настройки наших бинов до того, как они попадут в контейнер. ApplicationContext автоматически обнаруживает любые бины с реализацией BeanPostProcessor и помечает их как "post-processors" для того, чтобы создать их определенным способом. Например, в Spring есть реализации BeanPostProcessor-ов, которые обрабатывают аннотации @Autowired, @Inject, @Value и @Resource.

Интерфейс несет в себе несколько методов.

Оба метода вызываются для каждого бина. У обоих методов параметры абсолютно одинаковые. Разница только в порядке их вызова. Первый вызывается до init-метода, воторой, после. Важно понимать, что на данном этапе экземпляр бина уже создан и идет его донастройка.

Тут есть два важных момента:

1. Оба метода в итоге должны вернуть бин. Если в методе вы вернете null, то при получении этого бина из контекста вы получите null, а поскольку через бинпостпроцессор проходят все бины, после поднятия контекста, при запросе любого бина вы будете получать фиг, в смысле null.
2. Если вы хотите сделать прокси над вашим объектом (аспекты, транзакции, и т.д. — некая бизнес логика), то имейте ввиду, что это принято делать после вызова init метода, иначе говоря это нужно делать в методе postProcessAfterInitialization.
3. Если нужно заполнить бины через маркерные интерфейсы или настраивает объект, реализовывают метод postProcessBeforeInitialization (Object bean, String beanName),

Прокси — это класс-декорация над бином. Например, мы хотим добавить логику нашему бину, но джава-код уже скомпилирован, поэтому нам нужно на лету сгенерировать новый класс. Этим классом мы должны заменить оригинальный класс так, чтобы никто не заметил подмены.

Есть два варианта создания этого класса:

1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику;
2. либо он должен имплементировать те же самые интерфейсы, что и первый класс(Dynamic Proxy).

По конвенции спринга, если какой-то из BeanPostProcessor-ов меняет что-то в классе, то он должен это делать на этапе postProcessAfterInitialization(). Таким образом мы уверены, что initMethod у данного бина, работает на оригинальный метод, до того, как на него накрутился прокси.
Но даже после этого мы можем донастроить наши бины ApplicationListener-ами.

![[Pasted image 20250827122314.png]]

**Этап Бины готовы к использованию**

Их можно получить с помощью метода ApplicationContext#getBean().

**Этап Закрытие контекста**

Когда контекст закрывается (метод close() из ApplicationContext), бин уничтожается. Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод. Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy() - не рекомендуется к использованию как устаревший. Если в аннотации @Bean определен метод destroyMethod, то будет вызван и он.


# Bean

Термин бин (англ. Bean) - в Spring используется для ссылки на любой компонент, управляемый контейнером. Обычно бины на определенном уровне придерживаются спецификации JavaBean, но это не обязательно особенно если для связывания бинов друг с другом планируется применять Constructor Injection. Для получения экземпляра бина используется ApplicationContext. IoC контейнер управляет жизненным циклом спринг бина, областью видимости и внедрением.

# Типы скоупов

**Scope `singleton`**
Это область видимости **по умолчанию**. В рамках одного Spring IoC-контейнера создается **только один экземпляр** этого бина.
1. При запуске `ApplicationContext` Spring создает все `singleton`-бины (если не настроена ленивая инициализация).
2. Каждый созданный экземпляр помещается во внутренний кэш, который часто называют "singleton cache" (обычно это `ConcurrentHashMap`, где ключ — имя бина, а значение — сам объект).
3. При любом последующем запросе на этот бин (через внедрение зависимости или `context.getBean()`) Spring не создает новый объект, а просто возвращает ссылку на тот же самый экземпляр из кэша.
Идеально для **stateless** (не хранящих состояние) компонентов: сервисов, репозиториев, контроллеров, конфигурационных классов.

**Scope `prototype`**
Каждый раз, когда запрашивается бин этого типа, Spring создает **совершенно новый экземпляр**.
1. Spring не создает экземпляр этого бина при старте. Он только хранит его "рецепт" (`BeanDefinition`).
2. Когда поступает запрос на бин (через внедрение или `context.getBean()`), Spring использует "рецепт" для создания нового экземпляра (`new MyPrototypeBean(...)`), выполняет внедрение зависимостей в него и вызывает методы инициализации (`@PostConstruct`).
3. После этого Spring **отдает бин и больше не управляет им**.
Для **stateful** (хранящих состояние) объектов, где каждый клиент или поток должен иметь свой собственный, независимый экземпляр. Например, объект "строитель" (Builder), или объект, хранящий состояние какой-то сложной, многошаговой операции.

**Scope `request`**
Создается один экземпляр бина на **каждый HTTP-запрос**.
1. Когда в `DispatcherServlet` приходит новый HTTP-запрос, Spring создает новый экземпляр этого бина.
2. Этот экземпляр сохраняется как атрибут текущего HTTP-запроса (`HttpServletRequest`).
3. Все обращения к этому бину в рамках обработки **одного и того же запроса** будут возвращать тот же самый экземпляр.
4. Когда обработка запроса завершена и ответ отправлен клиенту, бин уничтожается, и для него вызываются методы `@PreDestroy`.
Для хранения данных, специфичных для одного запроса. Например, данные аутентифицированного пользователя на время запроса, отслеживание какой-либо информации в рамках одной операции.

**Scope `session`**
Создается один экземпляр бина на **каждую HTTP-сессию** пользователя.
1. При первом обращении к бину в рамках новой сессии Spring создает его экземпляр.
2. Этот экземпляр сохраняется как атрибут `HttpSession`.
3. Бин живет до тех пор, пока живет сессия (например, до тайм-аута или явного вызова `session.invalidate()`).
4. Когда сессия уничтожается, бин также уничтожается, и вызывается его `@PreDestroy`.
Идеально подходит для объектов, хранящих состояние пользователя между запросами. Классический пример — **корзина покупок** в интернет-магазине.

**Scope `application`**
Создается один экземпляр бина на весь жизненный цикл `ServletContext` (то есть на все веб-приложение). Очень похоже на `singleton`, но бин хранится как атрибут `ServletContext`. Это гарантирует, что он будет единственным на все приложение, включая все сервлеты и фильтры. На практике разница с `singleton` минимальна и проявляется в очень сложных конфигурациях с несколькими `ApplicationContext`.
Используется для глобальных данных приложения, которые должны быть доступны всем пользователям и всем сессиям. Например, кэш редко изменяемых данных (список стран, глобальные настройки).


# Жизненный цикл бина

![[Pasted image 20250827120436.png]]

# Внедрение одного scope в другой.

| Внешний бин (Container) | Внутренний бин (Injected) | Поведение и результат                                                                                               |
| :---------------------- | :------------------------ | :------------------------------------------------------------------------------------------------------------------ |
| **`singleton`**         | `singleton`               | **OK.** Стандартный случай.                                                                                         |
| **`singleton`**         | `prototype`               | Внедряется только один раз. **Решение:** использовать `@Lookup` или `ObjectFactory`.                                |
| **`singleton`**         | `request` / `session`     | **OK (автоматически).** Spring внедряет специальный **прокси**, который находит нужный бин в текущем веб-контексте. |
| **`prototype`**         | `singleton`               | **OK.** Каждый новый `prototype` получает ссылку на один и тот же `singleton`.                                      |
| **`prototype`**         | `prototype`               | **OK.** Каждый новый `prototype` получает свой собственный, новый `prototype`-зависимость.                          |
| **`request`**           | `singleton`               | **OK.** `Request`-бин получает ссылку на общий `singleton`.                                                         |
| **`request`**           | `session`                 | **OK.** `Request`-бин получает доступ к бину из текущей сессии (через прокси).                                      |

# @component, service, controller, repository

| Аннотация             | Слой приложения                   | Предназначение                                 | Дополнительное поведение Spring                                                                                     |
| :-------------------- | :-------------------------------- | :--------------------------------------------- | :------------------------------------------------------------------------------------------------------------------ |
| **`@Component`**      | Любой                             | Универсальный, базовый компонент.              | Нет. Просто регистрирует бин.                                                                                       |
| **`@Controller`**     | **Представление (Presentation)**  | Обработка HTTP-запросов в Spring MVC.          | **Да.** Позволяет использовать `@RequestMapping` и другие аннотации для маппинга запросов.                          |
| **`@RestController`** | **Представление (Presentation)**  | Создание REST API.                             | **Да.** Комбинация `@Controller` + `@ResponseBody`.                                                                 |
| **`@Service`**        | **Бизнес-логика (Service)**       | Содержит основную бизнес-логику.               | **Нет (но семантически важно).** Четко обозначает роль класса. Может использоваться для AOP-конфигураций.           |
| **`@Repository`**     | **Доступ к данным (Persistence)** | Работа с хранилищем данных (БД, файлы и т.д.). | **Да, ключевое!** Включает **трансляцию платформо-специфичных исключений** в единую иерархию `DataAccessException`. |

# Основные AnnotationProcessor

**`AutowiredAnnotationBeanPostProcessor`**
Это, пожалуй, самый важный пост-процессор для современного Spring. Он отвечает за **внедрение зависимостей (Dependency Injection)**. Сканирует бины на наличие аннотаций `@Autowired`, `@Value` и `@Inject` (из JSR-330). После создания бина он находит поля, конструкторы или методы, помеченные этими аннотациями, и "внедряет" в них соответствующие зависимости (другие бины или значения из конфигурационных файлов).

**`CommonAnnotationBeanPostProcessor`**
Этот процессор обрабатывает стандартные аннотации из Java (JSR-250), обеспечивая интеграцию с общими практиками Java EE. Обрабатывает аннотации `@PostConstruct`, `@PreDestroy` и `@Resource`.

**`AnnotationAwareAspectJAutoProxyCreator`**
Этот мощный пост-процессор является основой для **аспектно-ориентированного программирования (AOP)** в Spring. Он проверяет каждый бин и, если находит подходящие аспекты (`@Aspect`), оборачивает исходный бин в **прокси-объект**.

**`BeanValidationPostProcessor`**
Отвечает за интеграцию механизма валидации (JSR-380/Bean Validation) в Spring. 
Автоматически валидирует бины, помеченные аннотациями валидации (например, `@NotNull`, `@Size`, `@Email`), если они также помечены аннотацией `@Validated`.

**`ApplicationContextAwareProcessor`**
Это более простой, но полезный процессор для предоставления бинам доступа к самому контексту приложения. Проверяет, реализует ли бин один из "Aware"-интерфейсов (например, `ApplicationContextAware`, `BeanFactoryAware`, `EnvironmentAware`).
# Профили

Представьте, что у вашего телефона есть разные режимы: "Обычный", "На работе", "За рулем". В каждом режиме меняются настройки: громкость, уведомления, доступные приложения.
**Профили в Spring — это то же самое, но для вашего приложения.** Это механизм, который позволяет активировать разные наборы бинов и конфигураций в зависимости от окружения, в котором запускается приложение.
Проще говоря, профиль — это **метка** для ваших конфигураций. Вы можете сказать Spring: "Эту конфигурацию базы данных используй только для профиля `prod` (production), а вот эту, с базой данных в памяти, — для профиля `dev` (development)".

# Conditional
Часто бывает полезно включить или отключить весь класс `@Configuration`, `@Component` или отдельные методы `@Bean` в зависимости от каких-либо условий.

Аннотация `@Conditional` — это мета-аннотация, которая позволяет создавать более специализированные условные аннотации. Она указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют.

Может применяться:

- Над классами, прямо или косвенно аннотированными `@Component`, включая классы `@Configuration`;
- Над методами `@Bean`;
- Как мета-аннотация при создании наших собственных аннотаций-условий.

Условия проверяются непосредственно перед тем, как должно быть зарегистрировано `BeanDefinition` компонента, и они могут помешать регистрации данного `BeanDefinition`. Поэтому нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами (которых еще не существует), с их `BeanDefinition`-ами можно.

**Условия, основанные на классах и бинах**
- **`@ConditionalOnClass`**: Условие выполняется, если указанные классы **присутствуют** в classpath.
- **`@ConditionalOnMissingClass`**: Условие выполняется, если указанные классы **отсутствуют** в classpath.
- **`@ConditionalOnBean`**: Условие выполняется, если бин указанного типа (или с указанным именем) **уже существует** в контексте.
- **`@ConditionalOnMissingBean`**: Условие выполняется, если бин указанного типа **еще не был определен** в контексте. Это ключевая аннотация для переопределения стандартного поведения.
- **`@ConditionalOnSingleCandidate`**: Более строгая версия `@ConditionalOnBean`. Условие выполняется, если в контексте есть ровно один бин-кандидат указанного типа (и он помечен как основной, если есть несколько).

 **Условия, основанные на конфигурации и окружении**
- **`@ConditionalOnProperty`**: Условие выполняется, если свойство в `Environment` (например, из `application.properties`) существует и/или имеет определенное значение. Очень гибкая: есть атрибуты `prefix`, `name`, `havingValue`, `matchIfMissing`.
- **`@ConditionalOnExpression`**: Условие выполняется, если указанное SpEL-выражение (Spring Expression Language) возвращает `true`. Это самый мощный и гибкий вариант, позволяющий писать сложную логику.

 Условия, основанные на ресурсах
- **`@ConditionalOnResource`**: Условие выполняется, если указанный ресурс (файл) существует в classpath ( например, `classpath:/my-config.xml`).

 **Условия, основанные на типе приложения**
- **`@ConditionalOnWebApplication`**: Условие выполняется, если приложение является веб-приложением (т.е. использует `WebApplicationContext`). Можно уточнить тип: `SERVLET` или `REACTIVE`.
- **`@ConditionalOnNotWebApplication`**: Противоположное условие. Для консольных приложений или обработчиков очередей.

# SpEL

**SpEL (Spring Expression Language)** — это мощный язык выражений, интегрированный в экосистему Spring. Он позволяет выполнять запросы и манипулировать графом объектов во время выполнения программы (at runtime).

Основное применение — получение и вычисление значений для конфигурации бинов, но его возможности гораздо шире.

Синтаксис выражений SpEL — `#{выражение}`. Это важно отличать от плейсхолдеров свойств `\${свойство}`, которые обрабатываются на более раннем этапе.

# Шаблоны

Chain of Responsibility - это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи. Ему Spring Security

Singleton (Одиночка) - Паттерн Singleton гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет предоставлять сервисы. Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр объекта на Spring IoC-контейнер. Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все последующие запросы и ссылки для этого бина получат кэшированный объект. Рекомендуется использовать область видимости singleton для бинов без состояния. Область видимости бина можно определить как singleton или как prototype (создаётся новый экземпляр при каждом запросе бина).

Model View Controller (Модель-Представление-Контроллер) - Преимущество Spring MVC в том, что ваши контроллеры являются POJO, а не сервлетами. Это облегчает тестирование контроллеров. Стоит отметить, что от контроллеров требуется только вернуть логическое имя представления, а выбор представления остаётся за ViewResolver. Это облегчает повторное использование контроллеров при различных вариантах представления.

Front Controller (Контроллер запросов) - Spring предоставляет DispatcherServlet, чтобы гарантировать, что входящий запрос будет отправлен вашим контроллерам.Паттерн Front Controller используется для обеспечения централизованного механизма обработки запросов, так что все запросы обрабатываются одним обработчиком. Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем передать запрос соответствующему контроллеру. View Helper отделяет статическое содержимое в представлении, такое как JSP, от обработки бизнес-логики.

Dependency injection и Inversion of control (IoC) (Внедрение зависимостей и инверсия управления) - IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку всего их жизненного цикла от создания до полного уничтожения. В контейнере Spring используется инъекция зависимостей (Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring Beans).

Service Locator (Локатор служб) - ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает сервис (бин) по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный со Spring, чтобы найти бин. Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость поиска сервисов в JNDI, Service Locator использует кеширование. При запросе сервиса первый раз Service Locator ищет его в JNDI и кэширует объект. Дальнейший поиск этого же сервиса через Service Locator выполняется в кэше, что значительно улучшает производительность приложения.

Observer-Observable (Наблюдатель) - Используется в механизме событий ApplicationContext. Определяет зависимость "один-ко-многим" между объектами, чтобы при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.

Context Object (Контекстный объект) - Паттерн Context Object, инкапсулирует системные данные в объекте-контексте для совместного использования другими частями приложения без привязки приложения к конкретному протоколу. ApplicationContext является центральным интерфейсом в приложении Spring для предоставления информации о конфигурации приложения.

Proxy (Заместитель) - позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

Factory (Фабрика) - определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Template (Шаблон) - Этот паттерн широко используется для работы с повторяющимся бойлерплейт кодом (таким как, закрытие соединений и т. п.).


# `META-INF`

**`META-INF`** — это стандартная директория внутри Java-архивов (JAR, WAR, EAR), название которой расшифровывается как "Meta-Information". Её основное предназначение — хранить метаданные о содержимом архива.

Содержимое этой папки не является частью прикладного кода (классов вашего приложения), а служит для описания, конфигурации и управления этим кодом для различных сред выполнения (JVM), фреймворков и инструментов.

Если JAR-файл — это "контейнер" с кодом, то `META-INF` — это его "паспорт", "инструкция по применению" и "служебная документация".