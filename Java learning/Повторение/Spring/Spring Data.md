# Spring Data

Spring Data — это модуль Spring Framework, который упрощает доступ к данным в различных хранилищах (реляционные базы, NoSQL, JPA и т.д.), предоставляя унифицированный API и автоматическую реализацию операций. Он минимизирует написание бойлерплейт-кода для CRUD, запросов, пагинации и других задач.

Для каждого типа хранилища Spring Data использует специфичные API: JPA: Под капотом работает EntityManager из Hibernate или другого провайдера JPA. Spring Data генерирует JPQL-запросы. MongoDB: Используется MongoTemplate для операций с MongoDB. Cassandra/Redis/Elasticsearch: Аналогично, через свои шаблоны (CassandraTemplate, RedisTemplate и т.д.). Spring Data абстрагирует различия между хранилищами, предоставляя единый интерфейс

# Как Spring Data работает

Когда приложение стартует, Spring сканирует ваши интерфейсы репозиториев (например, AccountRepository). Для каждого такого интерфейса фреймворк создает динамический класс-реализацию с помощью JDK Proxy или CGLIB. Этот прокси перехватывает вызовы ваших методов.

Стандартные методы (унаследованные от JpaRepository) прокси делегирует на готовую реализацию – Spring Data содержит класс SimpleJpaRepository, где уже реализована логика методов save, findById и т.д. Прокси знает, что делать с ними: например, findById – выполнить EntityManager.find(); save – либо persist, либо merge в зависимости от состояния объекта.

Если вызывается кастомный метод, не совпадающий с базовыми CRUD, прокси анализирует его. Тут и применяется парсинг имени метода, описанный выше. Spring Data JPA разбирает название (с помощью класса PartTree), определяет критерии и генерирует либо JPQL, либо создает Criteria API запрос для выполнения. Например, для findByOwnerName прокси построит JPQL строку и выполнит ее через EntityManager. Все это происходит прозрачно при первом вызове метода, после чего запрос кешируется для повторного использования.

Методы, помеченные @Query, прокси обрабатывает иначе – он берет готовый текст JPQL/SQL из аннотации и выполняет его, подставляя параметры.

Транзакционность: Spring Data автоматическим образом оформляет репозитории как @Transactional (по умолчанию методы чтения @Transactional(readOnly=true)). При вызове метода репозитория Spring откроет транзакцию (если еще не открыта) и выполнит операцию внутри нее. Например, вызов accountRepo.save() начнет транзакцию, выполнит INSERT, и при выходе из метода транзакция будет зафиксирована. Это удобно – вам не нужно явно использовать @Transactional на каждом методе сервиса, если вы вызываете репозиторий (хотя явное управление транзакциями на уровне сервисов – хорошая практика для более сложных операций, см. далее).

Инъекция реализации: Получив сгенерированный прокси-объект репозитория, Spring регистрирует его как bean в контексте. Таким образом, когда вы делаете @Autowired AccountRepository, вы получаете именно этот прокси. Он выглядит как ваш интерфейс и ведет себя как реализация.

# Transactional

## Введение

В современных приложениях важно обеспечивать **атомарность операций с данными**. Если выполнение бизнес-логики включает несколько обращений к базе данных, они должны выполняться _все как единое целое или не выполняться вовсе_. Например, при переводе денег со счета покупателя на счет продавца нужно либо уменьшить баланс покупателя **и** увеличить баланс продавца, либо не делать ничего, если произошла ошибка. Транзакции как раз гарантируют принцип “_все или ничего_“: если в ходе выполнения операции возникает исключение, то **все изменения откатываются**, и база данных возвращается в консистентное состояние. Без транзакций частичное выполнение могло бы привести к потере данных или нарушению их целостности.

**Spring Framework** предоставляет удобный способ декларативного управления транзакциями с помощью аннотации **`@Transactional`**. Этой аннотацией можно пометить метод или класс сервиса, чтобы выполнить его логику внутри транзакции. Разработчику не нужно вручную открывать, коммитить или откатывать транзакцию – за него это сделает Spring. В результате код становится чище и безопаснее, а риск ошибок, связанных с неправильной работой с транзакциями, значительно снижается.

Стоит отметить, что в контексте **Spring Boot** (начиная с версий Spring Boot 3 и Spring Data JPA 3.5+ на базе Spring Framework 6) практически никакой дополнительной настройки для использования `@Transactional` не требуется. Если в вашем проекте есть зависимость `spring-boot-starter-data-jpa` (или любая другая, притягивающая модуль **spring-tx**), то поддержка транзакций **включается автоматически**. Spring Boot сам сконфигурирует нужный **PlatformTransactionManager** (например, `JpaTransactionManager` для JPA/Hibernate) и активирует управление транзакциями. В традиционных Spring-проектах без Boot раньше приходилось явно прописывать `<tx:annotation-driven/>` в XML или использовать `@EnableTransactionManagement` в конфигурации – в Spring Boot этого не требуется, все работает “из коробки”.

Аннотацию `@Transactional` чаще всего применяют к методам сервисного слоя (классам с `@Service`). Можно ставить ее как на весь класс (тогда все публичные методы класса будут выполняться в транзакции по умолчанию), так и на отдельные методы. Если `@Transactional` указана на классе, а на конкретном методе не переопределена, то метод наследует транзакционную политику класса. **Spring Data JPA** в своих репозиториях также использует `@Transactional`: по умолчанию все методы, выполняющие модификацию данных (например, `save`, `delete`) помечены транзакцией на запись, а методы чтения (например, `findAll`, `findById`) выполняются в транзакции с флагом `readOnly=true`. Это означает, что простые запросы через репозиторий выполняются в рамках кратковременной транзакции (чаще всего сразу завершаются после выполнения операции). Однако в прикладном коде рекомендуется открывать транзакции **на уровне сервисов**, особенно если операция объединяет несколько вызовов репозиториев. Внешняя транзакция на уровне сервиса _перекрывает_ настройки транзакционности методов репозитория – например, если сервис помечен транзакцией read-write (по умолчанию), то даже вызовы методов репозитория, имеющих `readOnly=true`, будут выполняться в рамках общей read-write транзакции без ограничений на запись. Таким образом, `@Transactional` на уровне сервисов позволяет задать **границы транзакции** для группы операций и обеспечить целостность данных на уровне бизнес-логики.

## Основы работы @Transactional: механизмы Spring

Как же Spring реализует поведение транзакций при помощи одной лишь аннотации? Ключ к пониманию – это **AOP (Aspect-Oriented Programming)**, или аспектно-ориентированное программирование. Spring при старте приложения создает специальную прокси-обертку вокруг каждого бина, в котором обнаружена аннотация `@Transactional` (на классе или методах). Этот прокси берет на себя задачу перехватывать вызовы методов и выполнять дополнительный код _до и после_ вашего метода. Упрощенно можно представить, что для транзакционного метода выполнение идет так:

1. **До** вызова реального метода: прокси обращается к менеджеру транзакций (PlatformTransactionManager) и открывает новую транзакцию (или присоединяется к существующей – об этом позже, в разделе про propagation). Для JPA это также означает открытие _EntityManager_ (сессии Hibernate) и привязку ее к текущему потоку.
2. **Вызов метода**: ваш бизнес-код выполняется внутри открытой транзакции. Если в процессе выполнения произойдет необработанное исключение, Spring пометит транзакцию как требующую отката.
3. **После** возврата из метода: прокси перехватывает результат или исключение. Если метод завершился нормально (без исключений), прокси инициирует коммит транзакции – все накопленные изменения будут зафиксированы в базе данных. Если же произошло неперехваченное исключение, прокси выполнит откат транзакции (rollback). После коммита или отката Spring также закрывает _EntityManager_ (сессию) и отвязывает его от потока.

Весь этот функционал инкапсулирован в инфраструктуре Spring. Разработчику достаточно поставить `@Transactional` – и Spring сам вызовет нужные методы `begin()`, `commit()` или `rollback()` в нужный момент. Это существенно упрощает код по сравнению с ручным управлением транзакцией через try-catch блоки.

Следует знать и о _технических деталях реализации_. Spring использует два вида прокси: **динамические JDK-прокси** и прокси на основе **CGLIB**. Если ваш транзакционный бин реализует какой-то интерфейс, по умолчанию Spring создаст прокси JDK, который реализует тот же интерфейс (и перехватывает вызовы интерфейсных методов). Если же интерфейса нет, будет использован CGLIB для создания подкласса вашего класса в runtime. В любом случае, прокси перехватывает вызовы **на уровне контейнера Spring**. Это означает, что _только вызовы извне, проходящие через прокси, будут обернуты транзакцией_. Если внутри того же класса транзакционный метод вызовет другой свой метод, помеченный `@Transactional`, то такой внутренний вызов **не пройдет через прокси** и, соответственно, второй метод не начнет новую транзакцию и не присоединится к существующей – аннотация будет проигнорирована. Этот распространенный подводный камень мы подробно рассмотрим далее, в разделе про типичные ошибки.

Еще одно ограничение: транзакцией по умолчанию оборачиваются **только публичные методы**. Методы `private`, пакетные (package-private) или `protected` – даже если они помечены `@Transactional` – не будут перехвачены прокси и выполнятся без транзакции. Таким образом, аннотацию имеет смысл ставить **только на public методы сервисов**. Как правило, это не проблема, так как бизнес-логика, требующая транзакции, обычно находится в публичных методах сервисного слоя. Но знать об этом необходимо, чтобы избежать скрытых ошибок.

Под капотом `@Transactional` работает благодаря API Spring Transaction Management. При открытии транзакции используется соответствующая реализация **PlatformTransactionManager** – для JPA/Hibernate это обычно `JpaTransactionManager`, который делегирует операции EntityManager’у JPA и JDBC-соединению. Он позаботится о том, чтобы применить нужные настройки из аннотации (уровень изоляции, read-only и т.п.) на уровне соединения с БД или ORM. Более того, Spring умеет объединять несколько транзакционных операций в одну: если транзакция уже открыта, новые вызовы с propagation = REQUIRED (по умолчанию) не создают новую физическую транзакцию, а участвуют в текущей. Эти нюансы мы рассмотрим далее.

![](https://i0.wp.com/proselyte.net/wp-content/uploads/2025/08/trn1.png?resize=700%2C727&quality=80&ssl=1)

_Рис. 1: иллюстрация работы `@Transactional` в Spring (через AOP?прокси) для JPA/Hibernate_

Резюмируя: `@Transactional` – это **декларативный способ** огородить кусок кода транзакцией. Spring через AOP-прокси автоматически запускает транзакцию в начале метода и управляет ее завершением (коммит или откат) по его окончании. Это позволяет сконцентрироваться на бизнес-логике, поручив инфраструктурные заботы фреймворку.

## Transaction propagation: поведение вложенных транзакций

Когда несколько транзакционных методов вызываются один внутри другого, возникает вопрос – **как они взаимодействуют между собой**? Должен ли внутренний метод выполнить свою часть в рамках уже существующей транзакции, или начать новую независимую? А может, ему вообще не нужна транзакция? За это отвечает параметр `propagation` аннотации `@Transactional`. **Propagation** (способ распространения транзакции) определяет, что делать, когда вызов метода происходит в контексте уже _существующей_ транзакции.

Spring поддерживает несколько режимов propagation (значения перечисления `org.springframework.transaction.annotation.Propagation`). Рассмотрим наиболее распространенные из них и их семантику:

- **REQUIRED** (по умолчанию) – метод должен выполняться внутри транзакции. Если на момент вызова уже есть активная транзакция, метод _встраивается_ в нее (participates). Если же транзакции нет – Spring откроет новую. Этот режим удобен в большинстве случаев: внешние сервисы открывают транзакцию, а все вложенные вызовы разделяют общий контекст. Таким образом, _все действия в цепочке либо коммитятся, либо откатываются вместе_. Обратите внимание: участие во внешней транзакции означает, что локальные настройки аннотации (например, timeout, readOnly, isolation) будут **проигнорированы** – применятся параметры внешней транзакции. Вложенный метод может пометить транзакцию как rollback-only (например, выбросив исключение), что предотвратит коммит всей цепочки. Если внутренний метод вызвал откат, а внешний об этом “не знает” и попытается зафиксировать транзакцию, Spring бросит исключение **UnexpectedRollbackException** – оно сигнализирует внешнему вызову, что транзакция откатилась, несмотря на отсутствие явной ошибки с его стороны.
- **REQUIRES_NEW** – каждый такой метод всегда выполняется в _новой, независимой_ транзакции. Если внешняя транзакция уже была, она будет **приостановлена** на время выполнения этого метода, а затем возобновлена после его завершения. Метод с REQUIRES_NEW всегда стартует **свою** физическую транзакцию, обособленную от внешней. Это означает, что коммит или откат внутренней транзакции **никак не влияет** на внешнюю: если внутренний метод упадет с исключением и откатится, внешняя транзакция все равно может продолжить работу и успешно зафиксироваться (ее “не заметит” откат вложенного метода). И наоборот, откат внешней транзакции не отменит уже зафиксированные изменения внутренних REQUIRES_NEW-транзакций. Такой режим полезен, когда нужно выполнить какую-то операцию **изолированно**. Классический пример – запись аудита или лога действий: основная транзакция может откатиться (например, из-за ошибки бизнес-логики), но запись о самом факте попытки (лог) хотелось бы сохранить. Метод логирования можно пометить Propagation.REQUIRES_NEW, и тогда он выполнится в отдельной транзакции, даже если основная не успешна. **Важно помнить**: REQUIRES_NEW требует открыть отдельное соединение к базе (так как предыдущее занято внешней транзакцией). Множество вложенных транзакций этого типа могут привести к **исчерпанию пула соединений** или даже дедлокам, если не рассчитать ресурсы. Например, если 10 потоков держат открытыми транзакции и каждый внутри вызывает REQUIRES_NEW, то понадобится еще 10 дополнительных соединений. Поэтому применять REQUIRES_NEW следует осознанно и при необходимости увеличивать размер пула соединений (хотя бы на количество параллельных вложенных транзакций плюс один).
- **NESTED** – метод выполняется в контексте _вложенной транзакции_ с использованием механизма **savepoint**. В этом режиме Spring **не открывает новую БД-сессию**, а использует ту же самую физическую транзакцию, но помечает **точку сохранения** (savepoint) перед выполнением метода. Если вложенный метод бросает исключение, можно откатить его изменения _до savepoint_, не отменяя всю внешнюю транзакцию. Внешняя транзакция продолжится, будто ничего не произошло (откатываются только действия внутренней части). Это похоже на частичный откат. Однако, если внешняя транзакция сама решит откатиться, откатится все, включая внутренние операции. `PROPAGATION_NESTED` полезен в ситуациях, когда допустимо в рамках одной большой операции проигнорировать сбой в части работы, откатив только ее. Например, пакетная обработка нескольких записей: можно обернуть обработку каждой записи во вложенную транзакцию. При сбое на одной записи ее изменения откатятся до savepoint, но остальные обработки не пострадают. **Важное ограничение**: вложенные транзакции через savepoint поддерживаются **только** при использовании локальной транзакции на одном ресурсе (например, DataSourceTransactionManager с JDBC). Если платформа транзакций не поддерживает savepoint (типично для JPA в режиме JTA), то `NESTED` будет работать как REQUIRED или не поддерживаться вовсе. В контексте Spring Data JPA с Hibernate вложенные транзакции возможны, если использовать локальные JDBC-транзакции. Hibernate поддерживает savepoints при работе через тот же Connection.
- **SUPPORTS** – не обязывает выполнять метод в транзакции. Если транзакция уже есть – метод выполнится внутри нее; если нет – просто выполнится _без транзакции_ (так называемый **нетранзакционный контекст**). Этот режим подходит для операций, которым не принципиальна транзакционность: они могут безопасно работать и в рамках существующей транзакции, и вне ее. Например, метод только читает справочные данные – можно пометить SUPPORTS, чтобы не открывать новую транзакцию зря, но позволить встроиться, если вызван из транзакционного контекста.
- **NOT_SUPPORTED** – всегда выполняет метод _вне транзакции_. Если на момент вызова есть активная транзакция, Spring ее **приостанавливает** на время выполнения текущего метода (аналогично REQUIRES_NEW, но **без** открытия новой транзакции). Таким образом, метод гарантированно выполнится без транзакционной обертки. Этот режим может понадобиться, если метод заведомо не должен участвовать в транзакции – например, длительная операция, во время которой не нужны транзакционные блокировки.
- **MANDATORY** – требует выполнение _внутри существующей_ транзакции. Если при вызове метода транзакция отсутствует, Spring бросит исключение. Этот режим используется, когда метод на уровне логики _не может_ работать без транзакции, и это явно контролируется. Например, метод низкоуровневого DAO, который предполагается вызывать только внутри сервисных транзакций.
- **NEVER** – противоположность MANDATORY: требует **отсутствия** активной транзакции. Если попытаться вызвать такой метод внутри транзакции, будет брошено исключение. Полезно для методов, которые должны выполняться только вне транзакционного контекста, чтобы избежать нежелательных побочных эффектов.

Чтобы лучше понять разницу между **PROPAGATION_REQUIRED** и **PROPAGATION_REQUIRES_NEW**, рассмотрим наглядно их работу.

Ниже представлена диаграмма последовательности для поведения по умолчанию (PROPAGATION_REQUIRED). Метод _B_ вызывается из метода _A_ в одном потоке выполнения, и они будут разделять **единую транзакцию**. Метод _B_ **не открывает** новую транзакцию, а использует контекст уже начатой транзакции _A_. Все операции обоих методов выполняются между одним `begin` и `commit`:

![](https://i0.wp.com/proselyte.net/wp-content/uploads/2025/08/tr1.png?resize=700%2C379&quality=80&ssl=1)

_Рис. 2: иллюстрация работы PROPAGATION_REQUIRE_D

Следующая диаграмма показывает поведение при **PROPAGATION_REQUIRES_NEW**. Метод _B_ всегда запускается в **новой** транзакции. Текущая транзакция _A_ при вызове _B_ временно **приостанавливается**. Метод _B_ выполняется независимо – он открывает свою транзакцию, выполняет операции и фиксирует их (commit) или откатывает, _не влияя на внешнюю транзакцию_. После завершения _B_ транзакция _A_ возобновляется и продолжается:

![](https://i0.wp.com/proselyte.net/wp-content/uploads/2025/08/tr2.png?resize=700%2C456&quality=80&ssl=1)

_Рис. 3: иллюстрация работы PROPAGATION_REQUIRES_NEW_

## Уровни изоляции транзакций (Isolation Level)

Помимо правильного определения границ транзакций, каждый разработчик должен понимать, **как параллельные транзакции влияют друг на друга**. Представьте, что два пользователя почти одновременно выполняют операции с одними и теми же данными – например, оба читают и обновляют одну и ту же запись. Без должных ограничений возможны неприятные эффекты: один пользователь может прочитать промежуточные (незафиксированные) данные другого; или увидит разные данные при повторном чтении, если параллельно другая транзакция их изменила; или пропустит новую запись, добавленную параллельно, при повторном выполнении запроса. Эти эффекты известны как **“грязное чтение” (dirty read)**, **“неповторяемое чтение” (non-repeatable read)** и **“фантомное чтение” (phantom read)**.

Чтобы контролировать подобные ситуации, СУБД поддерживают различные **уровни изоляции транзакций** – набор правил, определяющих видимость изменений, сделанных одной транзакцией, для других параллельных транзакций. Spring позволяет задать желаемый уровень изоляции через параметр `isolation` аннотации `@Transactional`. Доступны стандартные уровни изоляции, определенные в SQL-стандарте (перечисление `Isolation` в Spring повторяет их):

- **DEFAULT** – использовать уровень изоляции по умолчанию, установленный в базе данных. Обычно это оптимальный выбор, если нет специальных требований. Например, в PostgreSQL по умолчанию используется READ COMMITTED, в MySQL – REPEATABLE READ. **Spring** в этом случае не будет явно менять уровень, полагаясь на настройки СУБД.
- **READ_UNCOMMITTED** – самый слабый уровень изоляции. _Транзакция может видеть незакоммиченные изменения других транзакций_. Допускаются грязные чтения, а также неповторяемые и фантомные чтения. На практике почти не используется, так как нарушает целостность данных, хоть и дает максимум производительности (за счет отсутствия блокировок на чтение).
- **READ_COMMITTED** – транзакция видит только данные, зафиксированные (committed) другими транзакциями. **Грязные чтения невозможны** (то есть нельзя прочитать изменения, которые другая транзакция потом отменила). Однако _неповторяемые чтения_ и _фантомы_ все еще возможны. Это один из самых распространенных уровней – он обеспечивает базовую консистентность при небольших накладных расходах. В частности, большинство СУБД (Oracle, PostgreSQL, MSSQL) по умолчанию работают на уровне READ COMMITTED.
- **REPEATABLE_READ** – более строгий уровень изоляции. Гарантирует, что если транзакция прочитала некоторое значение, то _при повторном чтении в этой же транзакции оно останется таким же_. Запрещает неповторяемое чтение: никакая другая транзакция не может изменить данные, которые мы уже прочли, пока текущая транзакция не завершится. Таким образом, все чтения в рамках одной транзакции **повторяемы**. Однако фантомные чтения все еще возможны – другая транзакция может вставить новые строки, удовлетворяющие условиям вашего запроса (так называемые фантомы). В MySQL (InnoDB) уровень по умолчанию – REPEATABLE_READ (где, к слову, механизм _next-key locking_ предотвращает фантомы в рамках диапазонных запросов). Для большинства приложений этого уровня изоляции достаточно: он обеспечивает довольно сильные гарантии консистентности данных.
- **SERIALIZABLE** – самый строгий уровень изоляции. Транзакции выполняются так, _будто последовательно_, одна за другой, а не параллельно. Полностью исключает грязные, неповторяемые и фантомные чтения. Достигается это, как правило, за счет более жестких блокировок (например, блокировки на чтение **всех** диапазонов данных, участвующих в запросах) или за счет многоверсионного контроля с проверкой конфликтов при фиксации. SERIALIZABLE гарантирует максимальную целостность данных, но **может существенно снизить производительность** из-за блокировок и потенциальных откатов транзакций при обнаружении конфликтов. Применяется только там, где данные критически важны и небольшое снижение параллелизма допустимо.

В Spring уровень изоляции указывается, например, так: `@Transactional(isolation = Isolation.SERIALIZABLE)`. Если используемая СУБД или транзакционный менеджер не поддерживает указанный уровень, то будет брошено исключение. Ранее, в чистом JPA, существовало ограничение: стандартный JPA не позволял менять изоляцию “на лету” (только глобально для соединения), но начиная с Spring 4.1 `JpaTransactionManager` умеет устанавливать уровень изоляции через JDBC-соединение. Таким образом, сегодня вы можете использовать настройку `isolation` в Spring Boot JPA, и она будет работать, если база данных поддерживает соответствующий уровень.

На практике подавляющее большинство приложений используют **READ_COMMITTED** или **REPEATABLE_READ** как баланс между согласованностью данных и производительностью. Уровень SERIALIZABLE выбирается для критичных финансовых операций, требующих абсолютной точности (при этом нужно быть готовым к повторным попыткам транзакции при возникновении конфликтов). Явно указывать уровень изоляции в `@Transactional` имеет смысл, когда конкретно для данной операции нужны гарантии выше или ниже, чем глобальные настройки базы. Например, отчет может выполняться с SERIALIZABLE, чтобы получить “снимок” данных на текущий момент, а не видеть обновления, которые параллельно вносятся другими транзакциями.
## Поведение rollback: когда транзакция откатывается?

После того как транзакция открыта, Spring должен решить – фиксировать ее (commit) или откатывать (rollback) при завершении метода. По умолчанию логика довольно простая: **если метод завершился без необработанных исключений, транзакция подтверждается**, если же из метода выброшено _неперехваченное исключение_, транзакция откатывается. Однако важно знать, что **не каждое исключение приведет к откату**. По умолчанию Spring откатывает транзакцию _только_ при возникновении **unchecked exception** (исключения, унаследованные от `RuntimeException` или `Error`). Проверяемые исключения (наследники `Exception`, но не RuntimeException) по умолчанию **не приводят к откату**. Такой дизайн исторически обусловлен тем, что проверяемые исключения часто означают ожидаемые ситуации, которые программист может обработать (например, бизнес-ошибка типа “товар закончился на складе”) – откатывать транзакцию в таких случаях не всегда нужно.

Конечно, эти правила можно изменить. Параметры аннотации `@Transactional` позволяют настроить поведение при исключениях:

- **`rollbackFor`** – список классов исключений (или их имен), при возникновении которых _нужно откатить_ транзакцию, даже если они являются проверяемыми (checked). Например, можно указать `@Transactional(rollbackFor = SQLException.class)`, и тогда транзакция откатится и при выбросе `java.sql.SQLException` (который является checked-исключением). Также существует псевдоним `rollbackForClassName` для указания имен исключений строкой.
- **`noRollbackFor`** – наоборот, список исключений, при которых **не следует откатывать** транзакцию. Это позволяет исключить из стандартного поведения какие-то RuntimeException. Например, `@Transactional(noRollbackFor = CustomBusinessException.class)` означает, что если метод выбросит `CustomBusinessException` (наследник RuntimeException), Spring _не будет_ откатывать транзакцию – вероятно, такое исключение используется для управления потоком выполнения (например, чтобы прервать операцию, но сохранить уже сделанные изменения).

Важно понимать, что правила отката срабатывают только если исключение _выходит из метода наружу_. Если внутри метода вы перехватили исключение и не дали ему всплыть, то для Spring выполнение считается успешным, и он попытается закоммитить транзакцию. Даже если внутри произошло исключение, но вы его поймали – фреймворк об этом “не узнает”. В таких случаях, если вам все же нужен откат, следует вручную пометить транзакцию на rollback. Для этого можно вызвать:

```
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
```

Этот программный способ помечает текущую транзакцию как подлежащую откату _без_ выбрасывания исключения. Однако учтите, что такой вызов сработает **только внутри транзакционного контекста**; если транзакции нет, `currentTransactionStatus()` вернет статус без транзакции. Как правило, лучше не злоупотреблять этим и позволять исключениям пробрасываться – используя декларативный подход (`rollbackFor` и т.п.), код получается чище и понятнее.

Также стоит знать, что Spring определяет два специальных исключения, связанных с транзакциями: **UnexpectedRollbackException** – бросается, когда транзакция была помечена на откат (например, внутренним вызовом), но внешний код об этом не знает и пытается выполнить commit. Второе – **TransactionSystemException**, которое оборачивает низкоуровневые проблемы системы транзакций (например, сбой при работе с JDBC или JPA во время коммита). В обычной работе с `@Transactional` вы с ними редко сталкиваетесь, но полезно понимать их природу.

Итак, **по умолчанию Spring откатывает транзакцию при RuntimeException**, а при checked-исключениях – нет. Вы можете изменить это поведение, явно указав классы исключений для отката или, наоборот, для игнорирования отката. Всегда старайтесь проектировать логику так, чтобы неперехваченное исключение действительно означало необходимость отката – это самый ясный и надежный подход. Ловите исключения внутри транзакции только если уверены, что можете корректно продолжить работу и зафиксировать частичный результат.

## Ленивая загрузка (Lazy Loading) и границы транзакции

Одно из распространенных явлений при работе с ORM (например, Hibernate) – это **ленивая загрузка** связанных данных. Свойства сущностей, отмеченные как `LAZY`, не загружаются сразу из базы при первом запросе – вместо них Hibernate подставляет _прокси-объекты_, которые запрашивают реальные данные только когда вы к ним обращаетесь. Однако для выполнения такого **дозагружения** необходим активный _сеанс_ Hibernate (EntityManager) и открытая транзакция. Если попытаться обратиться к lazy-свойству вне контекста сессии, ORM не сможет выполнить запрос – в результате бросается знаменитое исключение **LazyInitializationException** с сообщением _“no Session”_ (нет сессии для инициализации прокси).

Аннотация `@Transactional` напрямую влияет на ленивую загрузку, потому что управление _сессией_ Hibernate привязано к транзакции. Как правило, **сессия открывается при старте транзакции и закрывается при ее коммите/откате**. Поэтому, пока код выполняется _внутри_ метода с `@Transactional`, все `LAZY`-связи можно свободно инициализировать – необходимые данные будут подгружены из базы в рамках той же транзакции. А вот как только метод закончился и транзакция закрылась, прикрепленный к ней EntityManager тоже закрывается. Любая попытка доступа к ленивым полям после этого приведет к LazyInitializationException.

Рассмотрим сценарий: у вас есть метод сервиса, помеченный `@Transactional`, который загружает сущность и возвращает ее в контроллер для использования на слое представления. Если у сущности есть лениво инициализируемые поля (например, коллекция связанных объектов), и вы попытаетесь обратиться к ним во View (уже за пределами метода сервиса), то получите исключение – транзакция к тому моменту завершена, и сессия закрыта. Часто новички забывают об этом, получая LazyInitializationException, хотя, казалось бы, запрос выполнялся в транзакции.

Есть несколько способов избежать этой проблемы:

- **Инициализировать необходимые lazy-поля внутри транзакции.** Проще всего – вызвать нужные геттеры внутри метода сервиса (пока транзакция открыта), либо использовать `JOIN FETCH` в JPQL/HQL-запросе, заранее подгрузив все требуемые данные. Тогда к моменту возврата из метода вся нужная информация уже будет загружена.
- Воспользоваться шаблоном **Open Session in View (OSIV)**. Spring (а точнее Spring Boot) по умолчанию включает механизм, который оставляет сессию Hibernate открытой на время выполнения всего веб-запроса. Это означает, что даже после выхода из сервисного метода (но пока продолжается обработка запроса в контроллере/вью), сессия остается активной, и ленивые поля могут подгрузиться при обращении. В Spring Boot этот механизм включен через свойство `spring.jpa.open-in-view=true` (стоит по умолчанию). Он помогает начинающим разработчикам сразу не столкнуться с LazyInitializationException. **Однако OSIV имеет и обратную сторону**: держать сессию открытой длительное время (на весь запрос) может быть не оптимально. Транзакция к тому моменту уже завершена, но сессия все равно привязана к соединению. Это чревато длительным удержанием connection при формировании ответа и потенциально большим количеством дополнительных запросов (N+1) при рендеринге. Многие продвинутые проекты предпочитают отключать OSIV и явно контролировать загрузку данных.
- **Не возвращать ленивые сущности наружу.** Хороший вариант – преобразовывать сущности в DTO внутри транзакции и возвращать уже полностью заполненные DTO. Либо вообще избегать LAZY-загрузки для данных, которые нужны сразу: можно пометить отношения как EAGER (но это грубое решение, ухудшающее производительность глобально – ведь данные будут загружаться всегда, даже когда они не нужны).

Главный вывод: если получаете `LazyInitializationException`, значит вы пытаетесь обратиться к данным вне контекста транзакции. Либо расширьте контекст (например, за счет OSIV или переноса логики в сервисный слой), либо загружайте необходимые данные внутри транзакции заранее. Добавление `@Transactional` к коду, который читает ленивые объекты, часто решает проблему – сессия останется открытой до конца метода, и Hibernate спокойно выполнит дополнительные запросы. Только не переусердствуйте: открывать транзакцию там, где вы просто рендерите данные, не всегда хорошая идея (это может создать длительную транзакцию). Лучше спроектировать уровень доступа к данным так, чтобы к моменту выхода из сервисного метода у вас уже была вся нужная информация.

Например, вместо того чтобы возвращать из транзакционного метода объект `User` с ленивой коллекцией `roles` и затем где-то в шаблоне обращаться к `user.getRoles()`, можно сразу в сервисе вызвать `user.getRoles().size()` (инициализируя коллекцию) или выполнить запрос с JOIN FETCH, получив пользователя сразу с ролями.

В целом, понимание механизма ленивой загрузки и жизненного цикла сессии Hibernate – обязательная часть работы с Spring Data JPA. Аннотация `@Transactional` гарантирует наличие активной сессии на время работы метода, поэтому **все операции загрузки/сохранения** должны выполняться **в пределах транзакции**.

## Сравнение с ручным управлением транзакциями (PlatformTransactionManager)

Мы рассмотрели декларативный подход – когда достаточно повесить `@Transactional`, и Spring сам разберется, когда начать и завершить транзакцию. Но что стоит за этим “магическим” подходом? А стоит за ним вполне реальный API: интерфейс **PlatformTransactionManager** и связанные с ним классы.

Можно управлять транзакциями и _программно_, без аннотаций. Например, вот эквивалент простейшего использования `@Transactional` вручную:

```
@Autowired
private PlatformTransactionManager txManager;

public void doSomething() {
    // Определяем параметры транзакции (можно задать propagation, timeout, readOnly и др.)
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    def.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
    def.setTimeout(5); // таймаут 5 секунд, например
    // Начинаем транзакцию
    TransactionStatus status = txManager.getTransaction(def);
    try {
        // ... выполняем логику, как внутри @Transactional
        // Например:
        repository.save(entity);
        // Если дошли сюда без исключений, фиксируем транзакцию:
        txManager.commit(status);
    } catch (Exception ex) {
        // В случае ошибки откатываем транзакцию:
        txManager.rollback(status);
        throw ex; // пробрасываем дальше
    }
}
```

Как видим, код вручную вызывает `txManager.getTransaction()` для старта транзакции и затем явно делает `commit` или `rollback`. Аннотация `@Transactional` избавляет нас от всей этой шаблонной обвязки, позволяя выразить намерение декларативно. **Spring AOP** фактически оборачивает ваш метод примерно таким же try-catch блоком.

Ручное управление транзакциями может понадобиться, если требуется особенно тонкий контроль. Например, нужно выполнить часть метода без транзакции, затем начать транзакцию, потом снова выполнить что-то без транзакции – такое сложно выразить одной аннотацией. Или вы пишете низкоуровневый код, где нельзя легко применить Spring AOP (например, внутри нестандартного фонового потока). В таких случаях можно воспользоваться `PlatformTransactionManager` напрямую или через удобный шаблон **TransactionTemplate** – Spring предоставляет этот класс, позволяющий выполнить лямбда-выражение внутри транзакции, что упрощает синтаксис программного управления транзакциями.

Тем не менее, **в 99% случаев лучше использовать `@Transactional`**, так как это существенно уменьшает объем шаблонного кода и вероятность ошибок. Spring сам правильно обработает все исключения, позаботится о выбросе UnexpectedRollbackException в нужных ситуациях, и код будет выглядеть чище. Программные транзакции стоит рассматривать только при наличии веских причин. Например, одна из таких причин – **оптимизация длительных операций**: допустим, внутри одной бизнес-операции вы делаете и запросы в базу, и длительный вызов внешнего веб-сервиса. Держать транзакцию открытой на все время внешнего вызова не хочется (это блокирует соединение с БД). Можно разделить логику: обернуть операции с базой в две транзакции (до и после внешнего вызова), а сам внешний вызов выполнить _вне_ транзакции. Реализовать это можно, например, вынеся внешний вызов в отдельный метод с `PROPAGATION_REQUIRES_NEW` (при этом внешнюю транзакцию пометив как `NOT_SUPPORTED`), либо более явно, используя программное управление. В любом случае, такие ситуации – скорее исключение.

**PlatformTransactionManager** в Spring имеет несколько реализаций: для работы с одной БД через JDBC (DataSourceTransactionManager), для JPA (JpaTransactionManager), для распределенных транзакций JTA (JtaTransactionManager) и другие. В контексте Spring Boot + Spring Data JPA обычно используется `JpaTransactionManager`, который под капотом все равно работает с JDBC-соединениями. Поэтому все, что мы обсуждали (propagation, изоляция, откаты), справедливо и для Hibernate/JPA – Spring просто вызывает необходимые методы у EntityManager и Connection.

Подведем итог: `@Transactional` – это надстройка над PlatformTransactionManager + AOP. **Ручное управление транзакциями** возможно и понимать его полезно (приведенный выше шаблон try/commit/rollback – по сути то, что делает Spring за нас). Но в ежедневной работе гораздо удобнее и безопаснее пользоваться декларативными транзакциями.
