# Зачем нужен Spring Boot

**Spring Boot** — это не замена Spring Framework. Это **надстройка** над ним, которая кардинально упрощает и ускоряет процесс разработки, конфигурирования и развертывания Spring-приложений.

Его философия — **"Convention over Configuration"** (Соглашение вместо конфигурации). Spring Boot говорит: "Я знаю, как обычно настраивают веб-приложение, приложение для работы с базой данных или для отправки сообщений. Просто скажи мне, что ты хочешь сделать, и я настрою все за тебя по умолчанию. Если тебе не понравятся мои настройки, ты сможешь их легко переопределить".

По сути, Spring Boot это просто набор классов конфигурации, которые создают нужные бины в контексте. Точно так же их можно создать руками, просто Boot это автоматизирует. При этом помогая решить проблему конфликтов разных версий компонентов. Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику посредством так называемых starter-пакетов (`spring-boot-starter-web`, `spring-boot-starter-data-jpa` и т.д.).
# Автоконфигурация

В основе лежит аннотация `@EnableAutoConfiguration` (которая спрятана внутри главной аннотации `@SpringBootApplication`). При запуске приложения Spring Boot анализирует ваш **classpath** (т.е. какие библиотеки у вас подключены). 
- Spring Boot видит в classpath `spring-boot-starter-web` и, следовательно, библиотеку `spring-webmvc`. Он думает: "Ага, разработчик хочет создать веб-приложение!". И он автоматически настраивает `DispatcherServlet`, `Tomcat` как встроенный сервер, `Jackson` для (де) сериализации JSON, `ViewResolver` и многое другое.
- Затем он видит `spring-boot-starter-data-jpa` и драйвер для H2/PostgreSQL. Он думает: "Похоже, нужна работа с базой данных!". И автоматически создает бины `DataSource`, `EntityManagerFactory` и `PlatformTransactionManager`, используя данные из вашего `application.properties`.
Эта магия реализуется через механизм **условных аннотаций`` (``@ConditionalOnClass``, ``@ConditionalOnBean``, `@ConditionalOnProperty` и т.д.). Внутри библиотеки `spring-boot-autoconfigure.jar`` лежат сотни классов конфигурации, каждый из которых активируется только при выполнении определенного условия. Например: `TomcatServletWebServerFactory` будет создан только при условии `@ConditionalOnClass(ServletRequest.class)` и `@ConditionalOnMissingBean(ServletWebServerFactory.class)` (т.е. если в classpath есть сервлеты и вы сами не создали фабрику серверов).

Жизненный цикл создания:
1. Создание бинов пользователя.
2. Поиск EnableAutoConfiguration.
3. Поиск всех EnableAutoConfiguration и classpath, чтобы загрузить начальный Config файлы.
4. Далее настройка с приоритетом на бины пользователя, бинов библиотек, с помощью Conditional.
# Версии

**`<parent>` в Maven `pom.xml` — это механизм наследования.** Он позволяет дочернему POM-файлу наследовать конфигурацию от родительского POM-файла.

**Централизованное управление версиями (через BOM)**
Это **самая важная** функция. `spring-boot-starter-parent` сам по себе наследуется от `spring-boot-dependencies`. Этот `spring-boot-dependencies` — это и есть тот самый **BOM (Bill of Materials)**, о котором мы говорили. Ваш проект получает "в наследство" огромную секцию `<dependencyManagement>`, в которой прописаны версии для сотен популярных библиотек (Spring Framework, Jackson, Hibernate, Tomcat и т.д.), которые были тщательно протестированы на совместимость командой Spring.

**Разумные настройки по умолчанию (Sensible Defaults)**
`parent` устанавливает множество полезных настроек по умолчанию, избавляя вас от рутины

**Конфигурация плагинов**
`parent` заранее настраивает ключевые плагины Maven для работы со Spring Boot.
**`spring-boot-maven-plugin`**: Самый главный плагин. Он настраивается в `parent`'e. Его задача — упаковать ваше приложение в * _исполняемый "fat" JAR-файл_*. Этот JAR содержит не только ваш код, но и все зависимости, а также встроенный веб-сервер (Tomcat). Именно благодаря этому плагину вы можете запустить приложение простой командой `java -jar myapp.jar`.

# Стартеры

Чтобы ускорить процесс управления зависимостями, Spring Boot неявно упаковывает необходимые сторонние зависимости для каждого типа приложения на основе Spring и предоставляет их разработчику посредством так называемых starter-пакетов. Starter-пакеты представляют собой набор удобных дескрипторов зависимостей, которые можно включить в свое приложение.

В техническом плане, это просто **`pom.xml` файл** (для Maven), который:

- **Не содержит Java-кода.**
- **Содержит список других, транзитивных зависимостей**, которые необходимы для работы определенной функциональности (веб, данные, безопасность).
- **Предоставляет "мнение" (opinionated view)** о том, какие библиотеки и каких версий лучше всего работают вместе.

Когда вы добавляете один стартер, вы получаете целый, согласованный набор библиотек, избавляя себя от ручного управления зависимостями.

Стартеры сами по себе решают только проблему управления зависимостями. Их истинная сила раскрывается в связке с **Автоконфигурацией**.

Эта связка работает как идеально слаженный механизм:

1. **Вы (Разработчик):** Говорите Spring Boot, **что** вы хотите сделать. Например: "Я хочу веб-приложение".
2. **Стартер (`spring-boot-starter-web`):** Добавляет в ваш classpath **всё, что для этого нужно** (Spring MVC, Tomcat, Jackson и т.д.).
3. **Автоконфигурация (`@EnableAutoConfiguration`):** **Реагирует** на появление этих библиотек в classpath. Она видит: "Ага, в classpath есть `DispatcherServlet`, значит, нужно настроить Spring MVC, создать встроенный Tomcat и зарегистрировать `ObjectMapper` для JSON".

> **Стартеры приносят "инструменты", а Автоконфигурация знает, как ими пользоваться.**

Без стартера Автоконфигурации не на что было бы реагировать. Без Автоконфигурации стартер был бы просто набором библиотек, которые вам все равно пришлось бы настраивать вручную.

# `spring.factories` и его будущее

`spring.factories` — это файл в формате `Properties` (ключ=значение), расположенный в директории `META-INF/` внутри JAR-архива.

Это реализация механизма **SPI (Service Provider Interface)**, адаптированная в Spring. Он служит в качестве "манифеста" или индекса, который позволяет различным модулям (JAR-файлам) декларировать свои компоненты (классы) для Spring Framework без необходимости явного сканирования всего classpath.

Spring при запуске ищет все файлы `spring.factories` на classpath, считывает их и использует для обнаружения и регистрации различных расширений.

Начиная со Spring Boot 2.7 и Spring Framework 6, был введен новый, более производительный механизм для автоконфигурации, который заменяет использование `spring.factories` для этой конкретной цели.

- **Новый файл**: `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`
- **Формат**: Простой текстовый файл, где каждая строка — это полное имя класса автоконфигурации.

Этот подход более эффективен, так как Spring Boot теперь может читать один специализированный файл вместо парсинга общего `spring.factories`, который используется и для других целей (например, для `ApplicationListener`'ов). `spring.factories` по-прежнему поддерживается для обратной совместимости.