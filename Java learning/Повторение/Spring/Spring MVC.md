# Spring MVC

Spring имеет собственную MVC-платформу веб-приложений, которая не была первоначально запланирована. Spring MVC является фреймворком, ориентированным на запросы. В нем определены стратегические интерфейсы для всех функций современной запросно-ориентированной системы. Цель каждого интерфейса — быть простым и ясным, чтобы пользователям было легко его заново имплементировать, если они того пожелают. MVC прокладывает путь к более чистому front-end-коду. Все интерфейсы тесно связаны с Servlet API. Эта связь рассматривается некоторыми как неспособность разработчиков Spring предложить для веб-приложений абстракцию более высокого уровня. Однако эта связь оставляет особенности Servlet API доступными для разработчиков, облегчая все же работу с ним.

# DispatcherServlet

`DispatcherServlet` — это реализация сервлета (`javax.servlet.http.HttpServlet`), которая обрабатывает HTTP-запросы в Spring MVC, маршрутизируя их к контроллерам, обрабатывая параметры, преобразовывая ответы и управляя исключениями. В Spring Boot он автоматически регистрируется и настраивается для обработки всех или части запросов, что делает его основой для REST API и традиционных MVC-приложений. DispatcherServlet экземпляр создается сервлет-контейнерами, такими как Tomcat или Jetty. В Spring Boot **DispatcherServlet** — это единый фронт-контроллер, который принимает все HTTP-запросы. Он не выполняет логику сам, а действует как диспетчер, передавая запрос нужным компонентам для обработки, поиска контроллера и преобразования данных.
Spring Boot настраивает его автоматически, чтобы он по умолчанию обрабатывал все запросы к приложению. Для REST API он играет ключевую роль, координируя преобразование Java-объектов в JSON и обеспечивая работу аннотаций контроллеров. Проще говоря, это ядро обработки всех веб-взаимодействий в Spring.

![[Pasted image 20250829221218.png]]

# Жизненный цикл у запроса

- **Приём запроса.** HTTP-запрос поступает в **`DispatcherServlet`** — единую точку входа и главный контроллер Spring MVC.
- **Поиск обработчика.** `DispatcherServlet` через `HandlerMapping` находит нужный метод в классе, помеченном `@RestController`. Он сопоставляет URL, HTTP-метод (GET, POST и т.д.) и заголовки запроса. Если ничего не найдено — возвращается ошибка 404.
- **Вызов метода контроллера.**
    - Сначала могут сработать **интерсепторы** (`HandlerInterceptor`) для предварительной обработки (например, проверки безопасности).
    - Spring автоматически извлекает параметры из запроса (`@PathVariable`, `@RequestParam`) и преобразует тело запроса (например, JSON) в Java-объект (`@RequestBody`).
    - Если используется аннотация `@Valid`, данные валидируются.
    - Наконец, вызывается сам метод контроллера.
- **Обработка результата.**
    - Объект, который вернул метод (например, `User`), **сериализуется** в JSON или XML с помощью `HttpMessageConverter`.
    - Если метод вернул `ResponseEntity`, Spring использует из него статус, заголовки и тело ответа.
- **Обработка исключений.** Если на любом этапе возникло **исключение**, оно перехватывается и обрабатывается глобально (через `@ControllerAdvice`) или локально в контроллере (через `@ExceptionHandler`), формируя ответ с соответствующим кодом ошибки (например, 400 или 500).
- **Отправка ответа.** `DispatcherServlet` отправляет готовый HTTP-ответ (статус, заголовки и тело) клиенту. После этого вызываются методы очистки в интерсепторах.
# Основные классы

1. **HandlerMapping** - Сопоставляет входящий HTTP-запрос с соответствующим обработчиком (обычно методом контроллера). Определяет, какой контроллер и метод должны обработать запрос на основе URL, HTTP-метода, заголовков и других критериев.
2. **HandlerAdapter** - Вызывает обработчик, определённый `HandlerMapping`, адаптируя его к конкретному типу (например, метод контроллера с аннотациями или функциональный обработчик). Выполняет привязку параметров и преобразование результата.
3. **HttpMessageConverter** - Преобразует тело HTTP-запроса (например, JSON) в объект Java и обратно (объект в JSON для ответа). Используется для десериализации `@RequestBody` и сериализации ответа в REST API.
4. **HandlerInterceptor** - Позволяет перехватывать запросы до, после или по завершении обработки контроллером. Используется для аутентификации, логирования, модификации запроса/ответа.
5. **HandlerExceptionResolver** - Обрабатывает исключения, возникшие во время обработки запроса, преобразует их в HTTP-ответы (например, JSON с ошибкой для REST API).
6. **WebDataBinderFactory** - Создаёт WebDataBinder для привязки параметров запроса (например, @RequestParam, @PathVariable, @RequestBody) к аргументам метода контроллера. Поддерживает валидацию и конверсию данных.
7. **MultipartResolver** -  Обрабатывает multipart/form-data запросы, такие как загрузка файлов. Парсит тело запроса и предоставляет файлы как параметры контроллера.
# Embedded Server

Вместо того чтобы вы деплоили свой код на сервер, **сервер теперь деплоится внутрь вашего кода**.

Приложение собирается в один исполняемый JAR-файл, который можно запустить командой `java -jar myapp.jar`.

**Анатомия "Fat JAR":**

Если вы распакуете такой JAR-файл, вы увидите интересную структуру:

```
myapp.jar
|
+-- BOOT-INF/
|   +-- classes/  <-- Ваш скомпилированный код (.class файлы)
|   |   +-- com/
|   |       +-- example/
|   |           +-- MyApplication.class
|   |           +-- MyController.class
|   |
|   +-- lib/      <-- Все ваши зависимости, включая сам сервер!
|   |   +-- spring-boot-starter-web-2.7.5.jar
|   |   +-- tomcat-embed-core-9.0.68.jar  <-- Вот он, встроенный Tomcat!
|   |   +-- spring-webmvc-5.3.23.jar
|   |   +-- ... (десятки других .jar)
|
+-- META-INF/
|   +-- MANIFEST.MF <-- Манифест, указывающий на специальный загрузчик
|
+-- org/
    +-- springframework/
        +-- boot/
            +-- loader/
                +-- JarLauncher.class <-- Специальный класс-загрузчик!
                +-- ...
```

Теперь, когда приложение запущено и классы доступны, как именно стартует Tomcat?

Этот процесс является частью **автоконфигурации** Spring Boot.
1. **Обнаружение:** При старте контекста `AutoConfiguration` видит, что в classpath есть `spring-boot-starter-web` и, следовательно, классы `Servlet.class` и `Tomcat.class`.
2. **Активация `ServletWebServerFactoryAutoConfiguration`:** Это триггерит соответствующую автоконфигурацию.
3. **Создание Фабрики:** Внутри этой конфигурации есть условные бины. Сработает тот, для которого есть класс в classpath. Spring Boot создает бин `TomcatServletWebServerFactory`. Это еще не сам сервер, а **фабрика**, которая знает, как создать и настроить экземпляр Tomcat. Если бы в classpath был Jetty, была бы создана `JettyServletWebServerFactory`.

# ContextLoaderListener

Это ContextLoaderListener слушатель, который помогает загрузить Spring MVC. Как следует из названия, он загружается и создает ApplicationContext, так что вам не нужно писать явный код для его создания. Контекст приложения — это то, куда уходит Spring bean. Для веб-приложения существует подкласс WebAppliationContext. ContextLoaderListener Также связывает жизненный цикл ApplicationContext для жизненного цикла ServletContext. Вы можете получить ServletContext с WebApplicationContext помощью getServletContext() метода.

# HandlerMapping

`HandlerMapping` — это интерфейс в Spring MVC, который определяет соответствие между HTTP-запросом и обработчиком (handler). Обработчик — это, как правило, метод в классе, помеченном `@Controller` или `@RestController`, хотя в более общих случаях это может быть любой объект, поддерживаемый `HandlerAdapter`. `HandlerMapping` возвращает объект `HandlerExecutionChain`, который включает:
- **Handler**: Обработчик запроса (например, метод контроллера).
- **HandlerInterceptors**: Список интерсепторов, которые будут применены к запросу (если они настроены).
Основная реализация интерфейса `HandlerMapping` в Spring MVC — это `RequestMappingHandlerMapping`, которая используется для обработки аннотаций `@RequestMapping`.
# HandlerAdapter

`HandlerAdapter` — это интерфейс в пакете `org.springframework.web.servlet`, который определяет, как вызывать обработчик (Handler) и обрабатывать его результат. Он абстрагирует процесс выполнения Handler'а, позволяя Spring MVC поддерживать различные типы обработчиков (например, методы контроллеров, старые интерфейсы `Controller`, или кастомные обработчики). Основная задача `HandlerAdapter`:

- Извлечь параметры из `HttpServletRequest` и передать их в Handler.
- Вызвать Handler.
- Обработать возвращённый результат (например, преобразовать в JSON для REST API или создать `ModelAndView` для MVC).

# HttpMessageConverter

Как работает HttpMessageConverter?

`HttpMessageConverter` — это интерфейс в пакете `org.springframework.http.converter`, который определяет методы для чтения и записи HTTP-сообщений. Его основная задача:

- **Десериализация**: Преобразование тела запроса (например, JSON) в объект Java (для `@RequestBody`).
- **Сериализация**: Преобразование объекта Java в тело ответа (например, JSON) для отправки клиенту (для `@ResponseBody` или возвращаемого значения метода `@RestController`).

Spring MVC и Spring Boot предоставляют несколько стандартных реализаций `HttpMessageConverter`:

1. **MappingJackson2HttpMessageConverter**:
    - Поддерживает JSON (через библиотеку Jackson).
    - Используется по умолчанию в REST API.
    - Поддерживает `MediaType.APPLICATION_JSON`.
    - Пример: Преобразует `{ "name": "John" }` в `User` и обратно.
2. **StringHttpMessageConverter**:
    - Поддерживает текстовые данные (`text/plain`).
    - Используется для строковых ответов.
    - Пример: Преобразует `String` в тело ответа.
3. **FormHttpMessageConverter**:
    - Поддерживает `application/x-www-form-urlencoded`.
    - Используется для обработки HTML-форм.
    - Пример: Преобразует параметры формы в объект.
4. **ByteArrayHttpMessageConverter**:
    - Поддерживает бинарные данные (`application/octet-stream`).
    - Используется для файлов или байтовых массивов.
5. **MappingJackson2XmlHttpMessageConverter**:
    - Поддерживает XML (через Jackson XML).
    - Поддерживает `MediaType.APPLICATION_XML`.
    - Требует зависимости `jackson-dataformat-xml`.
6. **ResourceHttpMessageConverter**:
    - Поддерживает ресурсы (например, файлы).
    - Используется для потоковой передачи данных.

# HandlerInterceptor

`HandlerInterceptor` — это интерфейс в пакете `org.springframework.web.servlet`, который определяет три метода для перехвата запросов:

- `preHandle`: Вызывается до выполнения Handler'а.
- `postHandle`: Вызывается после выполнения Handler'а, но до формирования ответа.
- `afterCompletion`: Вызывается после завершения обработки запроса (включая рендеринг ответа или обработку ошибки).

`HandlerInterceptor` включается в объект `HandlerExecutionChain`, возвращаемый `HandlerMapping`, и применяется к запросам, которые сопоставлены с определённым Handler'ом.

# HandlerExceptionResolver

`HandlerExceptionResolver` — это интерфейс в пакете `org.springframework.web.servlet`, который определяет метод для обработки исключений, возникающих на различных этапах обработки запроса (например, в `HandlerAdapter`, при валидации, или в `HttpMessageConverter`). Его задача:

- Перехватить исключение.
- Преобразовать его в HTTP-ответ с соответствующим статусом, заголовками и телом (например, JSON с описанием ошибки для REST API).
- Вернуть объект `ModelAndView` (для MVC) или `null` (для REST API, где ответ формируется напрямую).

# @Controller и @RestController

- **`@RestController` = `@Controller` + `@ResponseBody`**.
- `@Controller` подходит для MVC-приложений с рендерингом представлений.
- `@RestController` оптимизирован для REST API с возвратом данных.
- В Spring Boot оба типа контроллеров легко интегрируются с `DispatcherServlet` и другими компонентами.
- Выбор зависит от архитектуры приложения: серверный рендеринг (`@Controller`) или API (`@RestController`).

# @RequestParam и @PathVariable

|**Характеристика**|**`@RequestParam`**|**`@PathVariable`**|
|---|---|---|
|**Источник данных**|Извлекает параметры из строки запроса (query parameters) или тела формы (`application/x-www-form-urlencoded`).|Извлекает значения из переменных в URL-пути (path variables).|
|**Пример URL**|`GET /api/users?name=John&age=25`|`GET /api/users/123` (где `123` — переменная пути).|
|**Синтаксис в контроллере**|`@RequestParam String name`|`@PathVariable Long id`|
|**Обязательность**|Необязательный по умолчанию (можно настроить через `required=false`).|Обязательный по умолчанию (ошибка 404, если переменная отсутствует).|
|**Использование**|Для фильтров, поисковых запросов, необязательных параметров.|Для идентификации ресурсов в REST API (например, ID объекта).|
|**Поддерживаемые типы**|Простые типы (`String`, `int`, `long`), массивы, коллекции.|Простые типы, часто `String`, `Long`, или кастомные типы.|

# @RequestMapping

`@RequestMapping` — это аннотация, которая применяется на уровне класса или метода в контроллерах (помеченных `@Controller` или `@RestController`) для указания, какие HTTP-запросы они обрабатывают. Она позволяет:

- Сопоставлять URL-пути с методами или классами.
- Указывать HTTP-методы (GET, POST, PUT, DELETE и т.д.).
- Настраивать дополнительные условия, такие как заголовки, параметры запроса или типы контента.

`@RequestMapping` обрабатывается `RequestMappingHandlerMapping` и `RequestMappingHandlerAdapter`, которые интегрируются с `DispatcherServlet` для маршрутизации запросов.

# @GetMapping, @PostMapping, @DeleteMapping и прочие

Это более узкие аннотации для маппинга http-методов. @GetMapping — Обрабатывает get-запросы @PostMapping — Обрабатывает post-запросы @DeleteMapping — Обрабатывает delete-запросы @PutMapping — Обрабатывает put-запросы @PatchMapping — Обрабатывает patch-запросы Все написанное ниже характерно также и для других аннотаций. Аннотация @GetMapping — это просто аннотация которая содержит @RequestMapping(method = RequestMethod.GET).Она также позволяет более глубоко настроить метод-обработчик.Ее параметры(они конвертируются в аналогичные параметры @RequestMapping): path — URI headers — заголовки name — имя обработчика params — параметры produces — тип возвращаемых данных(JSON, XML, текст). Используется в REST consumes — тип принимаемых данных. Используется в REST По умолчанию аннотация принимает путь до метода.@GetMapping("managers") = @GetMapping(path = "managers")

# Filter и Interceptor

**Filter** — это компонент из спецификации Java Servlet API, определённый в пакете `javax.servlet`. Он используется для перехвата HTTP-запросов и ответов на уровне веб-контейнера (например, Tomcat) до или после их обработки сервлетом (в Spring — `DispatcherServlet`). Фильтры применяются для выполнения сквозной функциональности, такой как логирование, аутентификация, кодирование, CORS или модификация запросов/ответов.



|**Характеристика**|**Filter**|**Interceptor (HandlerInterceptor)**|
|---|---|---|
|**Спецификация**|Java Servlet API (`javax.servlet.Filter`)|Spring Framework (`org.springframework.web.servlet.HandlerInterceptor`)|
|**Уровень работы**|Работает на уровне веб-контейнера, до/после `DispatcherServlet`.|Работает внутри Spring MVC, после `DispatcherServlet`, но до/после метода контроллера.|
|**Доступ к контексту Spring**|Нет прямого доступа к Spring-контексту (можно получить через `WebApplicationContext`).|Полный доступ к Spring-контексту, бинам и `HandlerMethod`.|
|**Этапы обработки**|Один этап: `doFilter` (до и после цепочки).|Три этапа: `preHandle`, `postHandle`, `afterCompletion`.|
|**Контроль обработки**|Может прервать цепочку, не вызывая `chain.doFilter`.|Может прервать обработку, вернув `false` в `preHandle`.|
|**Доступ к Handler'у**|Нет доступа к `HandlerMethod` (только `ServletRequest`).|Имеет доступ к `Handler` (например, `HandlerMethod`), что позволяет проверять метод контроллера.|
|**Гибкость настройки**|Применяется ко всем URL через `urlPatterns`.|Гибкая настройка через `addPathPatterns`/`excludePathPatterns`.|
|**Типичные задачи**|- Логирование всех запросов.  <br>- CORS.  <br>- Кодировка.  <br>- Сжатие ответа.  <br>- Низкоуровневая аутентификация.|- Аутентификация/авторизация в Spring.  <br>- Логирование вызовов контроллеров.  <br>- Модификация `ModelAndView` (в MVC).  <br>- Проверка прав доступа.|
|**Производительность**|Выполняется раньше, минимальная зависимость от Spring.|Выполняется позже, зависит от контекста Spring.|
|**Применение в Spring Boot**|Регистрируется через `@WebFilter` или `FilterRegistrationBean`.|Регистрируется через `WebMvcConfigurer`.|
|**Пример использования**|Обработка CORS для всех запросов.|Проверка JWT-токена для защищённых API-методов.|

# RestTemplate и WebClient

Класс RestTemplate является центральным инструментом для выполнения клиентских HTTP-операций в Spring. Он предоставляет несколько утилитных методов для создания HTTP-запросов и обработки ответов.

Spring WebClient — это реактивный, неблокирующий HTTP-клиент, входящий в состав Spring WebFlux, предназначенный для выполнения асинхронных HTTP-запросов. Он предоставляет современную альтернативу устаревшему `RestTemplate`, поддерживая реактивные потоки (`Mono` и `Flux`) и предлагая гибкие возможности настройки. WebClient построен на базе реактивного стека Reactor и Netty, что делает его подходящим для приложений, требующих высокой производительности и масштабируемости.

| Характеристика                 | WebClient                                                        | RestTemplate                                                           |
| ------------------------------ | ---------------------------------------------------------------- | ---------------------------------------------------------------------- |
| **Архитектура**                | Реактивная, неблокирующая (Reactor, Netty)                       | Блокирующая, синхронная (HttpURLConnection, Apache HttpClient, OkHttp) |
| **Поддержка реактивности**     | Да (Mono, Flux)                                                  | Нет                                                                    |
| **Производительность**         | Высокая для множества одновременных запросов (асинхронность)     | Ограничена из-за блокирующего ввода-вывода                             |
| **Таймауты по умолчанию**      | Connect: 30 сек, Read/Write: отсутствуют                         | Connect/Read: отсутствуют (зависят от клиента)                         |
| **Кодеки/Форматы**             | JSON (Jackson), Form, Multipart, Text, ByteArray (настраиваемые) | JSON, XML, Form, другие (через MessageConverter)                       |
| **Ограничение размера ответа** | 256 КБ в памяти (настраиваемый)                                  | Без ограничений (зависит от JVM)                                       |
| **HTTP-клиент**                | Reactor Netty (HTTP/1.1, HTTP/2)                                 | HttpURLConnection, Apache HttpClient, OkHttp                           |
| **Обработка ошибок**           | Через onStatus, реактивные операторы                             | Через ResponseErrorHandler или исключения                              |
| **Retry**                      | Через Reactor (retry оператор)                                   | Требует ручной реализации                                              |
| **Прокси**                     | Через Netty (настраиваемый)                                      | Через JVM или клиент (например, Apache HttpClient)                     |
| **Компрессия**                 | Поддерживается (настраивается через Netty)                       | Поддерживается (зависит от клиента)                                    |
| **Логирование**                | Через фильтры или Netty wiretap                                  | Через Interceptor или клиент                                           |
| **Базовый URL**                | Настраиваемый через builder                                      | Настраиваемый через конструктор                                        |
| **Поддержка WebSocket**        | Да                                                               | Нет                                                                    |
| **Spring Boot интеграция**     | Автонастройка через WebClient.Builder                            | Автонастройка через RestTemplateBuilder                                |
| **Статус**                     | Рекомендуемый для новых приложений                               | Устаревший (с Spring 5)                                                |
| **Использование**              | Реактивные, асинхронные приложения                               | Традиционные, синхронные приложения                                    |

# @ResponseBody и ResponseEntity

ResponseEntity - Это специальный класс, который представляет http-ответ. Он содержит тело ответа, код состояния, заголовки. Мы можем использовать его для более тонкой настройки http-ответа. Он является универсальным типом, и можно использовать любой объект в качестве тела.

`@RequestBody` — это аннотация из пакета `org.springframework.web.bind.annotation`, которая указывает, что параметр метода контроллера должен быть привязан к телу входящего HTTP-запроса. Spring использует `HttpMessageConverter` (например, `MappingJackson2HttpMessageConverter` для JSON) для десериализации тела запроса в объект Java.

- **Назначение**: Преобразовать тело запроса (например, JSON `{ "name": "John" }`) в объект Java (например, `User`).
- **Типичное использование**: В REST API для обработки данных, отправленных в запросах POST, PUT или PATCH.
- **Место применения**: На параметрах методов контроллеров, помеченных `@Controller` или `@RestController`.


