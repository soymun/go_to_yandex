# Aop и сквозная функциональность

Сквозная Функциональность — функциональность, которая может потребоваться вам на нескольких различных уровнях — логирование, управление производительностью, безопасность и т.д.

Аспектно-ориентированное программирование (АОП) - парадигма программирования, основанная на идее разделения функциональности для улучшения разбиения программы на модули. AOP и Spring - взаимодополняющие технологии, которые позволяют решать сложные проблемы путем разделения функционала на отдельные модули. АОП предоставляет возможность реализации сквозной логики - т.е. логики, которая применяется к множеству частей приложения - в одном месте и обеспечения автоматического применения этой логики по всему приложению. Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики.

# Weaving, target и introduction в АОП

Связывание(англ. weaving) представляет собой процесс действительной вставки аспектов в определенную точку кода приложения. Для решений АОП времени компиляции это делается на этапе компиляции, обычно в виде дополнительного шага процесса сборки. Аналогично, для решений АОП времени выполнения связывание происходит динамически во время выполнения. В AspectJ поддерживается еще один механизм связывания под названием связывание во время загрузки (load-time weaving - LTW), который перехватывает лежащий в основе загрузчик классов JVM и обеспечивает связывание с байт-кодом, когда он загружается загрузчиком классов.

Цель(англ. target) - это объект, поток выполнения которого изменяется каким-то процессом АОП. На целевой объект часто ссылаются как на объект, снабженный советом.

Внедрение (англ. introduction, введение) - представляет собой процесс, посредством которого можно изменить структуру объекта за счет введения в него дополнительных методов или полей, изменение иерархии наследования для добавления функциональности аспекта в инородный код. Обычно реализуется с помощью некоторого метаобъектного протокола (англ. metaobject protocol, MOP).

# Порядок выполнения (Ordering) аспектов

**Порядок имеет решающее значение!** Вы наверняка хотите, чтобы проверка безопасности произошла **до** начала транзакции. Если проверка провалится, не нужно тратить ресурсы на открытие транзакции, которую тут же придется откатить.

Для управления порядком используются:

1. **Аннотация `@Order(value)`**
2. **Интерфейс `org.springframework.core.Ordered`**

# Proxy

Прокси это специальный объект, который имеет такие же публичные методы как и бин, но у которого есть дополнительная функциональность.Два вида прокси:

JDK dynamic proxy — динамическое прокси. API встроены в JDK. Объекты создаются на основе интерфейсов.

CGLib proxy — не встроен в JDK. Используется когда интерфейс объекта недоступен, он создает классы наследники.

Плюсы прокси-объектов:Позволяют добавлять доп. логику — управление транзакциями, безопасность, логирование

Отделяет некоторый код(логирование и т.п.) от основной логики
# Создание Proxy

**JDK Dynamic Proxy может создавать прокси только для классов, которые реализуют один или несколько интерфейсов.**
Он не может проксировать "чистые" классы (POJO), которые не имплементируют интерфейсы. Именно поэтому для таких случаев Spring использует библиотеку CGLIB.
В этом механизме всего два главных действующих лица из пакета `java.lang.reflect:
1. **`java.lang.reflect.Proxy`:** Это утилитный класс-фабрика. Его основная задача — создавать новые прокси-классы и их экземпляры. У него нет публичного конструктора, и вы работаете с ним только через статические методы, главный из которых — `newProxyInstance()`.
2. **`java.lang.reflect.InvocationHandler`:** Это интерфейс. И это **сердце** всего механизма. Ваша "логика аспекта" (логирование, безопасность, транзакции) будет жить именно здесь. У этого интерфейса всего один метод:

**CGLIB может создавать прокси для любого класса, который не является `final` и имеет не-`final` методы. Ему не нужны интерфейсы.**
Он достигает этого за счет другой стратегии — **создания подкласса (наследования)**, а не реализации интерфейса.
Основные классы CGLIB находятся в пакете `org.springframework.cglib` (Spring включает свою перепакованную версию CGLIB, чтобы избежать конфликтов версий).
1. **`net.sf.cglib.proxy.Enhancer`:** Это аналог `java.lang.reflect.Proxy` из JDK. `Enhancer` (Улучшатель) — это класс-фабрика, который динамически создает подкласс вашего целевого класса, "улучшая" его новым поведением.
2. **`net.sf.cglib.proxy.MethodInterceptor`:** Это аналог `java.lang.reflect.InvocationHandler`. Это интерфейс, который вы реализуете, чтобы определить логику перехвата. Его единственный метод `intercept` — это то место, где будет жить ваш "аспект".

# Aspect

Аспект (англ. aspect) - модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом.

@Aspect @Component public class MyAspect { ... }

@Aspect: Говорит Spring: "Этот класс содержит AOP-логику, проанализируй его на наличие Pointcut'ов и Advice'ов". @Component: Говорит Spring: "Создай экземпляр этого класса и положи его в IoC-контейнер как бин".

Без @Component (или аналога) Spring проигнорирует ваш класс с @Aspect

# Pointcut

Срез (англ. pointcut) - набор точек соединения. Срез определяет, подходит ли данная точка соединения к данному совету. Самые удобные реализации АОП используют для определения срезов синтаксис основного языка (например, в AspectJ применяются Java-сигнатуры) и позволяют их повторное использование с помощью переименования и комбинирования.

@Pointcut("execution(public * com.example.demoAspects.MyService.*(..))") public void callAtMyServicePublic() { }

# Advice

Совет (англ. advice) - фрагмент кода, который должен выполняться в отдельной точке соединения (Pointcut). Существует несколько типов советов, совет может быть выполнен до, после или вместо точки соединения.

@Before — перед вызовом метода @After — после вызова метода @AfterReturning — после возврата значения из функции @AfterThrowing — в случае exception @AfterFinally — в случае выполнения блока finally @Around — можно сделать пред., пост., обработку перед вызовом метода, а также вообще обойти вызов метода.

на один Pointcut можно «повесить» несколько Advice разного типа.

# JointPoint

Точка соединения (англ. joinpoint) - это четко определенная точка в выполняемой программе, где следует применить совет. Типовые примеры точек соединения включают обращение к методу, собственно Method Invocation, инициализацию класса и создание экземпляра объекта. Многие реализации АОП позволяют использовать вызовы методов и обращения к полям объекта в качестве точек соединения.
# Spring AOP и AspectJ

|Характеристика|Spring AOP|AspectJ|
|:--|:--|:--|
|**Основной механизм**|Динамические прокси (JDK/CGLIB)|Модификация байт-кода|
|**Время внедрения (Weaving)**|**Runtime** (во время выполнения)|**Compile-time**, **Post-compile**, **Load-time**|
|**Типы Join Points**|Только выполнение методов|Методы, конструкторы, поля, обработчики исключений и др.|
|**Область действия**|Только Spring-бины|Любые Java-объекты|
|**Производительность**|Небольшой оверхед на вызов прокси|Нет оверхеда в рантайме (т.к. код уже встроен)|
|**Проблема `self-invocation`**|**Присутствует.** Вызов `this.method()` не перехватывается|**Отсутствует** (при compile/load-time weaving), т.к. байт-код изменен|
|**Простота настройки**|Очень просто, "из коробки" в Spring|Требует настройки (плагин для Maven/Gradle, java-агент)|
