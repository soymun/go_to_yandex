# Аутентификация и авторизация

Аутентификация — процесс верификации пользователя компьютерной системы.Вот как он происходит в Spring:
1. Полученные пароль и имя пользователя преобразуются в экземпляр UsernamePasswordAuthenticationToken. Он реализует интерфейс Authentication.
2. Токен передается объекту AuthenticationManager для проверки
3. В случае удачной проверки AM возвращает заполненный объект Authentication
4. Устанавливается security context, с помощью вызова SecurityContextHolder.getContext().setAuthentication(...)

Авторизация — это процесс удостоверения в том, что у пользователя есть роль, требуемая чтобы сделать какое-либо действие. При авторизации проверяется, есть ли у вас соответствующие права на доступ к ресурсу. Процесс:
1. По принципалу(principal) пользователя отображается его роль
2. Роль пользователя сверяется с ролью ресурса Сначала происходит аутентификация, а потом — авторизация.

# Что такое Spring Security

Spring Security решает задачи обеспечения безопасности веб-приложений, REST API, микросервисов и других типов приложений. Основные цели:

- Аутентификация: Проверка, кто пользователь (например, через логин/пароль, JWT, OAuth2).
- Авторизация: Определение, что пользователь может делать (роли, разрешения).
- Защита от атак: Предотвращение CSRF, XSS, SQL-инъекций, фиксация сессий и других уязвимостей.
- Интеграция: Поддержка LDAP, SAML, OAuth2, OpenID Connect и других стандартов.

Spring Security построен на концепции фильтров (Servlet Filters) и использует цепочку фильтров (FilterChain) для обработки запросов. Это позволяет гибко настраивать процесс безопасности.

В Spring Security цепочка фильтров реализуется через **Servlet Filter**, который является частью спецификации Java Servlet API. Spring Security использует специальный фильтр под названием `FilterChainProxy`, который выступает в роли центрального элемента, управляющего цепочкой фильтров безопасности.

- **DelegatingFilterProxy**: Это основной фильтр, зарегистрированный в контейнере сервлетов (например, Tomcat). Он перехватывает все HTTP-запросы и передает их через цепочку фильтров безопасности.
- **Security Filter Chain**: Внутри `DelegatingFilterProxy` содержится одна или несколько цепочек фильтров безопасности (`SecurityFilterChain`). Каждая цепочка фильтров соответствует определенному набору URL-шаблонов, определенных в конфигурации (например, `/api/**` или `/admin/**`).

Каждая цепочка фильтров состоит из набора фильтров (`Filter`), которые выполняются последовательно. Каждый фильтр выполняет свою задачу и передает управление следующему фильтру в цепочке или конечному ресурсу (например, контроллеру Spring MVC).

# Основные объекты, участвующие в Spring Security

`SecurityContext` — это интерфейс в Spring Security (`org.springframework.security.core.context.SecurityContext`), который представляет контекст безопасности для текущего потока выполнения (thread). Его основная задача — хранить объект `Authentication`, содержащий информацию о текущем пользователе, его учетных данных и полномочиях.
- **Хранение данных аутентификации**: Содержит информацию о том, кто аутентифицирован (или не аутентифицирован).
- **Доступность**: Доступен через `SecurityContextHolder` в любом месте приложения.
- **Потокобезопасность**: Привязан к текущему потоку выполнения, что делает его безопасным для использования в многопоточных приложениях.

`SecurityContextHolder` — это утилитный класс, который управляет доступом к `SecurityContext`. Он предоставляет статические методы для получения и установки контекста безопасности.

`UserDetailsService` — это интерфейс в пакете `org.springframework.security.core.userdetails`, который:
    - Загружает данные пользователя (объект `UserDetails`) по имени пользователя (`username`).
    - Используется Spring Security для аутентификации, когда нужно проверить, существует ли пользователь и какие у него права.

`UserDetails` — это интерфейс, который возвращается методом `loadUserByUsername`. Он предоставляет основные данные о пользователе:
- Имя пользователя.
- Пароль (обычно зашифрованный).
- Список ролей (`GrantedAuthority`), например, `ROLE_USER`, `ROLE_ADMIN`.
- Флаги состояния аккаунта (активен, не заблокирован и т.д.).

`AuthenticationManager` — это интерфейс в пакете `org.springframework.security.authentication`, который:
    - Принимает объект `Authentication`, содержащий учетные данные (например, имя пользователя и пароль или токен).
    - Проверяет их подлинность и возвращает полностью аутентифицированный объект `Authentication`, если проверка успешна.
    - Если аутентификация не удалась, выбрасывает `AuthenticationException` (например, `BadCredentialsException`).

`MethodSecurityInterceptor` — это реализация интерфейса `MethodInterceptor` из Spring AOP, которая перехватывает вызовы методов, помеченных аннотациями методной безопасности, и выполняет проверки доступа. Он активируется при включении методной безопасности с помощью аннотации `@EnableMethodSecurity` (или устаревшей `@EnableGlobalMethodSecurity`).

SpEL — это язык выражений, позволяющий динамически вычислять условия на основе контекста выполнения. В Spring Security он используется для:
- Проверки прав доступа (например, ролей, прав, пользовательских атрибутов).
- Фильтрации данных (входных или возвращаемых коллекций).
- Доступа к данным текущего пользователя (`Authentication`), параметрам метода, возвращаемым объектам и кастомным бинам.
SpEL-выражения пишутся в виде строк и оцениваются во время выполнения с использованием контекста, предоставляемого Spring Security.

# Какие есть ключевые фильтры Spring Security

1. **`ChannelProcessingFilter`**:
    - Проверяет, что запрос использует правильный протокол (например, требует HTTPS для защищённых ресурсов).
    - Редко используется в API с JWT, так как HTTPS обычно обеспечивается на уровне сервера.
2. **`SecurityContextPersistenceFilter`**:
    - Загружает `SecurityContext` из репозитория (например, `HttpSession`) в `SecurityContextHolder` в начале запроса.
    - После обработки запроса сохраняет или очищает `SecurityContext`.
    - В stateless-режиме (с JWT) сессия не используется, но фильтр всё равно выполняется, чтобы обеспечить чистый `SecurityContext`.
3. **`ConcurrentSessionFilter`**:
    - Управляет сессиями, проверяя, не превышен ли лимит одновременных сессий для пользователя.
    - Не используется в stateless API с JWT.
4. **`WebAsyncManagerIntegrationFilter`**:
    - Интегрирует Spring Security с асинхронной обработкой запросов (например, для `@Async` или WebFlux).
    - Обеспечивает доступ к `SecurityContext` в асинхронных потоках.
5. **`CsrfFilter`**:
    - Проверяет CSRF-токены для защиты от межсайтовых подделок запросов.
    - Обычно отключается для stateless API с JWT (`http.csrf().disable()`), так как JWT передаётся в заголовке.
6. **`LogoutFilter`**:
    - Обрабатывает запросы на выход (logout).
    - В контексте JWT редко используется, так как выход обычно реализуется на стороне клиента (удаление токена).
7. **`UsernamePasswordAuthenticationFilter`**:
    - Обрабатывает аутентификацию через форму (логин/пароль).
    - Не используется для JWT, так как аутентификация выполняется через токен.
8. **`DefaultLoginPageGeneratingFilter`**:
    - Генерирует страницу логина, если она не настроена.
    - Не применяется в API с JWT.
9. **`DefaultLogoutPageGeneratingFilter`**:
    - Генерирует страницу выхода.
    - Не применяется в API с JWT.
10. **`BasicAuthenticationFilter`**:
	- Обрабатывает HTTP Basic Authentication.
	- Может использоваться в API, но обычно заменяется JWT-фильтром.
11. **`RequestCacheAwareFilter`**:
	- Восстанавливает запросы, сохранённые в кэше (например, после перенаправления на страницу логина).
	- Не используется в stateless API.
12. **`SecurityContextHolderAwareRequestFilter`**:
	- Оборачивает запрос в объект, совместимый с `SecurityContextHolder`, предоставляя доступ к данным аутентификации.
	- Используется редко, но может быть полезен для интеграции с другими системами.
13. **`AnonymousAuthenticationFilter`**:
	- Устанавливает анонимную аутентификацию (`AnonymousAuthenticationToken`) для запросов, не прошедших аутентификацию.
	- Используется, если требуется обработка анонимных пользователей.
14. **`SessionManagementFilter`**:
	- Управляет сессиями (например, фиксирует сессию для предотвращения атак фиксации сессий).
	- Не используется в stateless API с JWT.
15. **`ExceptionTranslationFilter`**:
	- Перехватывает исключения, связанные с безопасностью (например, `AuthenticationException`, `AccessDeniedException`), и преобразует их в HTTP-ответы (401, 403).
	- Важен для обработки ошибок при недействительном JWT.
16. **`FilterSecurityInterceptor`**:
	- Последний фильтр, проверяет доступ к ресурсу на основе правил авторизации (например, аннотаций `@PreAuthorize` или конфигурации `HttpSecurity`).
	- Если доступ запрещён, выбрасывает `AccessDeniedException`.

# OncePerRequestFilter

`OncePerRequestFilter` — это базовый класс в Spring Framework, который расширяет `GenericFilterBean` и гарантирует, что метод фильтрации (`doFilterInternal`) вызывается **ровно один раз** для каждого HTTP-запроса, даже если запрос перенаправляется (forward) или повторно обрабатывается внутри приложения (например, в случае включения других сервлетов или фильтров).

# Аннотации для методной безопасности

|Аннотация|Когда выполняется|Что делает|Особенность|Пример|
|---|---|---|---|---|
|**@PreAuthorize**|**До** вызова метода|**Проверяет права доступа**|Мощная проверка через SpEL|`@PreAuthorize("hasRole('ADMIN')")`|
|**@PostAuthorize**|**После** вызова метода|**Проверяет права доступа** к результату|Проверка на основе возвращённых данных|`@PostAuthorize("returnObject.owner == principal.name")`|
|**@PreFilter**|**До** вызова метода|**Фильтрует** входящую коллекцию|Удаляет из коллекции-аргумента элементы, не прошедшие проверку|`@PreFilter("filterObject.owner == principal.name")`|
|**@PostFilter**|**После** вызова метода|**Фильтрует** исходящую коллекцию|Удаляет элементы из возвращаемой коллекции|`@PostFilter("filterObject.isPublic == true")`|
|**@Secured**|**До** вызова метода|**Проверяет роли**|Простая проверка по списку ролей (без SpEL)|`@Secured("ROLE_ADMIN")`|
|**@RolesAllowed**|**До** вызова метода|**Проверяет роли**|Аналог `@Secured`, стандарт JSR-250|`@RolesAllowed({"ROLE_USER", "ROLE_ADMIN"})`|

# Аннотации для аутентификации

Вот более лаконичное описание этих аннотаций.

@AuthenticationPrincipal - Внедряет объект **текущего пользователя** (`Principal`) напрямую в параметр метода. Это самый простой способ получить `UserDetails` или ваш кастомный объект пользователя.

@CurrentSecurityContext - Внедряет **контекст безопасности** (`SecurityContext`) или его часть в параметр метода. Позволяет с помощью SpEL-выражения "вытащить" любую нужную деталь, например, только имя пользователя или его права.
# Кодирование

Кодирование — это процесс преобразования данных из одного формата в другой, чтобы сделать их совместимыми с определённой системой или протоколом. Это **обратимый** процесс, не предназначенный для обеспечения безопасности.

# Шифрование

Шифрование — это процесс преобразования данных в нечитаемый вид с использованием ключа, чтобы защитить их от несанкционированного доступа. Это **обратимый** процесс, но только при наличии правильного ключа.

# JWT

В современном веб-разработке вопрос безопасной и масштабируемой аутентификации и авторизации пользователей стал как никогда актуален. Классические механизмы сессий на стороне сервера постепенно уступают место более гибким подходам, основанным на **токенах**, среди которых наибольшее распространение получил **JWT (JSON Web Token)**.

**JWT** – это компактный, самодостаточный и криптографически подписанный токен, позволяющий передавать информацию между участниками системы без необходимости хранить сессионные данные на сервере. Благодаря своей структуре и универсальности, JWT активно применяется в:

- REST API,
- микросервисных архитектурах,
- мобильных и SPA-приложениях,
- а также во многих реализациях **OAuth 2.0** и **OpenID Connect**.

Однако популярность JWT также породила массу недопониманий: как правильно его генерировать? Как надёжно валидировать? Чем отличается свой токен от токена внешнего провайдера? Какие уязвимости типичны и как их избежать?

Цель данной статьи – **не просто объяснить, что такое JWT**, но и **показать, как он работает на практике**, с примерами на **Spring Boot (Java)** и **Go (Gin Framework)**.

Статья будет полезна как начинающим разработчикам, так и инженерам, переходящим к построению распределенных, безопасных систем.

В ходе материала мы:

- разберём, как устроен JWT изнутри (Header, Payload, Signature),
- покажем отличие **JWS** от **JWE**,
- сравним **сессионную и токен-ориентированную модели**,
- рассмотрим два ключевых сценария: **валидация “своего” токена** и **валидация токена от внешнего OIDC-провайдера**,
- внедрим JWT в Spring Boot и Go-приложение,
- проанализируем уязвимости, связанные с JWT, и способы их устранения,
- дополним всё **диаграммами PlantUML** для лучшего понимания процессов.

## Что такое JWT? RFC 7519 и назначение токенов

**JSON Web Token (JWT)** – это стандарт (RFC 7519), описывающий компактный и URL-безопасный способ передачи определенных _утверждений_ (claims) между сторонами в виде JSON-объекта. Проще говоря, JWT представляет собой **цифровой токен**, который можно подписывать (или шифровать) и использовать для безопасной передачи информации. Этот токен самодостаточен: он содержит всю необходимую информацию для проверки своей подлинности без обращения к внешнему хранилищу данных. Благодаря цифровой подписи данные внутри JWT могут быть проверены на целостность и источник – получатель токена может убедиться, что он выдан доверенной системой и не был подделан.

JWT-токены широко применяются в современных веб-приложениях, особенно для задач аутентификации и авторизации. Например, после успешного логина пользователь может получить JWT, который затем отправляется с каждым запросом вместо традиционной серверной сессии. В отличие от механизмов с сохранением сессий на сервере, JWT позволяют системе работать без сохранения состояния на стороне сервера (stateless), что упрощает масштабирование и взаимодействие между разными сервисами. JWT стали популярны в экосистемах OAuth 2.0 и OpenID Connect, превращая простые OAuth-серверы авторизации в полноценные identity-провайдеры. В этих стандартах JWT используется как формат **ID Token** и **Access Token**, переносящий информацию о пользователе и правах доступа.

Важно понимать, что термин «JWT» обычно относится к токену в целом, однако на практике токен может быть _подписан_ или _зашифрован_. JWT является частью семейства спецификаций JOSE (JSON Object Signing and Encryption). Если токен подписан, мы имеем дело с **JWS (JSON Web Signature)**; если токен зашифрован, это **JWE (JSON Web Encryption)**. Далее мы подробно рассмотрим структуру JWT, типы токенов и их использование на практике.

## Сессионный подход vs токен на основе JWT

В веб-приложениях распространены два основных подхода хранения состояния аутентификации пользователя между запросами: **на основе сессий (cookie-based)** и **на основе токенов (token-based)**. Оба решают одну задачу – позволяють пользователю не вводить логин и пароль при каждом запросе – но делают это по-разному, со своими плюсами и минусами.

**Сессионная аутентификация (на cookies):** при классическом подходе после успешного входа на сервере создается сессия, привязанная к пользователю. Сервер хранит данные сессии (например, ID пользователя, время входа, роли и др.) в памяти или базе данных, а клиент получает _сеансовый идентификатор_ в виде cookie. Браузер автоматически отправляет этот cookie с каждым запросом, и сервер по идентификатору находит данные сессии и понимает, что запрос от аутентифицированного пользователя. Такой подход прост и удобен – браузер сам управляет cookie. При выходе пользователя сервер инвалидирует (удаляет) сессию и/или отдает cookie с истекшим сроком, разрывая сессию. Однако сессии требуют хранения состояния: данные о каждом залогиненном пользователе находятся на сервере. Это накладывает ограничения на **масштабирование** – если у вас несколько серверов, нужно либо “прилипание” пользователя к одному серверу, либо общая база/кэш для сессий, что усложняет архитектуру и может стать узким местом. Кроме того, каждая сессия занимает память, и слишком большое число активных сессий может влиять на ресурсы сервера.

**Токен-ориентированная аутентификация (JWT):** при подходе с JWT состояние сессии хранится **на клиенте** в самом токене, а сервер не сохраняет пользовательские данные между запросами. После успешной проверки логина сервер выдает _подписанный JWT-токен_ и отправляет его клиенту (например, в теле ответа или устанавливая в cookie). Браузер или клиентское приложение сохраняет этот токен (в памяти, LocalStorage, или в cookie) и добавляет его в заголовок **Authorization: Bearer …** при последующих запросах к серверу. Сервер, получив запрос, **проверяет подпись** токена и извлекает из него информацию о пользователе, правах и т.д., без необходимости обращаться к базе данных. Такой механизм является stateless – сервер ничего не хранит о сессии, он только выдает и проверяет токены. Это значительно упрощает горизонтальное масштабирование и интеграцию микросервисов: любой сервер с нужным секретным ключом может проверить JWT, независимо от других узлов. Также JWT легко использовать в сценариях, когда запросы идут не из браузера, а, например, от мобильных приложений или между сервисами, – не нужно полагаться на браузерные cookies иorigin, токен можно передать в API-запросе.

**Сравнение подходов:** Использование JWT вместо сессий имеет ряд преимуществ: приложение становится независимым от сервера сессий, легче масштабируется и может работать кросс-доменно (токен можно передавать между доменами/API). JWT – самодостаточный носитель информации о пользователе (идентификатор, роли и пр.), поэтому снижается количество запросов к базе данных за эти сведения при каждом обращении. Однако есть и **обратная сторона**: безопасность токенов целиком лежит на правильной реализации. В случае серверной сессии разработчик может просто удалить сессию на сервере, чтобы разлогинить пользователя, – и cookie тут же станет невалидным. С JWT же **нет встроенного механизма отзыва** токена: пока указанное в нем время жизни не истечет, токен считается действительным при проверке подписи. Если пользователя нужно принудительно разлогинить (отозвать токен до экспирации), придется реализовывать дополнительный механизм – например, хранить «черный список» отозванных токенов на сервере и проверять по нему каждую просьбу. Это частично возвращает нас к хранению состояния на сервере, нивелируя преимущество stateless-подхода. Кроме того, **компрометация токена** несет больший риск: если злоумышленник похитит JWT (например, через XSS-атаку, см. раздел «Безопасность»), он получит доступ к ресурсам от имени пользователя до истечения срока токена. В случае же кражи cookie с session-id можно хотя бы оперативно уничтожить серверную сессию.

В целом, выбор между сессией и JWT зависит от требований проекта. Для **традиционных веб-сайтов** с серверными рендерингом и одной точкой входа зачастую проще и безопаснее использовать серверные сессии (cookie), получая автоматическую защиту от повторного использования токена при логауте и встроенную отправку cookie браузером. Но **в распределенных системах и REST API** (особенно при работе с мобильными или SPA-клиентами) JWT-токены дают большую гибкость и масштабируемость. Нередко эти подходы комбинируют: например, хранят JWT в http-only cookie, совмещая преимущества (статус на клиенте + автоматическая отправка браузером). Важно лишь тщательно проработать **безопасность**, о чем мы подробно поговорим ниже.

## Структура JWT: Header, Payload, Signature

JWT-токен имеет строго определенную структуру – это строка, состоящая из **трех частей**, разделенных точками: `Header.Payload.Signature`. Каждая часть – это данные в формате JSON, закодированные в Base64 URL-safe.

_Структура JWT._ На схеме слева показаны три основные части токена, а справа – пример содержимого. **Header** обычно содержит тип токена (`JWT`) и алгоритм подписи (`HS256` и др.). **Payload** включает набор _claims_ – утверждений о пользователе и параметров токена (например, идентификатор пользователя, роли, время выпуска и истечения). **Signature** – это криптографическая подпись, полученная путем вычисления HMAC-SHA256 от соединения закодированного заголовка и payload с секретным ключом (при симметричном алгоритме). Подпись служит для проверки целостности и подлинности: она гарантирует, что никто не изменил данные токена с момента его выпуска.

Рассмотрим каждую часть подробнее:

- **Header (заголовок):** содержит метаданные токена. Обязательные поля – это тип токена `typ` (для JWT всегда `"JWT"`) и алгоритм подписи `alg` (например, `"HS256"` для HMAC-SHA256, `"RS256"` для RSA и т.д.). Могут присутствовать дополнительные поля, например `kid` (key ID) – идентификатор ключа, которым подписан токен, используемый для выбора ключа из набора (актуально при асимметричной подписи, об этом далее).

```
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- **Payload (полезная нагрузка):** содержит сами _claims_ – утверждения о субъекте токена (пользователе или системе) и другие данные. Существует ряд стандартных (зарезервированных) полей: например, `iss` (issuer, издатель токена), `sub` (subject, субъект токена – обычно идентификатор пользователя), `aud` (audience, аудитория токена – для какого приложения или сервиса он предназначен), `exp` (expiration time, время истечения), `iat` (issued at, время выпуска), `nbf` (not before, время, раньше которого токен недействителен), `jti` (JWT ID, уникальный идентификатор токена). Эти поля необязательны, но часто используются. Помимо них, payload может содержать любые _публичные или приватные_ claims – произвольные пары «ключ-значение» с дополнительной информацией. Например, можно включить `name` или `email` пользователя, список его ролей (`roles`) или разрешений. Важно помнить, что содержимое payload **не шифруется** (в случае JWS-токена) – оно только закодировано в Base64. Любой, кто получит JWT, может расшифровать payload и прочитать данные, поэтому туда нельзя помещать конфиденциальную информацию в открытом виде (пароли, личные данные, секретные ключи и т.п.).

Пример payload с некоторыми стандартными claim и дополнительными полями:

```
{
  "iss": "myapp.example.com",
  "sub": "user12345",
  "iat": 1644744000,
  "exp": 1644768000,
  "role": "admin",
  "name": "John Doe"
}
```

Здесь `iss` указывает, кем выдан токен (наш сервис), `sub` – идентификатор пользователя, `iat`/`exp` – метки времени выпуска и истечения токена (в формате UNIX timestamp). Дополнительно добавлены `role` и `name` пользователя.

- **Signature (подпись):** результат криптографической функции, обеспечивающий защиту токена. Для формирования подписи библиотека объединяет закодированный Header и Payload через точку, и вычисляет на них цифровую подпись с помощью указанного в Header алгоритма и секретного ключа. Например, при алгоритме HS256 формула подписи такая:

```
signature = HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret_key )
```

Для RSA- или ECDSA-алгоритмов вместо общего секрета используется приватный ключ для подписи и публичный ключ для проверки. Подпись позволяет проверить, что _Header_ и _Payload_ не были изменены: при валидации JWT сервер заново вычисляет подпись из пришедших Header и Payload и сравнивает с переданной. Если они не совпадают – токен был подделан или поврежден и отклоняется.

**Итоговая сериализация JWT** выглядит как одна строка: три блока Base64, разделенных точками, например:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. 
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvbiBEb2UiLCJyb2xlIjoiYWRtaW4iLCJleHAiOjE2NDQ3NjgwMDB9. 
TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

Этот токен можно легко декодировать, используя инструменты вроде [jwt.io](https://jwt.io/) или командных утилит, чтобы увидеть содержимое Header и Payload. Подпись же не расшифровывается, а проверяется путем вычисления заново.

## Типы JWT: JWS и JWE – подпись vs шифрование

По сути, JWT – это контейнер для данных, который можно либо **подписать** (для защиты целостности), либо **зашифровать** (для конфиденциальности), либо и то, и другое сразу. В спецификации различаются два варианта:

- **JWS (JSON Web Signature):** подписанный JWT. Это самый распространенный тип токенов. В JWS-токене Payload остается открытым (незашифрованным) и может быть прочитан любым получателем, но защищен цифровой подписью. Подпись гарантирует, что данные подлинные и не модифицированы: получатель, зная секрет (для HMAC) или публичный ключ (для RSA/ECDSA), может убедиться, что токен действительно выдан доверенной стороной. **JWT в веб-аутентификации почти всегда представляют собой JWS.** Такие токены удобны тем, что их можно свободно пересылать и кешировать – никаких дополнительных действий, кроме проверки подписи, не нужно. Однако данные в них не являются приватными: хранить чувствительную информацию нельзя, т.к. любой может декодировать payload.
- **JWE (JSON Web Encryption):** зашифрованный JWT. В этом случае содержимое Payload (и опционально Header) шифруется получателю. JWE обеспечивает **конфиденциальность** – даже перехватив токен, злоумышленник не прочитает его содержимое без ключа расшифровки. Однако сам по себе JWE не гарантирует подлинности: если токен только зашифрован, но не подписан, получатель не может быть уверен, кем он создан (если злоумышленник получил публичный ключ шифрования, он тоже мог создать токен, хоть и не читая содержимое). Поэтому обычно JWE-токены применяют в сочетании с подписью: например, сначала подписать данные (JWS), потом результирующую строку зашифровать – так достигаются и целостность, и конфиденциальность. Структура JWE сложнее: помимо зашифрованного Payload, включает зашифрованный ключ сессии, заголовок с алгоритмами, IV, тег аутентификации и др.. Все эти части соединяются точками, аналогично JWS.

**Когда использовать JWE?** Зашифрованные JWT встречаются значительно реже. В большинстве случаев достаточно подписать токен и просто не помещать в него секретные данные. Сценарии для JWE – когда нужно передать через сторонние системы зашифрованную информацию (например, медицинские данные или персональные сведения) и вы хотите использовать JWT как оболочку. Тогда отправитель шифрует токен на публичном ключе получателя (чтобы только он смог прочесть). Если же данные не столь критичны или уже доступны получателю, лишнее шифрование только увеличит размер токена и нагрузку на систему. Поэтому для задач аутентификации и обмена авторизационной информацией практически всегда используются **JWT с подписью (JWS)**.

Для справки: спецификации JWS и JWE определены в отдельных RFC (7515 и 7516 соответственно). Но разработчикам зачастую достаточно понимать, что «обычный» JWT – это подписанный токен. Если же возникает потребность скрыть содержимое JWT, можно рассмотреть JWE или другой канал шифрования.

## Примеры использования JWT

Рассмотрим, как JWT применяется на практике в разных сценариях. Типичные случаи – это когда приложение само выпускает JWT для своих пользователей, а также когда приложение принимает JWT от стороннего сервиса (например, стороннего провайдера авторизации). В обоих ситуациях важна правильная валидация токена.

### Валидация JWT, выпущенного приложением

Когда токен генерируется и используется в пределах одного приложения (или набора своих сервисов), задача достаточно проста. После того как пользователь прошел аутентификацию (например, отправил логин и пароль, или выполнил OAuth-авторизацию), сервер создает JWT и возвращает его клиенту. Клиент сохраняет токен и отправляет с каждым запросом. Серверу для валидации нужно знать **секретный ключ** (если используется HMAC) или **публичный ключ** (если токен подписан асимметрично). Так как токен наш собственный, эти ключи известны приложению изначально.

Алгоритм проверки такой JWT на сервере включает несколько шагов:

1. Извлечь токен из запроса – обычно он передается в HTTP-заголовке `Authorization: Bearer <token>` (либо в cookie, если решено хранить JWT в cookie). Например, в Go с Gin можно получить заголовок и отделить префикс “Bearer”: `tokenString := c.GetHeader("Authorization")` (в реальном коде нужно убрать префикс и проверить, что заголовок есть). В Spring Boot при использовании Spring Security токен автоматически вынимается фильтром из заголовка.
2. Распарсить токен и проверить **подпись**. С помощью JWT-библиотеки выполняется разбор строки токена: вычисляется подпись заново и сравнивается с ожидаемой. В псевдокоде на Java это выглядит так:
3. Проверить **стандартные claims**: часто токен содержит поле `exp` (время истечения) – сервер должен убедиться, что текущее время меньше указанного и токен не просрочен. Также можно проверить `nbf` (не раньше определенного времени), `iss` (совпадает ли издатель с нашим приложением), `aud` (предназначен ли токен для этого сервиса). Например, получив Claims через `.getBody()` или `token.Claims`, можно сделать:
4. Определить пользователя из токена. После успешной криптографической проверки можно считать токен аутентифицированным. Из claims извлекаются идентификатор или имя пользователя (например, поле `sub` или другой custom claim). Далее приложение обычно загружает информацию о пользователе (например, из базы) или прямо использует claims токена (например, роли) для авторизации.
5. Решить, имеет ли пользователь доступ к запрошенному ресурсу (**авторизация**). JWT может содержать, например, claim `role: admin` или список прав. На основе этих данных и логики приложения происходит проверка, можно ли выполнять данный запрос. (Подробнее о сценариях авторизации – в следующем разделе.)

При собственных JWT нет необходимости в внешних сетевых запросах при валидации – весь механизм работает локально с помощью криптографических функций. Важно лишь хранить секретный ключ в конфигурации безопасно (не светить его в коде или в репозитории). Например, в Spring Boot секрет можно положить в `application.properties`, а доступ к нему дать через аннотацию `@Value`. Никогда не храняйте ключ прямо в коде или в публичных местах – обладая вашим HMAC-секретом, злоумышленник мог бы подписывать любые токены и выдавать себя за любого пользователя.

![](https://i0.wp.com/proselyte.net/wp-content/uploads/2025/06/jwt1.png?resize=571%2C847&quality=80&ssl=1)

_Рис 1. Пример системы, работающей с внешним провайдером._
### Валидация JWT от внешнего провайдера (OpenID Connect, OAuth2)

Другой распространенный случай – ваше приложение не само выдает токены, а доверяет стороннему **провайдеру аутентификации**. Это может быть OAuth2/OpenID Connect сервер (например, Google, Facebook, Auth0, Keycloak и т.д.), который после логина пользователя перенаправляет в ваше приложение JWT – обычно это **ID Token** (JWT с информацией о пользователе) или **Access Token** для API. Как приложению убедиться в подлинности такого токена?

Здесь нельзя использовать заранее известный секрет, ведь токен подписан _чужим_ сервисом. Однако JWT протокол рассчитан на этот случай посредством механизма **JSON Web Key Set (JWKS)**. Провайдер, выпускающий токены, публикует набор своих открытых ключей в формате JWKS – обычно по стандартному URL (например: `https://login.example.com/.well-known/jwks.json`). В JWT токене (в Header) при этом указывается ключ, которым он подписан – через поле `kid` (Key ID), а также алгоритм (`alg`, например RS256).

**JWKS (JSON Web Key Set)** – это JSON-документ, содержащий массив публичных ключей провайдера. Каждый ключ снабжен параметрами: `kid` (идентификатор), `kty` (тип, например RSA), модуль `n` и экспонента `e` для RSA, использование `use` (sig для подписей) и пр.. Ваше приложение может загрузить JWKS провайдера (это делается либо при запуске, либо при первом получении токена, либо библиотеками автоматически) и найти в этом наборе ключ с нужным `kid`. Получив параметры ключа (например, модуль и экспонента RSA), вы создаете из них публичный ключ. Далее процесс верификации такой же, как и раньше: библиотека JWT проверяет подпись токена, но теперь вместо вашего секрета использует публичный ключ поставщика.

![](https://i0.wp.com/proselyte.net/wp-content/uploads/2025/06/jwt3-1.png?resize=700%2C455&quality=80&ssl=1)

_Рис.2 : выше приведена иллюстрация процесса проверки JWT с использованием JWKS: приложение запрашивает у IdP набор ключей, находит нужный публичный ключ по kid, и валидирует подпись токена._

Таким образом, **вализация стороннего JWT** сводится к двум вещам: получению правильного ключа и проверке claims. Последнее особенно важно: чужой токен может быть подписан правильно, но предназначен не для вашего приложения. Поэтому обязательно проверяйте поля `iss` (совпадает ли с доверенным identity-провайдером) и `aud` (содержит идентификатор вашего приложения или ожидаемое значение). OpenID Connect ID Token, например, содержит `aud` равный client_id вашего приложения, и `iss` равный URL провайдера – эти поля следует сверять с конфигом. Также стоит обращать внимание на `exp`/`iat`, чтобы токен не был устаревшим или из будущего.

Современные фреймворки могут облегчить эту работу. В Spring Boot есть starter для **Spring Security OAuth2 Resource Server**, куда достаточно прописать URL Issuer-а (Issuer URI), и он сам скачает JWKS, выберет ключ и будет валидировать токены (библиотека Nimbus JOSE JWT под капотом). В Go существуют библиотеки, например **golang.org/x/oauth2/jwt** или пакеты от Auth0, которые умеют загружать JWKS и кэшировать ключи. Но даже вручную этот процесс реализуем: JWKS обычно меняется нечасто (ключи провайдера ротоируются раз в несколько дней/недель), поэтому приложение может периодически обновлять их копию.

**JSON Web Key (JWK)** – это отдельный ключ в формате JSON. Он может представлять публичный или симметричный ключ. В случае RSA содержит модуль `n` и экспонент `e` в base64url. JWKS – это просто JSON с массивом ключей (под полем `"keys"`). Ниже пример фрагмента JWKS (сокращен):

```
{
 "keys": [
  {
    "kid": "42148Kf",
    "kty": "RSA",
    "alg": "RS256",
    "use": "sig",
    "n": "iGaLqP6y-SJCCBq5Hv6pGDbG_SQ11MNjH7rWHcCFYz4hGwHC4lcSurTlV8u3avoVNM8jX...",
    "e": "AQAB"
  },
  { ... другой ключ ...}
 ]
}
```

По `kid` заголовка нашего JWT мы, например, выберем ключ с `"kid": "42148Kf"`. Используя `n` и `e`, можно воссоздать `RSAPublicKey`. Дальше – стандартная проверка подписи. Токены часто включают `kid` именно для того, чтобы потребителю не пришлось перебирать все ключи – достаточно сразу выбрать нужный.

Стоит отметить, что при интеграции с внешними OpenID Connect-провайдерами помимо проверки подписи, обычно происходит и получение **профильной информации**. Например, после валидного ID Token вы можете вызвать UserInfo endpoint провайдера или использовать данные из токена (имя, email) напрямую. Это за рамками обсуждения JWT, но важно понимать контекст: JWT облегчает доверие между сервисами (вашим приложением и identity-провайдером) за счет криптографии.

Итак, резюмируя проверку чужого JWT:

- Получаем/кешируем JWKS провайдера, выбираем нужный публичный ключ.
- Проверяем подпись токена этим ключом.
- Сверяем claims токена (issuer, audience, exp и др.) с ожидаемыми значениями.
- Считаем токен аутентифицированным и извлекаем из него необходимые данные (например, идентификатор пользователя, email, роли).

## Сценарии использования JWT: аутентификация, авторизация, атрибуты пользователя

JWT применяется в нескольких связанных, но разных сценариях:

- **Аутентификация (authentication):** подтверждение личности пользователя. В этом сценарии JWT выступает аналогом «удостоверения личности». Например, при логине пользователь вводит пароль, сервер проверяет его и возвращает JWT, который содержит информацию о пользователе (как минимум его идентификатор, `sub`). Наличие у клиента корректно подписанного JWT означает для сервера, что пользователь уже прошел аутентификацию ранее. Таким образом, JWT позволяет реализовать _многоразовый логин_: пользователь вводит пароль один раз, получает токен, и затем предъявляет токен при каждом запросе, чтобы подтвердить, кто он. В протоколах OAuth2/OIDC JWT используется в роли **ID Token** – токена, который подтверждает, что «пользователь X аутентифицирован провайдером Y».
- **Авторизация (authorization):** определение прав доступа. JWT удобно не только идентифицировать пользователя, но и передавать **его роли, права или другие атрибуты**, нужные для принятия решений на сервере. Например, в токен можно включить claim `role: admin` или `permissions: ["read","write"]`. При поступлении запроса сервер читает эти claims и решает, разрешено ли пользователю запрашиваемое действие. Это особенно полезно в микросервисной архитектуре: вместо того чтобы каждый сервис запрашивал центральный сервер авторизации «а какие права у пользователя X?», каждый сервис может доверять информации, вложенной в JWT (раз он подписан доверенным источником). Такой подход называется _явным распространением контекста безопасности_. Примеры: токен доступа в OAuth содержит scope – список дозволенных операций; JWT внутри организации может содержать отдел сотрудника, грейд доступа и т.п.
- **Передача пользовательских атрибутов между компонентами:** JWT часто используют для обмена информацией о пользователе между разными сервисами. Например, фронтенд-приложение после логина получает JWT с некоторыми данными пользователя (имя, email, настройки) и может передавать этот токен при запросах к другим сервисам – те получат необходимую базовую информацию из токена, не делая дополнительных запросов к первоисточнику. В распределенных системах JWT стал стандартом передачи сведений об идентификации и правах, поскольку каждый сервис, получив токен, автономно знает, кто пользователь и что ему разрешено. Это снижает связанность и нагрузку на центральную БД или авторизационный сервис. Кроме того, JWT применяется для **SSO (Single Sign-On)**: одна система аутентифицирует пользователя и выпускает JWT, а другие системы, получив этот JWT, «доверяют» ему и автоматически логинят пользователя у себя (конечно, после проверки подписи и аудитории токена). Многие крупные платформы реализуют SSO именно на JWT/OpenID Connect.

_Пример использования JWT в потоках аутентификации и авторизации._ 1) Пользователь вводит свои учетные данные (или использует вход через Google/Facebook). 2) Сервер проверяет их и создает JWT (подписывает токен). 3) Токен отправляется клиенту, который сохраняет его (например, в память приложения или httpOnly cookie). 4) При последующих запросах клиент отправляет токен в заголовке `Authorization`. 5) Сервер принимает токен и валидирует его (проверяет подпись, срок и пр.). 6) Запрос на защищенный ресурс (например, `GET /user/info`) выполняется, сервер на основе информации токена определяет права доступа. 7) Если токен валидный и у пользователя есть права – сервер возвращает запрошенные данные. 8) Если токен недействителен или просрочен – возвращается ошибка (например, `401 Unauthorized`). Этот сценарий показывает, как JWT позволяет единожды залогинившись, обращаться к разным ресурсам без повторной аутентификации, и как на каждом шаге проверяется авторизация по данным токена.

В реальных приложениях JWT может использоваться сразу во всех трех аспектах: как удостоверение личности (аутентификация), как хранилище ролей/прав (авторизация), и как контейнер для переноса дополнительной информации о пользователе. Например, токен может содержать `sub: user123`, `role: admin` и даже некие пользовательские настройки или признаки – все зависит от задач. Но тут важно помнить про баланс между полезностью и безопасностью: включать в токен следует минимально необходимый набор сведений (принцип наименьших привилегий и раскрытия информации).

Хорошей практикой является **разделение токенов по назначению**. Например, в OAuth2 есть понятия **Access Token** и **ID Token**: первый используется _только_ для доступа к ресурсам (и в нем хранятся scopes/права, он может быть JWT или нет), а второй – для передачи информации о пользователе клиентскому приложению (всегда JWT в OIDC). Подобно этому, вы можете выпустить один JWT для внутренних сервисов с подробными правами, а другой – для фронтенда с только минимальными данными для интерфейса.

